;; parameters order of syscall:
define sys_6_r8  r8
define sys_5_r9  r9
define sys_4_r10 r10
define sys_3_rdx rdx
define sys_2_rsi rsi
define sys_1_rdi rdi
define sys_n_rax rax

;; syscall number:
define syscall_read                      0
define syscall_write                     1
define syscall_open                      2
define syscall_close                     3
define syscall_stat                      4
define syscall_fstat                     5
define syscall_lstat                     6
define syscall_poll                      7
define syscall_lseek                     8
define syscall_mmap                      9
define syscall_mprotect                  10
define syscall_munmap                    11
define syscall_brk                       12
define syscall_rt_sigaction              13
define syscall_rt_sigprocmask            14
define syscall_rt_sigreturn              15
define syscall_ioctl                     16
define syscall_pread64                   17
define syscall_pwrite64                  18
define syscall_readv                     19
define syscall_writev                    20
define syscall_access                    21
define syscall_pipe                      22
define syscall_select                    23
define syscall_sched_yield               24
define syscall_mremap                    25
define syscall_msync                     26
define syscall_mincore                   27
define syscall_madvise                   28
define syscall_shmget                    29
define syscall_shmat                     30
define syscall_shmctl                    31
define syscall_dup                       32
define syscall_dup2                      33
define syscall_pause                     34
define syscall_nanosleep                 35
define syscall_getitimer                 36
define syscall_alarm                     37
define syscall_setitimer                 38
define syscall_getpid                    39
define syscall_sendfile                  40
define syscall_socket                    41
define syscall_connect                   42
define syscall_accept                    43
define syscall_sendto                    44
define syscall_recvfrom                  45
define syscall_sendmsg                   46
define syscall_recvmsg                   47
define syscall_shutdown                  48
define syscall_bind                      49
define syscall_listen                    50
define syscall_getsockname               51
define syscall_getpeername               52
define syscall_socketpair                53
define syscall_setsockopt                54
define syscall_getsockopt                55
define syscall_clone                     56
define syscall_fork                      57
define syscall_vfork                     58
define syscall_execve                    59
define syscall_exit                      60
define syscall_wait4                     61
define syscall_kill                      62
define syscall_uname                     63
define syscall_semget                    64
define syscall_semop                     65
define syscall_semctl                    66
define syscall_shmdt                     67
define syscall_msgget                    68
define syscall_msgsnd                    69
define syscall_msgrcv                    70
define syscall_msgctl                    71
define syscall_fcntl                     72
define syscall_flock                     73
define syscall_fsync                     74
define syscall_fdatasync                 75
define syscall_truncate                  76
define syscall_ftruncate                 77
define syscall_getdents                  78
define syscall_getcwd                    79
define syscall_chdir                     80
define syscall_fchdir                    81
define syscall_rename                    82
define syscall_mkdir                     83
define syscall_rmdir                     84
define syscall_creat                     85
define syscall_link                      86
define syscall_unlink                    87
define syscall_symlink                   88
define syscall_readlink                  89
define syscall_chmod                     90
define syscall_fchmod                    91
define syscall_chown                     92
define syscall_fchown                    93
define syscall_lchown                    94
define syscall_umask                     95
define syscall_gettimeofday              96
define syscall_getrlimit                 97
define syscall_getrusage                 98
define syscall_sysinfo                   99
define syscall_times                     100
define syscall_ptrace                    101
define syscall_getuid                    102
define syscall_syslog                    103
define syscall_getgid                    104
define syscall_setuid                    105
define syscall_setgid                    106
define syscall_geteuid                   107
define syscall_getegid                   108
define syscall_setpgid                   109
define syscall_getppid                   110
define syscall_getpgrp                   111
define syscall_setsid                    112
define syscall_setreuid                  113
define syscall_setregid                  114
define syscall_getgroups                 115
define syscall_setgroups                 116
define syscall_setresuid                 117
define syscall_getresuid                 118
define syscall_setresgid                 119
define syscall_getresgid                 120
define syscall_getpgid                   121
define syscall_setfsuid                  122
define syscall_setfsgid                  123
define syscall_getsid                    124
define syscall_capget                    125
define syscall_capset                    126
define syscall_rt_sigpending             127
define syscall_rt_sigtimedwait           128
define syscall_rt_sigqueueinfo           129
define syscall_rt_sigsuspend             130
define syscall_sigaltstack               131
define syscall_utime                     132
define syscall_mknod                     133
define syscall_uselib                    134
define syscall_personality               135
define syscall_ustat                     136
define syscall_statfs                    137
define syscall_fstatfs                   138
define syscall_sysfs                     139
define syscall_getpriority               140
define syscall_setpriority               141
define syscall_sched_setparam            142
define syscall_sched_getparam            143
define syscall_sched_setscheduler        144
define syscall_sched_getscheduler        145
define syscall_sched_get_priority_max    146
define syscall_sched_get_priority_min    147
define syscall_sched_rr_get_interval     148
define syscall_mlock                     149
define syscall_munlock                   150
define syscall_mlockall                  151
define syscall_munlockall                152
define syscall_vhangup                   153
define syscall_modify_ldt                154
define syscall_pivot_root                155
define syscall__sysctl                   156
define syscall_prctl                     157
define syscall_arch_prctl                158
define syscall_adjtimex                  159
define syscall_setrlimit                 160
define syscall_chroot                    161
define syscall_sync                      162
define syscall_acct                      163
define syscall_settimeofday              164
define syscall_mount                     165
define syscall_umount2                   166
define syscall_swapon                    167
define syscall_swapoff                   168
define syscall_reboot                    169
define syscall_sethostname               170
define syscall_setdomainname             171
define syscall_iopl                      172
define syscall_ioperm                    173
define syscall_create_module             174
define syscall_init_module               175
define syscall_delete_module             176
define syscall_get_kernel_syms           177
define syscall_query_module              178
define syscall_quotactl                  179
define syscall_nfsservctl                180
define syscall_getpmsg                   181
define syscall_putpmsg                   182
define syscall_afs_syscall               183
define syscall_tuxcall                   184
define syscall_security                  185
define syscall_gettid                    186
define syscall_readahead                 187
define syscall_setxattr                  188
define syscall_lsetxattr                 189
define syscall_fsetxattr                 190
define syscall_getxattr                  191
define syscall_lgetxattr                 192
define syscall_fgetxattr                 193
define syscall_listxattr                 194
define syscall_llistxattr                195
define syscall_flistxattr                196
define syscall_removexattr               197
define syscall_lremovexattr              198
define syscall_fremovexattr              199
define syscall_tkill                     200
define syscall_time                      201
define syscall_futex                     202
define syscall_sched_setaffinity         203
define syscall_sched_getaffinity         204
define syscall_set_thread_area           205
define syscall_io_setup                  206
define syscall_io_destroy                207
define syscall_io_getevents              208
define syscall_io_submit                 209
define syscall_io_cancel                 210
define syscall_get_thread_area           211
define syscall_lookup_dcookie            212
define syscall_epoll_create              213
define syscall_epoll_ctl_old             214
define syscall_epoll_wait_old            215
define syscall_remap_file_pages          216
define syscall_getdents64                217
define syscall_set_tid_address           218
define syscall_restart_syscall           219
define syscall_semtimedop                220
define syscall_fadvise64                 221
define syscall_timer_create              222
define syscall_timer_settime             223
define syscall_timer_gettime             224
define syscall_timer_getoverrun          225
define syscall_timer_delete              226
define syscall_clock_settime             227
define syscall_clock_gettime             228
define syscall_clock_getres              229
define syscall_clock_nanosleep           230
define syscall_exit_group                231
define syscall_epoll_wait                232
define syscall_epoll_ctl                 233
define syscall_tgkill                    234
define syscall_utimes                    235
define syscall_vserver                   236
define syscall_mbind                     237
define syscall_set_mempolicy             238
define syscall_get_mempolicy             239
define syscall_mq_open                   240
define syscall_mq_unlink                 241
define syscall_mq_timedsend              242
define syscall_mq_timedreceive           243
define syscall_mq_notify                 244
define syscall_mq_getsetattr             245
define syscall_kexec_load                246
define syscall_waitid                    247
define syscall_add_key                   248
define syscall_request_key               249
define syscall_keyctl                    250
define syscall_ioprio_set                251
define syscall_ioprio_get                252
define syscall_inotify_init              253
define syscall_inotify_add_watch         254
define syscall_inotify_rm_watch          255
define syscall_migrate_pages             256
define syscall_openat                    257
define syscall_mkdirat                   258
define syscall_mknodat                   259
define syscall_fchownat                  260
define syscall_futimesat                 261
define syscall_newfstatat                262
define syscall_unlinkat                  263
define syscall_renameat                  264
define syscall_linkat                    265
define syscall_symlinkat                 266
define syscall_readlinkat                267
define syscall_fchmodat                  268
define syscall_faccessat                 269
define syscall_pselect6                  270
define syscall_ppoll                     271
define syscall_unshare                   272
define syscall_set_robust_list           273
define syscall_get_robust_list           274
define syscall_splice                    275
define syscall_tee                       276
define syscall_sync_file_range           277
define syscall_vmsplice                  278
define syscall_move_pages                279
define syscall_utimensat                 280
define syscall_epoll_pwait               281
define syscall_signalfd                  282
define syscall_timerfd_create            283
define syscall_eventfd                   284
define syscall_fallocate                 285
define syscall_timerfd_settime           286
define syscall_timerfd_gettime           287
define syscall_accept4                   288
define syscall_signalfd4                 289
define syscall_eventfd2                  290
define syscall_epoll_create1             291
define syscall_dup3                      292
define syscall_pipe2                     293
define syscall_inotify_init1             294
define syscall_preadv                    295
define syscall_pwritev                   296
define syscall_rt_tgsigqueueinfo         297
define syscall_perf_event_open           298
define syscall_recvmmsg                  299
define syscall_fanotify_init             300
define syscall_fanotify_mark             301
define syscall_prlimit64                 302
define syscall_name_to_handle_at         303
define syscall_open_by_handle_at         304
define syscall_clock_adjtime             305
define syscall_syncfs                    306
define syscall_sendmmsg                  307
define syscall_setns                     308
define syscall_getcpu                    309
define syscall_process_vm_readv          310
define syscall_process_vm_writev         311
define syscall_kcmp                      312
define syscall_finit_module              313
define ascii.linefeed       000Ah;; 10
define ascii.esc            001Bh;; 27
define ascii.space          0020h;; 32
format elf64 executable 3
entry EntryPoint
define CellWidth 8 ;; (unit : byte)

;; if you want to extend xiaolinguist in assembly,
;; the following four registers must not be used
;; =================================
define NextWordPointer      r15
define ReturnStackPointer   r14
define ArgumtStackPointer   r13
define GreyPairStackPointer r12
;; =================================

define ExplainerPointer      rax
define TemporaryRegister    r11
define TemporaryRegister2   r10

;; ``ReturnStackPointer'' always stores the address of TOC (top-of-stack),
;; NOT the address of first-free-place in the stack
macro pushReturnStack Register {
   lea ReturnStackPointer, [ReturnStackPointer - CellWidth]  ;; 入栈时先向上(低地址)移动指针
   mov [ReturnStackPointer], Register                        ;; 再放入值
   }
macro popReturnStack Register {
   mov Register, [ReturnStackPointer]                        ;; 出栈时先取出值
   lea ReturnStackPointer, [ReturnStackPointer + CellWidth]  ;; 再向下(高地址)移动指针
   }

macro pushArgumtStack Register {
   lea ArgumtStackPointer, [ArgumtStackPointer - CellWidth]
   mov [ArgumtStackPointer], Register
   }
macro popArgumtStack Register {
   mov Register, [ArgumtStackPointer]
   lea ArgumtStackPointer, [ArgumtStackPointer + CellWidth]
   }
;; notations :
;; 1. ``the dictionary'' as a datastructure is a single-linked-list
;; 2. an entry in ``the dictionary'' is ``a word''
;; 3. ``a word'' as a datastructure looks like the following :
;;       (unit : CellWidth)
;;    ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
;;    ||  m : name-string  ||
;;    ||  1 : SizeOfFunctionBody  ||
;;    ||  1 : identification  ||
;;    ||  1 : link  ||
;;    ||  1 : type  ||
;;    ||  1 : address-of-name-string-header  ||
;;    ||  1 : address-of-explainer  ||
;;    ||  n : body  ||
;; 4. so, I adopt two notations to represent ``a word'' :
;;    word[link]      == address in a word where the link is stored
;;    word[explainer] == address in a word where the address-of-explainer is stored
;;    word[explainer] == address in a word before the function-body
;;    word[explainer] == address in a word as the head of a function-body


;; note that:
;;   there are only two ways to jump to a explainer
;;   1. next
;;   2. execute


;; not matter what way you use to set :
;;   [ExplainerPointer] == address-of-explainer (of a word you want to jump to)
;; then :
;;   jmp qword[ExplainerPointer]
;; it will works just well !!!

;; specially, about ``next'',
;; the way we use to set :
;;   [ExplainerPointer] == address-of-explainer (of a word you want to jump to)
;; is to find the address-of-explainer by :
;;    NextWordPointer  == an address in a function-body
;;   [NextWordPointer] == word-to-jump[explainer]
;; so, NextWordPointer is all that ``next'' needed
;; set [NextWordPointer] == word-to-jump[explainer]  correctly
;; then call ``next''
;; it will works just well !!!


;; 1. this ``next'' do tail-call-optimization
;; 2. in the following FASM marco, anonymous label of FASM is used
;;    (of course, label in marco must be anonymous !)
;;    hence, when using anonymous labels in assembly,
;;    they can not across ``next'' !


macro next {
   ;== NEED:
   ;==     NextWordPointer  points at an address in a function-body
   ;==    [NextWordPointer] == word-to-jump[explainer]
   ;== CHNG:
   ;==     NextWordPointer  points at next address in a function-body
   ;==    [NextWordPointer] == new-word-to-jump[explainer]
   ;==     ExplainerPointer  points at the address in a word
   ;==                      where the address-of-explainer is stored
   ;==    [ExplainerPointer] == address-of-explainer (of word-to-jump)
   mov ExplainerPointer, [NextWordPointer]
   add NextWordPointer, CellWidth
   ;; why not: cmp qword[NextWordPointer], Exit  ???
   cmp dword[NextWordPointer], Exit
   ;-- IF: [NextWordPointer] =/= Exit
   jne @f
   ;-- EL: [NextWordPointer] == Exit
   popReturnStack NextWordPointer
@@:
   jmp qword[ExplainerPointer]
   }
   ;; maybe need more optimization,
   ;; for the above ``popReturnStack NextWordPointer'' may be
   ;; followed by ``pushReturnStack NextWordPointer'' (in explainFunctionBody)



;; initial Link to point to NULL
Link = 0


;; example of macro expanding :
;; defWord "double", double
;;    dq duplicate
;;    dq plus
;;    dq Exit
;; ==expand to==>
;; WordStringHeaderOfdouble:
;;         dq (EndOfdouble - WordStringOfdouble)
;; WordStringOfdouble:
;;         db "double"
;; EndOfWordStringOfdouble:
;; LinkOfdouble:
;;         dq Link
;;         Link = LinkOfdouble
;; TypeOfdouble:
;;         dq 0
;; AddressOfWordStringHeaderOfdouble:
;;         dq WordStringHeaderOfdouble
;; double:
;;         dq explainFunctionBody
;;         dq duplicate
;;         dq plus
;;         dq Exit


macro defWord WordString, Word {
segment readable writeable
;;--------------------------------------
WordStringHeaderOf#Word:
        dq (EndOfWordStringOf#Word - WordStringOf#Word)
;;--------------------------------------
WordStringOf#Word:
        db WordString
EndOfWordStringOf#Word:
;;--------------------------------------
SizeOfFunctionBodyOf#Word:
        dq (EndOfFunctionBodyOf#Word - Word)/8 - 1
;;--------------------------------------
IdentificationOf#Word:
        dq IdentificationOf#Word
;;--------------------------------------
LinkOf#Word:
        dq Link
        Link = LinkOf#Word
;;--------------------------------------
TypeOf#Word:
        dq 0
;;--------------------------------------
AddressOfWordStringHeaderOf#Word:
        dq WordStringHeaderOf#Word
;;======================================
Word:   dq explainFunctionBody
;;--------------------------------------
        ;; here follows a list of word[explainer]
        }
macro defWordEnd Word {
EndOfFunctionBodyOf#Word:
}
;; 注意 ><><><
;;      只有这些explainer才是能够直接被执行的代码
;;      直接用jmp转跳到explainFunctionBody就可以执行了
;;      而那些用defCode定义的汇编代码(比如 addition)不是直接转跳过去就能执行的
;;      因为addition这个地址下保存的是地址 而不是指令

;; 1. if ``next'' meet ``Exit'',
;;    ``next'' will ``popReturnStack NextWordPointer''
;; 2. on the other hand,
;;    explainFunctionBody is the only explainer
;;    who ``pushReturnStack NextWordPointer''
;; 3. so, it is these two functions, ``next'' and ``explainFunctionBody'',
;;    which handle the nested function calls
segment readable executable
explainFunctionBody:
   ;== SAVE:
   ;==     NextWordPointer  points at an old address in a function-body
   ;==    [NextWordPointer] == old-word-to-jump[explainer]
   ;== NEED:
   ;==    ExplainerPointer == current-word[explainer]
   ;==        this value can be used to calculate
   ;==        the address in a word where the function-body is stored
   ;== CHNG:
   ;==    [ExplainerPointer] == new-word-to-jump[explainer]
   ;==    [NextWordPointer] == new-word-to-jump[explainer]
   pushReturnStack NextWordPointer
   ;; to calculate the address in a word where the function-body is stored
   ;; this address is as an ``argmnt'' of explainFunctionBody
   add ExplainerPointer, CellWidth
   mov NextWordPointer, ExplainerPointer
   next



;; assembly code have no explainer
macro defCode WordString, Word {
segment readable writeable
;;--------------------------------------
WordStringHeaderOf#Word:
        dq (EndOfWordStringOf#Word - WordStringOf#Word)
;;--------------------------------------
WordStringOf#Word:
        db WordString
EndOfWordStringOf#Word:
;;--------------------------------------
IdentificationOf#Word:
        dq IdentificationOf#Word
;;--------------------------------------
LinkOf#Word:
        dq Link
        Link = LinkOf#Word
;;--------------------------------------
TypeOf#Word:
        dq 0
;;--------------------------------------
AddressOfWordStringHeaderOf#Word:
        dq WordStringHeaderOf#Word
;;======================================
Word:   dq AssemblerCodeOf#Word
;;--------------------------------------
segment readable executable
AssemblerCodeOf#Word:
        ;; here follows the assembly code
        }




defCode "execute", execute
  ;; ( word[address of explainer] -- )
  popArgumtStack ExplainerPointer
  jmp qword[ExplainerPointer]

;; not matter what way you use to set :
;;   [ExplainerPointer] == address-of-explainer (of a word you want to jump to)
;; then :
;;   jmp qword[ExplainerPointer]
;; it will works just well !!!



;; 对于在我理解上不是primitive-function的word统一使用explainer
;; 我并没有比较两者的效率 这样作单纯是为了追求理解上的一致性
macro defVar WordString, InitialValue, Word {
segment readable writeable
;;--------------------------------------
WordStringHeaderOf#Word:
        dq (EndOfWordStringOf#Word - WordStringOf#Word)
;;--------------------------------------
WordStringOf#Word:
        db WordString
EndOfWordStringOf#Word:
;;--------------------------------------
IdentificationOf#Word:
        dq IdentificationOf#Word
;;--------------------------------------
LinkOf#Word:
        dq Link
        Link = LinkOf#Word
;;--------------------------------------
TypeOf#Word:
        dq 0
;;--------------------------------------
AddressOfWordStringHeaderOf#Word:
        dq WordStringHeaderOf#Word
;;======================================
Word:   dq explainVar
;;--------------------------------------
        dq InitialValue
;;--------------------------------------
        }


segment readable executable
explainVar:
   ;; ( -- address )
   add ExplainerPointer, CellWidth
   pushArgumtStack ExplainerPointer
   next



macro defConst WordString, InitialValue, Word {
segment readable writeable
;;--------------------------------------
WordStringHeaderOf#Word:
        dq (EndOfWordStringOf#Word - WordStringOf#Word)
;;--------------------------------------
WordStringOf#Word:
        db WordString
EndOfWordStringOf#Word:
;;--------------------------------------
IdentificationOf#Word:
        dq IdentificationOf#Word
;;--------------------------------------
LinkOf#Word:
        dq Link
        Link = LinkOf#Word
;;--------------------------------------
TypeOf#Word:
        dq 0
;;--------------------------------------
AddressOfWordStringHeaderOf#Word:
        dq WordStringHeaderOf#Word
;;======================================
Word:   dq explainConst
;;--------------------------------------
        dq InitialValue
;;--------------------------------------
        }

segment readable executable
explainConst:
   ;; ( -- value )
   add ExplainerPointer, CellWidth
   mov TemporaryRegister, [ExplainerPointer]
   pushArgumtStack TemporaryRegister
   next




;; in stack:
;;   string[address, length]
;; in memory:
;;   ||  1 : length  ||
;;   ||  n : string  ||
macro defConstString WordString, ConstStringValue, Word {
segment readable writeable
;;--------------------------------------
WordStringHeaderOf#Word:
        dq (EndOfWordStringOf#Word - WordStringOf#Word)
;;--------------------------------------
WordStringOf#Word:
        db WordString
EndOfWordStringOf#Word:
;;--------------------------------------
IdentificationOf#Word:
        dq IdentificationOf#Word
;;--------------------------------------
LinkOf#Word:
        dq Link
        Link = LinkOf#Word
;;--------------------------------------
TypeOf#Word:
        dq 0
;;--------------------------------------
AddressOfWordStringHeaderOf#Word:
        dq WordStringHeaderOf#Word
;;======================================
Word:   dq explainConstString
;;--------------------------------------
        dq (EndOfConstStringValueOf#Word - ConstStringValueOf#Word)
;;--------------------------------------
ConstStringValueOf#Word:
        db ConstStringValue
EndOfConstStringValueOf#Word:
;;--------------------------------------
        }


segment readable executable
explainConstString:
   ;; ( -- string[address, length] )
   add ExplainerPointer, CellWidth
   mov TemporaryRegister, [ExplainerPointer]
   add ExplainerPointer, CellWidth
   pushArgumtStack ExplainerPointer
   pushArgumtStack TemporaryRegister
   next



;; 下面是尾递归优化版本的Exit
;; 在这个版本中 需要一个唯一的值来判断FunctionBody的结束点
;; 而下面定义Exit的方式就是使用Exit这个label所代表的地址值来作这个判断
;; 并且下面的定义方式同时做到了当executer来执行它的时候 它会把这个地址入栈
;; 但是其实如果你把Exit写到一个词的定义中 这个常量Word是永远不会被执行的
;; 因为变成名词了 所以首字母大写
defConst "Exit", Exit, Exit
;; (* so, the following numbers are the same :
;;   Exit
;;   readWord Exit find wordLinkToWordExplainer
;;   *)

defConst "FunctionBodyExplainer", explainFunctionBody, FunctionBodyExplainer
defConst "VarExplainer",          explainVar,          VarExplainer
defConst "ConstExplainer",        explainConst,        ConstExplainer
defConst "ConstStringExplainer",  explainConstString,  ConstStringExplainer
defVar "Base", 10, Base

defVar "Here",  0, Here

;; 在这里的汇编代码内想要初始化FirstWordInDictionary的值
;; 就必须在这篇代码的最后面加一个词
;; 以确保FirstWordInDictionary能保存
;; 最后一个被定义到Dictionary中的word
;; 每次最后一个被定义到Dictionary中的word 都被认为是Dictronary中的第一个word
defVar "FirstWordInDictionary", LinkOfTheLatestWordInThisFile , FirstWordInDictionary
;; 注意: 上面是LinkOfTheLatestWordInThisFile
;;       而不是TheLatestWordInThisFile
defConst "CellWidth", CellWidth, TheCellWidth

defConst "Zero",  0, Zero
defConst "One",   1, One
defConst "Two",   2, Two
defConst "Three", 3, Three
defConst "Four",  4, Four
defConst "Five",  5, Five
defConst "Six",   6, Six
defConst "Seven", 7, Seven
defConst "Eight", 8, Eight
defConst "Nine",  9, Nine
defConst "Ten",  10, Ten

defConst "False", 0, False
defConst "True",  1, True

;; 在十进制下把Base变为2之后
;; 想要变回来 就需要
;; 在二进制下把Base变为1010
;; test:
;; 2 Base save
;; 101 011 bitwiseAnd . (* 1 *)
;; 101 bitwiseInvert 011 bitwiseInvert bitwiseOr bitwiseInvert . (* 1 *)
;; 1010 Base save
;; 所以最好定义常数来保存常用的进位基底
;; 并且为了让这些定义完全与做定义的时候的进位基底无关
;; 就应该把这些常数定义在汇编中
defConst "BinBase", 2,  BinBase
defConst "OctBase", 8,  OctBase
defConst "DecBase", 10, DecBase
defConst "HexBase", 16, HexBase
defConst "AphBase", 36, AphBase
;; test:
;; BinBase Base save
;; 101 011 bitwiseAnd . (* 1 *)
;; 101 bitwiseInvert 011 bitwiseInvert bitwiseOr bitwiseInvert . (* 1 *)
;; DecBase Base save

;; 字典编撰者也是要看Base这个变量的
;; test:
;; BinBase Base save
;; 10 : kkk defineVar
;; DecBase Base save
;; kkk fetch . (* 2 *)
defCode "drop", drop
   ;; ( a -- )
   popArgumtStack rax
   next

defCode "twoDrop", twoDrop
   ;; ( a b -- )
   ;; drop是在抛弃栈中的元素
   popArgumtStack rax
   popArgumtStack rax
   next



defCode "duplicate", duplicate
   ;; ( a -- a a )
   mov  rax, [ArgumtStackPointer]
   pushArgumtStack rax
   next

defCode "twoDuplicate", twoDuplicate
   ;; ( a b -- a b a b )
   mov  rbx, [ArgumtStackPointer]
   mov  rax, [ArgumtStackPointer + CellWidth]
   pushArgumtStack rax
   pushArgumtStack rbx
   next

defCode "nonZeroDuplicate", nonZeroDuplicate
   ;; if a =/= 0
   ;; ( a -- a a )
   ;; else
   ;; ( a -- a )
   mov  rax, [ArgumtStackPointer]
   test rax, rax
   jz nonZeroDuplicate_meetZero
   pushArgumtStack rax
nonZeroDuplicate_meetZero:
   next



defCode "over", over
   ;; ( a b -- a b  a )
   mov  rax, [ArgumtStackPointer + CellWidth]
   pushArgumtStack rax
   next

defCode "x|over|xx", xoverxx
   ;; ( a  b c -- a  b c  a )
   mov  rax, [ArgumtStackPointer + (2 * CellWidth)]
   pushArgumtStack rax
   next

defCode "xx|over|x", xxoverx
   ;; ( a b  c -- a b  c  a b )
   mov  rax, [ArgumtStackPointer + (2 * CellWidth)]
   pushArgumtStack rax
   mov  rax, [ArgumtStackPointer + (2 * CellWidth)] ;; not (1 * CellWidth)
   pushArgumtStack rax
   next

defCode "xx|over|xx", xxoverxx
   ;; ( a b  c d -- a b  c d  a b )
   mov  rax, [ArgumtStackPointer + (3 * CellWidth)]
   pushArgumtStack rax
   mov  rax, [ArgumtStackPointer + (3 * CellWidth)] ;; not (3 * CellWidth)
   pushArgumtStack rax
   next

defCode "x|over|xxx", xoverxxx
   ;; ( a  b c d -- a  b c d  a )
   mov  rax, [ArgumtStackPointer + (3 * CellWidth)]
   pushArgumtStack rax
   next



defCode "tuck", tuck
   ;; ( a b -- b  a b )
   popArgumtStack  rbx
   popArgumtStack  rax
   pushArgumtStack rbx
   pushArgumtStack rax
   pushArgumtStack rbx
   next

defCode "x|tuck|xx", xtuckxx
   ;; ( a  b c -- b c  a  b c )
   popArgumtStack  rcx
   popArgumtStack  rbx
   popArgumtStack  rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   pushArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   next

defCode "xx|tuck|x", xxtuckx
   ;; ( a b  c -- c  a b  c )
   popArgumtStack  rcx
   popArgumtStack  rbx
   popArgumtStack  rax
   pushArgumtStack rcx
   pushArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   next

defCode "xx|tuck|xx", xxtuckxx
   ;; ( a b  c d -- c d  a b  c d )
   popArgumtStack  rdx
   popArgumtStack  rcx
   popArgumtStack  rbx
   popArgumtStack  rax
   pushArgumtStack rcx
   pushArgumtStack rdx
   pushArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   pushArgumtStack rdx
   next



defCode "swap", swap
   ;; ( a b -- b a )
   popArgumtStack  rbx
   popArgumtStack  rax
   pushArgumtStack rbx
   pushArgumtStack rax
   next

defCode "x|swap|xx", xswapxx
   ;; ( a  b c -- b c  a )
   popArgumtStack  rcx
   popArgumtStack  rbx
   popArgumtStack  rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   pushArgumtStack rax
   next

defCode "xx|swap|x", xxswapx
   ;; ( a b  c -- c  a b )
   popArgumtStack  rcx
   popArgumtStack  rbx
   popArgumtStack  rax
   pushArgumtStack rcx
   pushArgumtStack rax
   pushArgumtStack rbx
   next

defCode "x|swap|xxx", xswapxxx
   ;; ( a  b c d -- b c d  a )
   popArgumtStack  rdx
   popArgumtStack  rcx
   popArgumtStack  rbx
   popArgumtStack  rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   pushArgumtStack rdx
   pushArgumtStack rax
   next

defCode "xx|swap|xx", xxswapxx
   ;; ( a b  c d -- c d  a b )
   popArgumtStack  rdx
   popArgumtStack  rcx
   popArgumtStack  rbx
   popArgumtStack  rax
   pushArgumtStack rcx
   pushArgumtStack rdx
   pushArgumtStack rax
   pushArgumtStack rbx
   next

defCode "xx|swap|xxxx", xxswapxxxx
   ;; ( a b  c d e f -- c d e f  a b )
   popArgumtStack  r9 ;; f
   popArgumtStack  r8 ;; e
   popArgumtStack  rdx
   popArgumtStack  rcx
   popArgumtStack  rbx
   popArgumtStack  rax
   pushArgumtStack rcx
   pushArgumtStack rdx
   pushArgumtStack r8 ;; e
   pushArgumtStack r9 ;; f
   pushArgumtStack rax
   pushArgumtStack rbx
   next

defCode "xxxx|swap|xx", xxxxswapxx
   ;; ( a b c d  e f --  e f  a b c d )
   popArgumtStack  r9 ;; f
   popArgumtStack  r8 ;; e
   popArgumtStack  rdx
   popArgumtStack  rcx
   popArgumtStack  rbx
   popArgumtStack  rax
   pushArgumtStack r8 ;; e
   pushArgumtStack r9 ;; f
   pushArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   pushArgumtStack rdx
   next


defCode "|123->321|", abcTOcba
   popArgumtStack rax
   popArgumtStack rbx
   popArgumtStack rcx
   pushArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   next
defCode "add1", add1
   ;; ( n -- n+1 )
   inc qword[ArgumtStackPointer]
   next

defCode "add2", add2
   ;; ( n -- n+1 )
   add qword[ArgumtStackPointer], 2
   next

defCode "add3", add3
   ;; ( n -- n+1 )
   add qword[ArgumtStackPointer], 3
   next

defCode "add4", add4
   ;; ( n -- n+4 )
   add qword[ArgumtStackPointer], 4
   next

defCode "add8", add8
   ;; ( n -- n+8 )
   add qword[ArgumtStackPointer], 8
   next


defCode "sub1", sub1
   ;; ( n -- n-1 )
   dec qword[ArgumtStackPointer]
   next

defCode "sub2", sub2
   ;; ( n -- n-1 )
   sub qword[ArgumtStackPointer], 2
   next

defCode "sub3", sub3
   ;; ( n -- n-1 )
   sub qword[ArgumtStackPointer], 3
   next

defCode "sub4", sub4
   ;; ( n -- n-4 )
   sub qword[ArgumtStackPointer], 4
   next

defCode "sub8", sub8
   ;; ( n -- n-8 )
   sub qword[ArgumtStackPointer], 8
   next


defCode "twoAdd1", twoAdd1
   ;; ( m, n -- m+1, n+1 )
   inc qword[ArgumtStackPointer]
   inc qword[ArgumtStackPointer + CellWidth]
   next


defCode "+", addition
   ;; ( a b -- a+b )
   popArgumtStack rax
   add qword[ArgumtStackPointer], rax
   next

defCode "-", subtraction
   ;; ( a b -- a-b )
   popArgumtStack rax
   sub qword[ArgumtStackPointer], rax
   next

defCode "*", multiple
   ;; ( a b -- a*b )
   popArgumtStack  rbx ;; 2ed arg
   popArgumtStack  rax ;; 1st arg
   imul rbx, rax
   ;; imul will ignore overflow
   ;; 当有两个参数时 imul将会把乘法的结果保存在第一个参数寄存器中
   pushArgumtStack rbx
   next

defCode "mod/", divmod
   ;; ( a, b -- a mod b, a/b )
   ;; ( dividend, divisor -- remainder, quotient )
   ;; the arg of idiv is divisor(除数)
   ;; the lower half of dividend(被除数) is taken from rax
   ;; the upper half of dividend(被除数) is taken from rdx
   ;; 下面清空rdx 也就是说这里并不使用被除数的高位部分
   xor  rdx, rdx
   popArgumtStack  rbx ;; 2ed arg
   popArgumtStack  rax ;; 1st arg
   idiv rbx
   ;; the remainder is stored in rdx
   ;; the quotient  is stored in rax
   pushArgumtStack rdx ;; remainder
   pushArgumtStack rax ;; quotient
   next
;; ``save'' and ``fetch'' default to a CellWidth (== 8 bytes)
;; the rule of ``fetchTwo'' and so on are:
;;   in memory:
;;     ||  1 : value-1  ||
;;     ||  1 : value-2  ||
;;     ||  1 : value-3  ||
;;     ...
;;   on stack:
;;     [ ... , value-3, value-2, value-1]
;; of course we have:
;;   fetchTwo : memory=copy=>stack
;;   saveTwo  : stack->memory

defCode "save", save
   ;; ( value, address -- )
   popArgumtStack rbx
   popArgumtStack rax
   mov qword[rbx], rax
   next

defCode "saveTwo", saveTwo
   ;; ( value-2, value-1, address -- )
   popArgumtStack rbx
   popArgumtStack rax
   mov qword[rbx], rax
   popArgumtStack rax
   mov qword[rbx + CellWidth], rax
   next


defCode "fetch", fetch
   ;; ( address -- value )
   popArgumtStack  rbx
   mov rax, qword[rbx]
   pushArgumtStack rax
   next

defCode "twoFetch", twoFetch
   ;; ( address-1, address-2 -- value-1, value-2 )
   popArgumtStack  rbx
   popArgumtStack  rax
   mov TemporaryRegister2, qword[rbx]
   mov TemporaryRegister, qword[rax]
   pushArgumtStack TemporaryRegister
   pushArgumtStack TemporaryRegister2
   next

defCode "fetchTwo", fetchTwo
   ;; ( address -- value-1, value-2 )
   popArgumtStack  rbx
   mov rax, qword[rbx + CellWidth]
   pushArgumtStack rax
   mov rax, qword[rbx]
   pushArgumtStack rax
   next


defCode "addSave", addSave
   ;; ( number to add, address -- )
   popArgumtStack rbx
   popArgumtStack rax
   add qword[rbx], rax
   next

defCode "subSave", subSave
   ;; ( number to add, address -- )
   popArgumtStack rbx
   popArgumtStack rax
   sub qword[rbx], rax
   next



defCode "saveByte", saveByte
   ;; ( value, address -- )
   popArgumtStack rbx
   popArgumtStack rax
   mov byte[rbx], al
   next

defCode "fetchByte", fetchByte
   ;; ( address -- value )
   popArgumtStack rbx
   xor rax, rax
   mov al, byte[rbx]
   pushArgumtStack rax
   next

defCode "twoFetchByte", twoFetchByte
   ;; ( address-1, address-2 -- value-1, value-2 )
   popArgumtStack TemporaryRegister2
   popArgumtStack TemporaryRegister
   xor rbx, rbx
   mov bl, byte[TemporaryRegister2]
   xor rax, rax
   mov al, byte[TemporaryRegister]
   pushArgumtStack rax
   pushArgumtStack rbx
   next


defCode "copyByte", copyByte
   ;; ( source address, destination address --
   ;;   source address + 1, destination address + 1 )
   mov rbx, [ArgumtStackPointer + CellWidth] ;; source address
   mov al,  byte[rbx]                        ;; get a char from source address
   popArgumtStack rdi                        ;; destination address
   stosb                                     ;; copy to destination
   pushArgumtStack rdi                       ;; destination address is incremented by stosb
   inc qword[ArgumtStackPointer + CellWidth] ;; increment source address
   next

defCode "copyByteString", copyByteString
   ;; ( source address, destination address, length -- )
   popArgumtStack rcx 
   popArgumtStack rdi 
   popArgumtStack rsi 
   rep movsb          
   next
;; defWord "compareString?", compareString?
;;    ;; ( address of string-1, address of string-2, length -- True or False )
;;    dq duplicate, zero?branch, 17;-- GOTO: drop, drop, drop, True, Exit

;;    dq xxswapx
;;    dq twoDuplicate, twoFetchByte
;;    dq equal?, false?branch, 6;-- GOTO: drop, drop, drop, False
;;    dq twoAdd1, xswapxx, sub1, branch, -13;-- GOTO: the beginning
;;    dq drop, drop, drop, False
;;    dq Exit

;;    dq drop, drop, drop, True, Exit

;; 上面的forth版本 在length为0的时候会返回True
;; 下面的汇编版本 在length为0的时候会返回False
;; >< 那一种行为才是正确的呢 ???

;; compareString?和equalString?之间的区别可能让人疑惑
defCode "compareString?", compareString?
   ;; ( address of string-1, address of string-2, length -- True or False )
   popArgumtStack rcx
   popArgumtStack rdi
   popArgumtStack rsi
   repe cmpsb
   sete al
   movzx rax, al
   pushArgumtStack rax
   next

defWord "equalString?", equalString?
   ;; ( string-1[address-1, length-1], string-2[address-2, length-2]
   ;;   -- True or False )
   dq xoverxx, equal?, false?branch, 4
   dq swap, compareString?, Exit
   dq drop, drop, drop, False
   dq Exit
defWordEnd equalString?
defCode "==", equal?
   popArgumtStack rbx
   popArgumtStack rax
   cmp   rbx, rax
   sete  al
   movzx rax, al
   pushArgumtStack rax
   next

defCode "=/=", notEqual?
   popArgumtStack rbx
   popArgumtStack rax
   cmp   rbx, rax
   setne al
   movzx rax, al
   pushArgumtStack rax
   next

defCode "<", lessThan?
   popArgumtStack rbx
   popArgumtStack rax
   cmp   rax, rbx
   setl  al
   movzx rax, al
   pushArgumtStack rax
   next

defCode ">", greaterThan?
   popArgumtStack   rbx
   popArgumtStack   rax
   cmp   rax, rbx
   setg  al
   movzx rax, al
   pushArgumtStack  rax
   next

defCode "<=", lessOrEqual?
   popArgumtStack rbx
   popArgumtStack rax
   cmp   rax, rbx
   setle al
   movzx rax, al
   pushArgumtStack rax
   next

defCode ">=", greaterOrEqual?
   popArgumtStack rbx
   popArgumtStack rax
   cmp   rax, rbx
   setge al
   movzx rax, al
   pushArgumtStack rax
   next

defCode "zero?", zero?
   popArgumtStack rax
   test  rax,rax
   setz  al
   movzx rax, al
   pushArgumtStack rax
   next

defCode "notZero?", notZero?
   popArgumtStack rax
   test  rax,rax
   setnz al
   movzx rax, al
   pushArgumtStack rax
   next


defWord "one?", one?
   dq One, equal?
   dq Exit
defWordEnd one?

defWord "true?", true?
   dq one?
   dq Exit
defWordEnd true?

defWord "false?", false?
   dq zero?
   dq Exit
defWordEnd false?
defCode "bitwiseAnd", bitwiseAnd
   ;; ( a, b -- a and b )
   popArgumtStack rbx
   and [ArgumtStackPointer], rbx
   next

defCode "bitwiseOr", bitwiseOr
   ;; ( a, b -- a or b )
   popArgumtStack rbx
   or  [ArgumtStackPointer], rbx
   next

defCode "bitwiseXor", bitwiseXor
   ;; ( a, b -- a xor b )
   popArgumtStack rbx
   xor [ArgumtStackPointer], rbx
   next

defCode "bitwiseInvert", bitwiseInvert
   ;; ( a -- invert a )
   not qword[ArgumtStackPointer]
   next

;; test:
;; 注意:
;;   在十进制下把Base变为2之后
;;   想要变回来 就需要
;;   在二进制下把Base变为1010
;;   所以最好定义常数来保存常用的进位基底
;; 2 Base save
;; 101 011 bitwiseAnd . ( 1 )
;; 101 bitwiseInvert 011 bitwiseInvert bitwiseOr bitwiseInvert . ( 1 )
;; 1010 Base save
;; BT copies a bit from a given register to the carry flag
defCode "fetchBit", fetchBit
   ;; ( fixnum, offset -- bit )
   popArgumtStack rbx
   popArgumtStack rax
   bt rax, rbx
   setc al
   movzx rax, al
   pushArgumtStack rax
   next

defCode "setBit", setBit
   ;; ( fixnum, offset -- fixnum )
   popArgumtStack rbx
   popArgumtStack rax
   bts rax, rbx
   pushArgumtStack rax
   next

defCode "clearBit", clearBit
   ;; ( fixnum, offset -- fixnum )
   popArgumtStack rbx
   popArgumtStack rax
   btr rax, rbx
   pushArgumtStack rax
   next

defCode "invertBit", invertBit
   ;; ( fixnum, offset -- fixnum )
   popArgumtStack rbx
   popArgumtStack rax
   btc rax, rbx
   pushArgumtStack rax
   next



;; "bsf" "bsr"
;; instructions scan a word or double word for first set bit
;; and store the index of this bit into destination operand
;; which must be general register
;; The bit string being scanned is specified by source operand
;; it may be either general register or memory
;; The ZF flag is set if the entire string is zero (no set bits are found)
;; otherwise it is cleared

;; If no set bit is found
;; the value of the destination register is undefined
;; "bsf" scans from low order to high order (starting from bit index zero)
;; "bsr" scans from high order to low order

;; 下面的函数 如果没找到 SetBit 就返回-1

defCode "findLowestSetBit", findLowestSetBit
   ;; ( fixnum -- offset )
   popArgumtStack rax
   bsf rax, rax
   jz tryToFindLowestSetBit_But_NoSetBitIsFound
   pushArgumtStack rax
   next
tryToFindLowestSetBit_But_NoSetBitIsFound:
   mov rax, -1
   pushArgumtStack rax
   next

defCode "findHighestSetBit", findHighestSetBit
   ;; ( fixnum -- offset )
   popArgumtStack rax
   bsr rax, rax
   jz tryToFindHighestSetBit_But_NoSetBitIsFound
   pushArgumtStack rax
   next
tryToFindHighestSetBit_But_NoSetBitIsFound:
   mov rax, -1
   pushArgumtStack rax
   next
;; "shl"
;; shifts the destination operand left
;; by the number of bits specified in the second operand
;; The destination operand can be general register or memory
;; The second operand can be an immediate value or the CL register
;; as bits exit from the left, zeros in from the right
;; The last bit that exited is stored in CF
;; "sal" is a synonym for "shl"
defCode "shiftLeft", shiftLeft
   ;; ( fixnum, step -- fixnum * 2^step )
   popArgumtStack rcx
   shl qword[ArgumtStackPointer], cl
   next

defCode "shiftRight", shiftRight
   ;; ( fixnum, step -- fixnum / 2^step )
   popArgumtStack rcx
   shr qword[ArgumtStackPointer], cl
   next

defCode "shiftRightPreserveSign", shiftRightPreserveSign
   ;; ( fixnum, step -- new fixnum )
   popArgumtStack rcx
   sar qword[ArgumtStackPointer], cl
   next



;; 注意 double了之后就是128 bit的二进制数了

;; "shld"
;; shifts bits of the destination operand to the left
;; by the number of bits specified in third operand,
;; while shifting
;; move high order bits from the source operand
;; into the destination operand on the right.
;; The source operand remains unmodified.
;; The destination operand can be a word or double word general register or memory,
;; the source operand must be a general register,
;; third operand can be an immediate value or the CL register.
defCode "doubleShiftLeft", doubleShiftLeft
   ;; ( fixnum-1, fixnum-2, step --
   ;;   new fixnum-1, new fixnum-2 )
   popArgumtStack rcx
   popArgumtStack rax
   shld qword[ArgumtStackPointer], rax, cl
   shl rax, cl
   pushArgumtStack rax
   next


;; "shrd"
;; shifts bits of the destination operand to the right,
;; while shifting
;; move low order bits from the source operand
;; into the destination operand on the left.
;; The source operand remains unmodified.
;; Rules for operands are the same as for the "shld" instruction.
defCode "doubleShiftRight", doubleShiftRight
   ;; ( fixnum-1, fixnum-2, step --
   ;;   new fixnum-1, new fixnum-2 )
   popArgumtStack rcx
   popArgumtStack rbx
   popArgumtStack rax
   shrd rbx, rax, cl
   shr rax, cl
   pushArgumtStack rax
   pushArgumtStack rbx
   next

defCode "doubleShiftRightPreserveSign", doubleShiftRightPreserveSign
   ;; ( fixnum-1, fixnum-2, step --
   ;;   new fixnum-1, new fixnum-2 )
   popArgumtStack rcx
   popArgumtStack rbx
   popArgumtStack rax
   shrd rbx, rax, cl
   sar rax, cl
   pushArgumtStack rax
   pushArgumtStack rbx
   next




defCode "rotateLeft", rotateLeft
   ;; ( fixnum, step -- new fixnum )
   popArgumtStack rcx
   rol qword[ArgumtStackPointer], cl
   next

defCode "rotateRight", rotateRight
   ;; ( fixnum, step -- new fixnum )
   popArgumtStack rcx
   ror qword[ArgumtStackPointer], cl
   next
;; defCode ">r", toReturnStackPointer
;;    ;; ( address -- )
;;    popArgumtStack  rax
;;    pushReturnStack rax
;;    next

;; defCode "r>", fromReturnStackPointer
;;    ;; ( -- address )
;;    popReturnStack  rax
;;    pushArgumtStack rax
;;    next

;; ><><>< what is the use of the above two words ???


defCode "fetchReturnStackPointer", fetchReturnStackPointer
   ;; ( -- an address in the ReturnStack )
   pushArgumtStack ReturnStackPointer
   next

defCode "resetReturnStackPointer", resetReturnStackPointer
   ;; ( an address in the ReturnStack -- )
   popArgumtStack ReturnStackPointer
   next

defCode "dropReturnStack", dropReturnStack
   ;; ( -- )
   add ReturnStackPointer, CellWidth
   next
;; to know why the following funny thing happens,
;; see the definition of the macro ``pushArgumtStack'',
defCode "makeSelfReferenceValue", makeSelfReferenceValue
   ;; ( -- address )
   pushArgumtStack ArgumtStackPointer
   next

defWord "fetchArgumtStackPointer", fetchArgumtStackPointer
   dq makeSelfReferenceValue, add8, Exit
defWordEnd fetchArgumtStackPointer

defCode "resetArgumtStackPointer", resetArgumtStackPointer
   ;; ( address -- )
   popArgumtStack ArgumtStackPointer
   next
defCode "fetchGreyPairStackPointer", fetchGreyPairStackPointer
   ;; ( -- address )
   pushArgumtStack GreyPairStackPointer
   next

defCode "resetGreyPairStackPointer", resetGreyPairStackPointer
   ;; ( address -- )
   popArgumtStack GreyPairStackPointer
   next


defCode "pushGreyPairStack", pushGreyPairStack
   ;; ( pair[address] -- )
   ;; ( top of ArgumtStack --> top of GreyPairStack )
   popArgumtStack rax
   lea GreyPairStackPointer, [GreyPairStackPointer - CellWidth]
   mov [GreyPairStackPointer], rax
   next

defCode "popGreyPairStack", popGreyPairStack
   ;; ( -- pair[address] )
   ;; ( top of GreyPairStack --> top of ArgumtStack )
   mov rax, [GreyPairStackPointer]
   lea GreyPairStackPointer, [GreyPairStackPointer + CellWidth]
   pushArgumtStack rax
   next

defCode "emptyGreyPairStack?", emptyGreyPairStack?
   ;; ( -- True or False )
   mov rax, GreyPairStackTop
   cmp GreyPairStackPointer, rax
   ;; 注意栈的实现方式
   ;; GreyPairStackPointer >= GreyPairStackTop 代表栈的溢出
   setge al
   movzx rax, al
   pushArgumtStack rax
   next

;; test:
;; emptyGreyPairStack? . ( 1 )
;; 6 pushGreyPairStack emptyGreyPairStack? . ( 0 )
;; popGreyPairStack . ( 6 )
;; emptyGreyPairStack? . ( 1 )
defCode "tailOfWordList", tailOfWordList
   ;; ( wordList[address, the number of words] -- wordList[new address, number - 1] )
   popArgumtStack rcx
   popArgumtStack rsi
   lodsq
   add rsi, rax
   pushArgumtStack rsi
   dec rcx
   pushArgumtStack rcx
   next

defCode "headOfWordList", headOfWordList
   ;; ( wordList[address, the number of words] -- wordString[address, length] )
   popArgumtStack rbx ;; do not need this arg
   popArgumtStack rsi
   mov rcx, qword[rsi]
   add rsi, CellWidth
   pushArgumtStack rsi
   pushArgumtStack rcx
   next

defWord "tailAndHeadOfWordList", tailAndHeadOfWordList
   ;; ( wordList[address, the number of words] --
   ;;   wordList[new address, number - 1], wordString[address, length] )
   dq twoDuplicate
   dq tailOfWordList
   dq xxswapxx
   dq headOfWordList
   dq Exit
defWordEnd tailAndHeadOfWordList
defCode "syscallWithZoreArgument", syscallWithZoreArgument
   ;; (* callNumber -- return value *)
   popArgumtStack sys_n_rax
   syscall
   pushArgumtStack rax
   next

defCode "syscallWithOneArgument", syscallWithOneArgument
   ;; (* callNumber, arg-1 -- return value *)
   popArgumtStack sys_1_rdi
   popArgumtStack sys_n_rax
   syscall
   pushArgumtStack rax
   next

defCode "syscallWithTwoArguments", syscallWithTwoArguments
   ;; (* callNumber, arg-1, arg-2 -- return value *)
   popArgumtStack sys_2_rsi
   popArgumtStack sys_1_rdi
   popArgumtStack sys_n_rax
   syscall
   pushArgumtStack rax
   next

defCode "syscallWithThreeArguments", syscallWithThreeArguments
   ;; (* callNumber, arg-1, arg-2, arg-3 -- return value *)
   popArgumtStack sys_3_rdx
   popArgumtStack sys_2_rsi
   popArgumtStack sys_1_rdi
   popArgumtStack sys_n_rax
   syscall
   pushArgumtStack rax
   next
defCode "literal", literal
   mov  rax, [NextWordPointer]
   add  NextWordPointer, CellWidth
   pushArgumtStack rax

   ;; why not: cmp qword[NextWordPointer], Exit  ???
   cmp dword[NextWordPointer], Exit
   ;-- IF: [NextWordPointer] =/= Exit
   jne @f
   ;-- EL: [NextWordPointer] == Exit
   popReturnStack NextWordPointer
@@:

   next


defCode "branch", branch
   ;; usage(in assembly): dq branch, number
   ;; the number denotes an offset
   ;; the base point of the offset is the place where the number stored
   ;; note that: in the function branch, [NextWordPointer] = offset
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister

   ;; why not: cmp qword[NextWordPointer], Exit  ???
   cmp dword[NextWordPointer], Exit
   ;-- IF: [NextWordPointer] =/= Exit
   jne @f
   ;-- EL: [NextWordPointer] == Exit
   popReturnStack NextWordPointer
@@:

   next


defCode "zero?branch", zero?branch
   ;; ( n -- )
   popArgumtStack rax
   test rax, rax
   jnz zero?branch_toBranch
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp zero?branch_help_toBranch
zero?branch_toBranch:
   add NextWordPointer, CellWidth
zero?branch_help_toBranch:

   ;; why not: cmp qword[NextWordPointer], Exit  ???
   cmp dword[NextWordPointer], Exit
   ;-- IF: [NextWordPointer] =/= Exit
   jne @f
   ;-- EL: [NextWordPointer] == Exit
   popReturnStack NextWordPointer
@@:

   next

defCode "false?branch", false?branch
   ;; ( n -- )
   ;; false?branch is identical to zero?branch
   ;; but we can not use defWord to define false?branch by false?branch
   ;; for it is a special key word
   popArgumtStack rax
   test rax, rax
   jnz false?branch_toBranch
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp false?branch_help_toBranch
false?branch_toBranch:
   add NextWordPointer, CellWidth
false?branch_help_toBranch:

   ;; why not: cmp qword[NextWordPointer], Exit  ???
   cmp dword[NextWordPointer], Exit
   ;-- IF: [NextWordPointer] =/= Exit
   jne @f
   ;-- EL: [NextWordPointer] == Exit
   popReturnStack NextWordPointer
@@:

   next

defCode "notFalse?branch", notFalse?branch
   ;; ( n -- )
   popArgumtStack rax
   test rax, rax
   jz notFalse?branch_toBranch
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp notFalse?branch_help_toBranch
notFalse?branch_toBranch:
   add NextWordPointer, CellWidth
notFalse?branch_help_toBranch:

   ;; why not: cmp qword[NextWordPointer], Exit  ???
   cmp dword[NextWordPointer], Exit
   ;-- IF: [NextWordPointer] =/= Exit
   jne @f
   ;-- EL: [NextWordPointer] == Exit
   popReturnStack NextWordPointer
@@:

   next
segment readable executable
EntryPoint:
        cld ;; set DF = 0, then rsi and rdi are incremented
        mov ReturnStackPointer,   ReturnStackTop
        mov ArgumtStackPointer,   ArgumtStackTop
        mov GreyPairStackPointer, GreyPairStackTop
        ;; initialise the variable Here to point at beginning of DataSegment
        mov TemporaryRegister, UserDataSegment
        mov [Here + CellWidth], TemporaryRegister
        mov NextWordPointer, LittleTest
        next

segment readable writeable
LittleTest:
        dq basicREPL
;;        dq assemblyDebug
segment readable writeable
ScratchUsedByWriteChar:
   rb 1

defCode "writeChar", writeChar
   ;; ( char --  ) write a char to stdin
   ;; just calls the Linux write system call
   popArgumtStack rax
   call writeChar_helperFunction
   next
writeChar_helperFunction:
   mov sys_1_rdi, 1 ;; stdout
   ;; write can not just write the char in al to stdout
   ;; write needs the address of the byte to write
   mov [ScratchUsedByWriteChar], al
   mov sys_2_rsi, ScratchUsedByWriteChar  ;; address
   mov sys_3_rdx, 1                       ;; max length to be write, just 1
   mov sys_n_rax, syscall_write
   syscall
   ret


;; Buffer for Linux syscall read
InputBufferSize = 10 * 1024 * 1024 ; bytes
segment readable writeable
InputBuffer:
   rb InputBufferSize

;; two local variables for readChar
segment readable writeable
readChar_CurrentChar:
   dq InputBuffer
readChar_TopOfBuffer:
   dq InputBuffer

defCode "readChar", readChar
   ;; read a char from stdin, return it into the ArgumtStack as following
   ;; (  -- char )
   ;; readChar calls the Linux read system call to fill InputBuffer
   ;; The other thing that readChar does is
   ;; if it detects that stdin has closed, it exits the program
   ;; which is why when you hit C-d, the FORTH system cleanly exits
   call readChar_helperFunction
   ;; .helperFunction will save the return value in rax
   pushArgumtStack rax
   next
readChar_helperFunction:
   ;; [readChar_CurrentChar] is a variable which contains a address in InputBuffer
   ;; TemporaryRegister is a helper-register for [readChar_CurrentChar]
   mov TemporaryRegister, [readChar_CurrentChar]
   cmp TemporaryRegister, [readChar_TopOfBuffer]
   ;-- IF: [readChar_CurrentChar] >= [readChar_TopOfBuffer]
   ;-- WK: all chars in InputBuffer has been processed
   ;-- DO: syscall read to fetch more input from stdin
   jge readChar_fetchMoreCharsFromStdinToInputBuffer
   ;-- EL: [readChar_CurrentChar] < [readChar_TopOfBuffer]
   ;-- WK: there is still some chars in the InputBuffer to be processed
   ;; for the following will just uses the al part of rax
   ;; it is necessary to clear rax
   xor rax, rax
   ;-- DO: fetch a char from InputBuffer to rax
   ;-- NT: after .helperFunction return rax will be pushArgumtStack
   mov al, byte[TemporaryRegister]
   ;-- DO: increment [readChar_CurrentChar]
   inc TemporaryRegister
   mov [readChar_CurrentChar], TemporaryRegister
   ret

readChar_fetchMoreCharsFromStdinToInputBuffer:
   ;; reset [readChar_CurrentChar] and [readChar_TopOfBuffer]
   ;; and syscall read to fetch more input chars from stdin to InputBuffer
   xor sys_1_rdi,     sys_1_rdi        ;; stdin
   mov sys_2_rsi,     InputBuffer      ;; buffer address
   mov [readChar_CurrentChar], sys_2_rsi        ;; reset [readChar_CurrentChar]
   mov sys_3_rdx,     InputBufferSize  ;; max length to be read
   mov sys_n_rax,     syscall_read
   syscall

   ;; the return value of syscall read
   ;; is a count of the number of bytes transferred
   test rax, rax
   ;-- IF: rax <= 0
   ;-- WK: there is an error or it is end of input
   ;-- DO: exit
   jz readChar_exit
   js readChar_exit
   ;-- EL: rax > 0
   ;-- WK: there are some chars has been fetched by syscall read
   ;-- DO: set [readChar_TopOfBuffer] to the right place
   ;--     readChar_TopOfBuffer = InputBuffer + the count of the number of bytes transferred
   ;-- NT: sys_2_rsi = InputBuffer
   ;--     rax = the count of the number of bytes transferred
   add sys_2_rsi, rax
   mov [readChar_TopOfBuffer], sys_2_rsi
   ;-- DO: jump back
   jmp readChar_helperFunction

readChar_exit:
   ;; exit with exit code = 0
   xor sys_1_rdi, sys_1_rdi
   mov sys_n_rax, syscall_exit
   syscall
defWord "readFirstNonBlankChar", readFirstNonBlankChar
   ;; (* -- FirstNonBlankChar *)
   dq readChar, duplicate
   dq literal, 32 ;; ascii.space
   dq greaterThan?, false?branch, 2
   dq   Exit
   dq drop
   dq branch, -10
defWordEnd readFirstNonBlankChar

defWord "readNonBlankChar", readNonBlankChar
   ;; (* -- FirstNonBlankChar or Zero *)
   dq readChar, duplicate
   dq literal, 32 ;; ascii.space
   dq greaterThan?, false?branch, 2
   dq   Exit
   dq drop
   dq Zero
   dq Exit
defWordEnd readNonBlankChar
define MaxWordLength 1024


segment readable writeable
BufferForReadWord:
   ;; note that, Subsequent calls will overwrite BufferForReadWord
   ;; this is why there is another function ``readWordForRuntime''
   rb MaxWordLength

defWord "readWord", readWord
   ;; (*  -- wordString[address, length] *)
   ;; 1. skips any blanks (spaces, tabs, newlines)
   ;; 2. calls readChar to read characters into BufferForReadWord
   ;;    until it hits a blank
   ;; 3. returns the address of BufferForReadWord and length on the stack

   dq literal, BufferForReadWord ;; (* leave return one of the values *)
   dq Zero                       ;; (* leave length counter *)

   dq literal, BufferForReadWord
   dq readFirstNonBlankChar
   dq over, saveByte, add1
   dq swap, add1, swap

   dq readNonBlankChar, duplicate, zero?branch, 9
   dq   over, saveByte, add1
   dq   swap, add1, swap
   dq   branch, -11

   dq twoDrop
   dq Exit
defWordEnd readWord


segment readable writeable
BufferForReadWordForRuntime:
   rb MaxWordLength

defWord "readWordForRuntime", readWordForRuntime
   ;; (*  -- wordString[address, length] *)
   ;; 1. skips any blanks (spaces, tabs, newlines)
   ;; 2. calls readChar to read characters into BufferForReadWord
   ;;    until it hits a blank
   ;; 3. returns the address of BufferForReadWord and length on the stack

   dq literal, BufferForReadWordForRuntime ;; (* leave return one of the values *)
   dq Zero                                 ;; (* leave length counter *)

   dq literal, BufferForReadWordForRuntime
   dq readFirstNonBlankChar
   dq over, saveByte, add1
   dq swap, add1, swap

   dq readNonBlankChar, duplicate, zero?branch, 9
   dq   over, saveByte, add1
   dq   swap, add1, swap
   dq   branch, -11

   dq twoDrop
   dq Exit
defWordEnd readWordForRuntime
define MaxStringLength 1024*1024

segment readable writeable
BufferForReadStringInToBuffer:
   ;; note that, Subsequent calls will overwrite BufferForReadStringInToBuffer
   rb MaxStringLength

defWord "readStringInToBuffer", readStringInToBuffer
   ;; (*  -- string[address of BufferForReadStringInToBuffer, length] *)
   dq literal, BufferForReadStringInToBuffer ;; (* leave return one of the values *)
   dq Zero                         ;; (* leave length counter *)

   dq literal, BufferForReadStringInToBuffer

   dq readChar, duplicate
   dq literal, 34 ;; ascii.doublequote
   dq equal?, notFalse?branch, 9
   dq   over, saveByte, add1
   dq   swap, add1, swap
   dq   branch, -14

   dq twoDrop
   dq Exit
defWordEnd readStringInToBuffer
;; The function uses the variable BASE as the radix
;; If the word starts with a '-' character then the returned value is negative

;; If the string can't be parsed as a number
;; or contains characters outside the current BASE
;; then we need to return an error indication.
;; So we let NUMBER returns two items on the stack.

defCode "number", number
   ;; ( wordString[address, length] --
   ;;   parsed number, length of unparsed string )
   popArgumtStack  rcx        ;; length  of string
   popArgumtStack  rdi        ;; address of string
   call number_helperFunction
   pushArgumtStack rax        ;; parsed number
   pushArgumtStack rcx        ;; length of unparsed string (0 = no error)
   next

number_helperFunction:
   xor  rax, rax
   xor  rbx, rbx

   test rcx, rcx
   ;-- IF: rcx == 0
   ;-- WK: trying to parse a zero-length string, it is an error
   ;-- DO: but will return 0
   jz number_return
   ;-- EL: rcx =/= 0
   ;-- WK: we have a non-empty string to be parsed
   ;-- DO: parse this non-empty string
   ;; copy the the variable Base into dl (rdx)
   ;; the following shows how to use a forth-variable-word in assembler code
   mov rdx, [Base + CellWidth]
   ;; fetch a char
   mov bl,  byte[rdi]
   inc rdi
   ;; sign-indicater
   ;; top of ArgumtStack == 0,  indicating positive
   ;; top of ArgumtStack =/= 0, indicating negative
   ;; initialise sign-indicater
   pushArgumtStack rax     ;; top of ArgumtStack == 0, indicating positive
   cmp bl, '-'
   ;-- IF: bl =/= '-'
   ;-- WK: maybe positive number, maybe error
   ;-- DO: try to convert the number
   jnz number_convert
   ;-- EL: bl == '-'
   ;-- DO: reset sign-indicater
   ;--     update the counter
   ;--     go into a loop to read all the chars
   popArgumtStack  rax
   pushArgumtStack rbx     ;; top of ArgumtStack =/= 0, indicating negative
   dec rcx                 ;; update the counter
   jnz number_fetchNextDigits
   popArgumtStack  rbx     ;; error: string is only '-'.
   mov rcx, 1
   ret

number_update_the_counter_and_fetchNextDigits:
   dec rcx
number_fetchNextDigits:
   mov bl,  byte[rdi]     ;; bl = next character in string
   inc rdi

number_convert:
   cmp bl, '_'
   je number_update_the_counter_and_fetchNextDigits

   ;; from low to high along the ascii
   sub bl, '0'
   ;-- IF: char < '0'
   jb number_endThisParse
   cmp bl, 10
   ;-- IF: '0' <= char <= '9'
   jb number_tryToAddDigitUp

   ;-- EL: '9' < char
   sub bl, ('A' - '0')
   ;-- IF: '9'< char < 'A'
   jb number_endThisParse
   cmp bl, 26
   ;-- NOTE-THAT: if bl == 0, char == 'A'
   ;-- IF: 'Z' < char
   jge @f
   ;-- EL: 'A' <= char <= 'Z'
   add bl, 10 ;; for 'A' =Hex= 10
   jb number_tryToAddDigitUp

@@:;-- IF: 'Z' < char
   sub bl, ('a' - 'A')
   ;-- IF: 'Z' < char < 'a'
   jb number_endThisParse
   cmp bl, 26
   ;-- NOTE-THAT: if bl == 0, char == 'a'
   ;-- IF: 'z' < char
   jge number_endThisParse
   ;-- EL: 'a' <= char <= 'a'
   add bl, 10 ;; for 'a' =Hex= 10
   ;; jb number_tryToAddDigitUp


number_tryToAddDigitUp:
   cmp bl, dl
   ;-- IF: bl >= dl
   ;-- WK: this digit >= Base
   jge number_endThisParse
   ;-- EL: bl < dl
   ;-- WK: this is a good digit
   ;-- DO: so add it to rax and loop
   imul rax, rdx   ;; (set! rax (* Base rax))
   add  rax, rbx
   dec  rcx
   jnz  number_fetchNextDigits

number_endThisParse:
;; negate the result according to the sign-indicater on the top of ArgumtStack
   popArgumtStack rbx
   test rbx, rbx
   jz   number_return
   neg  rax
number_return:
   ret


;; the following kinds of strings denote number,
;; because the function ``number'' can handle them.
;; 1. string with '0' - '9' as first char
;; 2. string with '-' as first char and with '0' - '9' as second char
;; so "-->", "_0" do not denote number.
;; under HexBase,
;; "feed" does not denote number, but "0feed", "0_feed" denote number

defCode "stringDenoteNumber?", stringDenoteNumber?
   ;; ( wordString[address, length] -- true or false )
   popArgumtStack  rcx        ;; length  of string
   popArgumtStack  rdi        ;; address of string
   call stringDenoteNumber?_helperFunction
   pushArgumtStack rax        ;; true or false
   next

stringDenoteNumber?_helperFunction:
   xor rbx, rbx

   test rcx, rcx
   ;-- IF: rcx == 0
   ;-- WK: trying to parse a zero-length string, it is an error
   jz stringDenoteNumber?_returnFalse
   ;-- EL: rcx =/= 0
   ;-- WK: we have a non-empty string to be parsed
   mov bl,  byte[rdi]
   cmp bl, '-'
   ;-- IF: bl =/= '-'
   ;-- WK: maybe positive number, maybe error
   jnz @f
   ;-- EL: bl == '-'
   inc rdi
   dec rcx                 ;; update the counter
   test rcx, rcx
   ;-- IF: rcx == 0
   ;-- WK: string is only '-'
   jz stringDenoteNumber?_returnFalse
   ;; fetch next digit
   mov  bl,  byte[rdi]
   inc  rdi

@@:
   sub bl, '0'
   ;-- IF: char < '0'
   jb stringDenoteNumber?_returnFalse
   cmp bl, 10
   ;-- IF: '0' <= char <= '9'
   jb stringDenoteNumber?_returnTrue
   ;-- EL: returnFalse

stringDenoteNumber?_returnFalse:
   xor rax, rax
   ret

stringDenoteNumber?_returnTrue:
   xor rax, rax
   mov rax, qword 1
   ret
defConstString "CommentBeginWordString",  "(*", CommentBeginWordString
defConstString "CommentEndingWordString", "*)", CommentEndingWordString

defWord "ignoreComment", ignoreComment
   ;; (* -- *)
   ;; (* ignore a list of comment words from stdin *)
   dq readWord
   dq CommentEndingWordString, equalString?, false?branch, -4
   dq Two, drop, Exit
defWordEnd ignoreComment


;; 在repl中和在define中对comment的处理方式是不一样的
defWord "(*", comment
   dq ignoreComment
   dq Exit
defWordEnd comment
;; a WordList (unit : CellWidth = 8 bytes)
;;   ||  1 : length-of-Word-1     ||
;;   ||  a : Word-1--as-a-string  ||
;;   ||  1 : length-of-Word-2     ||
;;   ||  b : Word-2--as-a-string  ||
;;   ...

;; note that:
;;    Subsequent calls will overwrite BufferForReadWordListForLexicographer
segment readable writeable
BufferForReadWordListForLexicographer:
   rb 1024*1024

defConstString "EndingWordForReadWordListForLexicographer", ";", EndingWordForReadWordListForLexicographer

defVar "NextWordForReadWordListForLexicographer", BufferForReadWordListForLexicographer, NextWordForReadWordListForLexicographer

defWord ":", readWordListForLexicographer
   ;; (* read a WordList from stdin (ForLexicographer) *)
   ;; (* -- wordList[address, the number of words] *)

   ;; (* 初始化NextWordForReadWordListForLexicographer *)
   dq literal, BufferForReadWordListForLexicographer
   dq NextWordForReadWordListForLexicographer
   dq save

   ;; (* 准备好返回值: [buffer-address, counter] *)
   dq literal, BufferForReadWordListForLexicographer
   dq Zero

   dq readWord

   dq twoDuplicate
   dq CommentBeginWordString, equalString?, false?branch, 5
   dq twoDrop, ignoreComment, branch, -9

   dq twoDuplicate
   dq EndingWordForReadWordListForLexicographer, equalString?, false?branch, 3
   dq twoDrop
   dq Exit

   ;; (* 当字符串不相等的时候: 添加一个word到列表中, 计数器加1 *)
   dq addWordToListForLexicographer
   dq add1
   dq branch, -20
defWordEnd readWordListForLexicographer


;; 以下面的方式来实现这个函数就不具有一般性
;; 还好下面的函数并没有在别的地方被调用过
;; 一个具有一般性的addWordToList应该有两个参数
;; ( wordString[address, length], wordList[address, number of words] -- )
;; 但是也许这样写也没有错
;; 因为我需要一个极小的核心系统来实现self-hosting
defWord "addWordToListForLexicographer", addWordToListForLexicographer
   ;; ( wordString[address, length] -- )
   ;; leave a length behind, for update NextWordForReadWordListForLexicographer at the end
   dq duplicate, xxswapx
   ;;   ||  1 : length-of-Word-1     ||
   dq duplicate, NextWordForReadWordListForLexicographer, fetch, save
   ;; update NextWordForReadWordListForLexicographer
   dq NextWordForReadWordListForLexicographer, fetch, add8, NextWordForReadWordListForLexicographer, save
   ;;   ||  a : Word-1--as-a-string  ||
   dq NextWordForReadWordListForLexicographer, fetch, swap, copyByteString
   ;; update NextWordForReadWordListForLexicographer again
   dq NextWordForReadWordListForLexicographer, addSave
   dq Exit
defWordEnd addWordToListForLexicographer
;; recall
;; a word in the dictionary (unit : CellWidth = 8 bytes)
;; ==
;;   ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
;;   ||  m : name-string  ||
;;   ||  1 : link  ||
;;   ||  1 : type  ||
;;   ||  1 : address-of-name-string-header  ||
;;   ||  1 : address-of-explainer  ||
;;   ||  n : body  ||
;; where
;;   ||  1 : type  ||
;; ==
;;   | type-bit-63 | ... | type-bit-1 | type-bit-0 |
;; type-bit-0 is for HiddenWord
define WordType_HiddenMask 00000001h


defCode "find", find
   ;; (* wordString[address, length] -- word[address of link] or Zero *)
   ;; find doesn't find dictionary entries which are flagged as hidden
   popArgumtStack  rcx     ;; length
   popArgumtStack  rdi     ;; address
   call find_helperFunction
   ;; returns the address of the address of the link of the word in the dictionary (or null)
   pushArgumtStack rax
   next

find_helperFunction:
   ;; >< 不知道下面对rsi的保护有没有必要
   ;; pushArgumtStack rsi    ;; save rsi so we can use it in string comparison
   ;; initialise the searching point
   mov rdx, [FirstWordInDictionary + CellWidth]

find_lookThisPoint:
   test rdx, rdx
   ;-- IF: rdx == 0
   ;-- WK: we reach the end of the linked list
   je find_notFound
   ;-- EL: rdx == 0
   ;-- WK: we have a word to look up
   ;-- DO: look the type field of this word
   mov rax, [rdx + CellWidth]
   and rax, WordType_HiddenMask
   ;-- IF: type::0 of this word =/= 0
   ;-- WK: this word is hidden
   jnz find_lookNextPoint
   ;-- EL: type::0 of this word == 0
   ;-- WK: this word is not hidden
   ;; get word length into rax
   mov TemporaryRegister, [rdx + (2 * CellWidth)]
   mov rax, [TemporaryRegister]
   cmp rax, rcx
   ;-- IF: rax =/= rcx
   ;-- WK: length is not the same
   jne find_lookNextPoint
   ;-- EL: rax == rcx
   ;-- WK: length is the same
   ;-- DO: compare the strings in detail
   pushArgumtStack rcx                       ;; save the length
   pushArgumtStack rdi                       ;; save the address (repe cmpsb will move this pointer)
   lea rsi, [TemporaryRegister + CellWidth]  ;; dictionary string we are checking against.
   ;; >< 下面这个命令的参数是 rsi rdi rcx
   ;; 分别是两个地址和需要被比较的长度
   repe cmpsb                                ;; compare the strings.
   popArgumtStack rdi
   popArgumtStack rcx
   ;-- IF: not the same
   jne find_lookNextPoint
   ;-- EL: the strings are the same
   ;-- DO: return the address of link of this word in rax
   mov rax, rdx
   ;; popArgumtStack rsi
   ret

find_lookNextPoint:
   ;; move back through the link field to the previous word
   mov rdx, [rdx]
   ;; jump back
   jmp find_lookThisPoint

find_notFound:
   ;; return 0
   xor rax, rax
   ;; popArgumtStack rsi
   ret


;; usage;
;; 1 2 readWord + find wordLinkToWordExplainer execute . ( 3 )
defWord "wordLinkToWordExplainer", wordLinkToWordExplainer
   ;; (* word[address of link] -- word[address of explainer] or Zero *)
   dq add8, add8, add8
   dq Exit
defWordEnd wordLinkToWordExplainer
defWord "appendNumberToHere", appendNumberToHere
   ;; (* a 64 bits number -- *)
   ;; reset ``Here'', which points next free memory
   dq Here, fetch
   dq save
   dq Here, fetch, add8
   dq Here ,save
   dq Exit
defWordEnd appendNumberToHere

;; note that:
;; a string in stack is string[address, length]
;; a string in memory is ||  1 : length  ||  n : string  ||
defWord "appendStringToHere", appendStringToHere
   ;; ( string[address, length] -- )
   ;; leave a length behind, for update Here
   dq duplicate, xxswapx
   ;;   ||  1 : length  ||
   dq duplicate, appendNumberToHere
   ;;   ||  n : string  ||
   dq Here, fetch, swap, copyByteString
   ;; update Here
   dq Here, fetch, addition, Here, save
   dq Exit
defWordEnd appendStringToHere

;; test: appendNumberToHere
;; 6 , Here fetch sub8 fetch .


;; recall
;; a word in the dictionary (unit : CellWidth = 8 bytes)
;;   ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
;;   ||  m : name-string  ||
;;   ||  1 : link  ||
;;   ||  1 : type  ||
;;   ||  1 : address-of-name-string-header  ||
;;   ||  1 : address-of-explainer  ||
;;   ||  n : body  ||

defWord "createWordHeader", createWordHeader
   ;; ( string[address, length] -- word[address of link] )
   dq Here, fetch, xxswapx ;; for address-of-name-string-header
   dq appendStringToHere
   dq Here, fetch, appendNumberToHere ;; (* identification *)
   dq Here, fetch ;; (* leave the word[link] *)
   dq Zero, appendNumberToHere ;; (* link *)
   dq Zero, appendNumberToHere ;; (* type *)
   dq swap
   dq appendNumberToHere ;; address-of-name-string-header
   dq Exit
defWordEnd createWordHeader


defWord "createWordHeaderForFunction", createWordHeaderForFunction
   ;; ( string[address, length] -- word[address of link] )
   dq Here, fetch, xxswapx ;; for address-of-name-string-header
   dq appendStringToHere
   dq Zero, appendNumberToHere ;; (* SizeOfFunctionBody *)
   dq Here, fetch, appendNumberToHere ;; (* identification *)
   dq Here, fetch ;; (* leave the word[link] *)
   dq Zero, appendNumberToHere ;; (* link *)
   dq Zero, appendNumberToHere ;; (* type *)
   dq swap
   dq appendNumberToHere ;; address-of-name-string-header
   dq Exit
defWordEnd createWordHeaderForFunction


;; 下面的函数其实可以处理任何函数返回的wordlist
;; 但是readWordListForLexicographer是专门为这里的函数而准备的
;; 之所以需要这种专门的reader
;; 是因为我实现这些reader的方式具有局限性
defWord "appendWordDescriptionToHere", appendWordDescriptionToHere
   ;; 这是一个处理列表的递归函数?? 其实是循环 因为我还没实现递归定义呢
   ;; 或者说这是一个尾递归优化了的递归函数
   ;; ( wordList[address, the number of words] -- )
   dq duplicate, zero?branch, 16;-- GOTO: twoDrop
   dq tailAndHeadOfWordList
   dq twoDuplicate, stringDenoteNumber?
   dq false?branch, 6;-- GOTO: 处理非数字
   ;; 处理数字, 这里放弃了对number的返回值作错误处理的机会
   dq number, drop, appendNumberToHere
   dq branch, -12;-- GOTO: the beginning
   ;; 处理非数字
   dq find, wordLinkToWordExplainer, appendNumberToHere
   dq branch, -17;-- GOTO: the beginning
   ;; 结束
   dq twoDrop
   dq Exit
defWordEnd appendWordDescriptionToHere

defWord "addNewWordToDictionary", addNewWordToDictionary
   ;; reset FirstWordInDictionary to point to the newly defined word
   ;; ( word[address of link] -- )
   dq duplicate
   dq FirstWordInDictionary, fetch
   dq swap
   dq save
   dq FirstWordInDictionary, save
   dq Exit
defWordEnd addNewWordToDictionary

defWord "setTheSizeOfFunctionBody", setTheSizeOfFunctionBody
   ;; (* wordList[address, the number of words], word[address of link] --
   ;;    wordList[address, the number of words], word[address of link] *)
   dq duplicate
   dq sub8, sub8
   dq xoverxx
   dq swap
   dq save
   dq Exit
defWordEnd setTheSizeOfFunctionBody

defWord "defineFunction", defineFunction
   ;; ( wordList[address, the number of words] -- )
   ;; to create a new word
   ;; is to use some words to describe the new word,
   ;; and let an explainer to explain the description of the new word.
   ;; to define a new word
   ;; is to add the new created word to the dictionary.
   dq tailAndHeadOfWordList
   dq createWordHeaderForFunction
   dq FunctionBodyExplainer, appendNumberToHere
   dq setTheSizeOfFunctionBody
   dq xxswapx
   dq appendWordDescriptionToHere
   dq addNewWordToDictionary
   dq Exit
defWordEnd defineFunction
defWord "basicREPL", basicREPL
   ;; ( unknown -- unknown )
   dq TheReturnStackTop, resetReturnStackPointer
   dq TheArgumtStackTop, resetArgumtStackPointer
   dq readAndExeute
   dq branch, -2
   ;; must not end with Exit here
defWordEnd basicREPL


defWord "readAndExeute", readAndExeute
   ;; ( unknown -- unknown )
   dq readWordForRuntime
   dq twoDuplicate, stringDenoteNumber?
   dq false?branch, 4;-- GOTO: find, 处理非数字

   ;; 处理数字, 这里放弃了对number的返回值作错误处理的机会
   dq number, drop
   dq Exit

   ;; 处理非数字
   dq find, duplicate, zero?branch, 4;-- GOTO: drop, errorOfReadAndExeute
   dq wordLinkToWordExplainer, execute
   dq Exit

   dq drop, errorOfReadAndExeute
   dq Exit
defWordEnd readAndExeute


defCode "errorOfReadAndExeute", errorOfReadAndExeute
   mov sys_3_rdx, errorOfReadAndExeute_massageSize
   mov sys_2_rsi, errorOfReadAndExeute_massage
   mov sys_1_rdi, 1; stdout
   mov sys_n_rax, syscall_write
   syscall
   next

segment readable writeable
errorOfReadAndExeute_massage   db ' <undefined word> ',ascii.linefeed
errorOfReadAndExeute_massageSize = ($ - errorOfReadAndExeute_massage)
SizeOfUserDataSegment = 11 * 1024 * 1024 ;; unit: byte
segment readable writeable
UserDataSegment:
        rb SizeOfUserDataSegment
EndOfUserDataSegment:
SizeOfReturnStack = 100 * 1024 ;; unit: CellWidth

defConst "ReturnStackTop",    ReturnStackTop,    TheReturnStackTop
defConst "ReturnStackBottom", ReturnStackBottom, TheReturnStackBottom

segment readable writeable
ReturnStackBottom:
        rq SizeOfReturnStack
ReturnStackTop:
        rq 100


defConst "ArgumtStackTop",    ArgumtStackTop,    TheArgumtStackTop
defConst "ArgumtStackBottom", ArgumtStackBottom, TheArgumtStackBottom

SizeOfArgumtStack = 100 * 1024 ;; unit: CellWidth
segment readable writeable
ArgumtStackBottom:
        rq SizeOfArgumtStack
ArgumtStackTop:
        rq 100
;;   (unit : byte)
;; ========================
;;   ||  1 : color     ||
;; ------------------------
;;   ||  8 : type tag  ||
;;   ||  8 : value     ||
;; ------------------------
;;   ||  8 : type tag  ||
;;   ||  8 : value     ||
;; ========================

ClrBytesSize = 1
CarBytesSize = 16
CdrBytesSize = 16
ConsBytesSize = ClrBytesSize + CarBytesSize + CdrBytesSize
NumberOfPairConstructions = 1024;; unit: byte

defConst "ClrBytesSize"  , ClrBytesSize  , TheClrBytesSize
defConst "CarBytesSize"  , CarBytesSize  , TheCarBytesSize
defConst "CdrBytesSize"  , CdrBytesSize  , TheCdrBytesSize
defConst "ConsBytesSize" , ConsBytesSize , TheConsBytesSize

segment readable writeable
        rb ClrBytesSize
InFrontOfTheFirstPairConstruction:
        rb (CarBytesSize + CdrBytesSize)

        rb ClrBytesSize
FirstPairConstruction:
        rb (CarBytesSize + CdrBytesSize)

        ;; ==========================
        rb (NumberOfPairConstructions - 2) * ConsBytesSize
        ;; ==========================

        rb ClrBytesSize
LastPairConstruction:
        rb (CarBytesSize + CdrBytesSize)

defConst "NumberOfPairConstructions", NumberOfPairConstructions, TheNumberOfPairConstructions

defConst "InFrontOfTheFirstPairConstruction", InFrontOfTheFirstPairConstruction, TheInFrontOfTheFirstPairConstruction
defConst "FirstPairConstruction", FirstPairConstruction, TheFirstPairConstruction
defConst "LastPairConstruction",  LastPairConstruction,  TheLastPairConstruction

defVar "CurrFreePairConstruction", FirstPairConstruction, CurrFreePairConstruction


;;------------------------------------------
;; 需要专门为gc准备一个栈 这个栈用来存放grey的pair
;; 这个栈中并不需要存放 type-tag 因为其中的所有值都是pair类型

SizeOfGreyPairStack = 100 * 1024 ;; unit: CellWidth
segment readable writeable
GreyPairStackBottom:
        rq SizeOfGreyPairStack
GreyPairStackTop:
        rq 1
;; a SymbolEntry (unit : byte)
;; ========================
;;   ||  1 : SymbolLength  ||
;; ------------------------
;;   || 56 : SymbolString  ||
;; ========================

SymbolLengthBytesSize = 1
;; 下面这个常数是多大应该根本不影响程序Symbol工作方式
SymbolStringBytesSize = 56 + 63;; 这样在SymbolEntry的末尾就可以保存一个word的地址
SymbolMaxLength = SymbolStringBytesSize
SymbolEntryBytesSize = SymbolLengthBytesSize + SymbolStringBytesSize
;; NumberOfSymbolEntrys = 1000003
;; NumberOfSymbolEntrys = 1000033
;; NumberOfSymbolEntrys = 1000333
;; ><><>< the numbers above are too big for ELF ???
;; NumberOfSymbolEntrys = 100003
NumberOfSymbolEntrys = 100333
;; NumberOfSymbolEntrys = 997
;; NumberOfSymbolEntrys = 499
;; NumberOfSymbolEntrys = 230


defConst "NumberOfSymbolEntrys",  NumberOfSymbolEntrys,  TheNumberOfSymbolEntrys
defConst "SymbolLengthBytesSize", SymbolLengthBytesSize, TheSymbolLengthBytesSize
defConst "SymbolStringBytesSize", SymbolStringBytesSize, TheSymbolStringBytesSize
defConst "SymbolMaxLength",       SymbolMaxLength,       TheSymbolMaxLength
defConst "SymbolEntryBytesSize",  SymbolEntryBytesSize,  TheSymbolEntryBytesSize

segment readable writeable

FirstSymbolEntry:
        rb SymbolEntryBytesSize

        ;; ========================
        rb (NumberOfSymbolEntrys - 2) * SymbolEntryBytesSize
        ;; ========================

LastSymbolEntry:
        rb SymbolEntryBytesSize


defConst "FirstSymbolEntry", FirstSymbolEntry, TheFirstSymbolEntry
defConst "LastSymbolEntry",  LastSymbolEntry,  TheLastSymbolEntry
SizeOfStringHeap = 1024 ;; unit: byte
segment readable writeable
StringHeap1:
        rb SizeOfStringHeap
EndOfStringHeap1:
segment readable writeable
StringHeap2:
        rb SizeOfStringHeap
EndOfStringHeap2:

defConst "SizeOfStringHeap", SizeOfStringHeap, TheSizeOfStringHeap

defConst "StringHeap1", StringHeap1, TheStringHeap1
defConst "StringHeap2", StringHeap2, TheStringHeap2
SizeOfLambdaStack = 100 * 1024 ;; unit: CellWidth
segment readable writeable
LambdaStackBottom:
        rq SizeOfLambdaStack
LambdaStackTop:
        rq 1
defConst "ascii.zero", 48, ascii.zero
defWord ".", printLittleNumber
   dq ascii.zero, addition, writeChar
   dq Exit
defWordEnd printLittleNumber

defCode "exitWithTOS", exitWithTOS
   popArgumtStack sys_1_rdi
   mov sys_n_rax, syscall_exit
   syscall

defWord "assemblyDebug", assemblyDebug
   ;; dq ><><><
   dq exitWithTOS
defWordEnd assemblyDebug
defConst "TheLatestWordInThisFile", 0, TheLatestWordInThisFile

#+TITLE: xiaolinguist
#+AUTHOR: XYH(谢宇恒)
#+EMAIL: xyheme@gmail.com


* TODO
1. xiaolinguist-mode 的中文支持

2. to hike over the island to the sea

3. 设计debuger的更好的用户界面
4. 设计字符串的垃圾回收器
5. 研究一下终端转义序列

6. 去写各种``语法编撰者''
   因为可以多次parse (多次pass)
   所以不同的``语法编撰者''之间可以彼此继承
   ><><>< 去实现相互对递归的函数的定义 ????
7. 设计word的语法 就是选出某些特殊的字符给它们赋予语义
   语义赋予的好不好就要看设计者的品味了
8. lambda 将要求用sexp来实现function-body
   这是为了灵活性
   而xiaolinguist的基础部分 使用array来实现function-body
   这是为了速度
9. 也许只能把函数以我现在的方式定义到字典里已经不能另我满意了
   因为查字典的速度是于字典的长度正相关的
   所以我的编译器的速度将会越来越慢
   ><><>< 用hash-table ???
   怎么用呢??? 给symbol的hash-table中每一项所保存字符串的field之外在增加一些field ???
   但是这是不合理的 因为如果这样的话 垃圾回收器就要跑遍它了
   也许可以限制symbol的一个field中只能保存那些已经定义在字典中的东西
   这种设计的用性如何呢 ?????????????
   因为字典中的word是不可删除的所以这样就是安全的
10. ><><>< 设计symbol和sexp的用法
11. 把注释标记从"("和")" 换成"(*"和"*)"
    要不然就浪费了大好符号
12. 关于数字的read和write
    大小写都要支持
    并且要支持__
13. ><><>< BUG
    当字典编撰者没有找到一个word的时候就会让程序崩溃
14. 调整gc 以增加<symbol> & <string>这两个数据类型
15. 给实现栈的macro增加错误处理
16. 估算运行时的空间消耗
    并重新设计各个内存块的大小
17. hash map
18. 研究并实现类似joy的对函数作用的模拟
    同时设计使用list这个数据结构的方式
* --------------------------------------------------
* notes about linguistics
1. 我可以把这个语言设计成一个关于语言本身的游戏
   程序语言与自然语言之间的类比非常有趣
2. lexicon : meaning "of or for words"
   Linguistic theories generally regard human languages as consisting of two parts:
   1) a lexicon, essentially a catalogue of a language's words (its wordstock);
   2) and a grammar, a system of rules which allow
      for the combination of those words into meaningful sentences.

   The lexicon is also thought to include bound morphemes,
   which cannot stand alone as words (such as most affixes).
   In some analyses,
   compound words and certain classes of idiomatic expressions
   and other collocations are also considered to be part of the lexicon.
   Dictionaries represent attempts at listing, in alphabetical order,
   the lexicon of a given language;
   usually, however, bound morphemes are not included.

   Items in the lexicon are called lexemes or word forms.
   Lexemes are not atomic elements
   but contain both phonological and morphological components.

   When describing the lexicon a reductionist approach is used,
   trying to remain general while using a minimal description.

   A lemma is a group of lexemes generated by inflectional morphology.
   Lemmas are represented in dictionaries by headwords
   which list the citation forms and any irregular forms,
   since these must be learned to use the words correctly.

   Lexemes derived from a word by derivation morphology are considered new lemmas.
   The lexicon is also organized according to open and closed categories.
   Closed categories, such as determiners or pronouns,
   are rarely given new lexemes; their function is primarily syntactic.
   Open categories, such as nouns and verbs,
   have highly active generation mechanisms
   and their lexemes are more semantic in nature.

   A central role of the lexicon is the documenting of established lexical norms and conventions.
   Lexicalization is the process where new words,
   having gained into widespread usage, enter in the lexicon.
   The mechanisms, not mutually exclusive, are:
   1) Innovation, the planned creation of new roots (often on a large-scale), such as slang, branding.
   2) Borrowing of foreign words.
   3) Compounding (composition), the combination of lexemes to make a single word.
   4) Abbreviation of compounds.
   5) Acronyms, the reduction of compounds to their initial letters, such as NASA and laser (from "LASER").
   6) Inflection, a morphology change with a category, such as number or tense.
   7) Derivation, a morphological change resulting in a change of category.
   8) Agglutination, the compounding of morphemes into a single word.
   Besides word formation, there are also mechanisms of lexeme change:
   1) Lexical replacement, the replacement of a lexeme or its sense.
   2) Sound change, a change such as a consonant or vowel shift localised to specific words or phonotactical combinations.
   3) Blocking the creation of new words while existing lexical conventions are maintained.
   4) Obsolescence of vocabulary; much slang, for example, typically has short lifespans.
3. Neologisms
4. morph
   语义的最小单元
5. catena
   any syntactic tree or connected subgraph of a tree is a catena.
   In this regard, every constituent is a catena,
   but there are many catenae that are not constituents.
   The constituent is therefore a subtype of catena.
6. Role of morphology
   Another mechanism involves generative devices that combine morphemes according to a language's rules.
   For example, the suffix "-able" is usually only added to transitive verbs, as in "read-able" but not "cry-able".
7. Compounding tends to produce longer lexemes which may result in lexemes of unwieldy proportion.
   This is compensated by mechanisms that reduce the length of words.
8. 设想建造一个中文词典
   设想建造一个人造语言的词典 就像toki-pona一样
9. tale
10. lie
11. story
12. ratiocination:
    process of reasoning
    logical deduction
13. rumor
14. falsehood
15. perpetrate
16. prose
17. plot
18. fiction
19. dictio
20. explain
    explainer
    explanatory
21. elucidate
    elucidator
    lucid
22. etymology
23. wordstock :
    (linguistics) The set of words in a language.
24. pictionary
25. 既然有了自己的字典
    为什么不能有自己的语言呢??
26. words should be defined using
    ``terms less abstruse than that which is to be explained''
27. lens
28. "It is often forgotten that (dictionaries) are artificial repositories,
    put together well after the languages they define.
    The roots of language are irrational and of a magical nature."
29. expound expounder exponent
30. riddle
31. elaborate
32. describe describer description
33. depict depiction
34. genre
35. lexicographer
36. prescriptive vs. descriptive
37. core glossary, defining dictionary
* notes about programming
1. in xiaolinguist, a ``word'' can not begin with [0-9]
   and can not begin with a `-' follows [0-9]
2. 在xiaolinguist中
   在用户空间所形成的字典中定义的word是可以被覆盖
   但是没法被删除的
   这可以说是所有的类forth语言的特点
3. ``to use forth is to re-think my words down
   to requiring a small number of arguments''
4. 由于xiaolinguist的间接性
   想要对xiaolinguist的行为方式形成透彻的理解是非常容易的
   要知道 对一个程序语言的行为方式的理解的偏失是非常可怕的
   形成完整的理解之后
   想要灵活地使用它就很简单
   想要扩展它也很简单
   想要以它为基础(或以它为工具)设计自己的语言也就很简单
5. ``avoiding syntactic complexity
   results in maximum flexibility''
6. expression  -- interpret
   description -- explain
7. 发现了joy这个语言
   它把所有栈处理函数理解成以栈为单一的参数以栈为单一的返回值的函数
   + 这个函数的数学性质我想都不敢想
     也许可以理解为无穷维空间到无穷维空间的变换
     但是一个具体的函数其实只是在维数很小的投影空间中的变换
   只是理解上的差异吗??
   任何的forth都可以以这种方式来理解吗??
   这种理解方式指出了``那些单纯的栈处理函数具有数学函数的性质''
   这种单参数性还带来了自然的curry
   这样words对新word的描述就被理解成了
   用函数的复合来定义一个新的函数
   joy的另一个特点是recursive combinators的使用
   Instead of lambda abstraction Joy uses program quotation,
   and higher order functions can be simulated by
   first order functions which dequote quoted programs.
   quotation就是保存一段计算在栈里吗???
   如果是的话我就可以在我的系统里模拟这种语义
8. 把数字都理解成函数之后
   就没有函数的作用了
   之后函数的复合
   而这里的一元函数的集合在复合之下是满足结合律的
   所以性质比函数的作用要好多了
   + 在设计程序语言的时候
     候常常要约定函数作用的结合方向
     而对于具有结合性的函数复合 就不用约定了
   + 但是不使用函数的作用
     就失去了λ-cal中的那种``代入''语义
     而这种语义正式我喜欢λ-cal的原因
     我觉得这种语义使用起来很灵活很方便
   + 其实是可以的
     比如那个最典型的高阶函数的例子:
     某个利用到等词的函数接收不同的等词作为参数比如[equal?]和[eq?]
     然后形成一个作用于列表的函数
     但是在joy中后面的一个作为的高阶函数作用之后
     得到的不是一个函数(一个函数被入栈)
     而是一个函数的作用
9. 所有的函数都是以栈为参数以栈为返回值的函数
   之后当然就没有高阶函数了 !!!
   但是类似高阶函数的语义可以通过列表这个数据结构外加一个解释器来实现
   一个word列表是一句
   而一些word列表被入栈之后就形成了一段
   而诠释者所诠释的就可以是这些段了
   尽管在语义上 可以把诠释者理解为高阶函数
   但是它们都还是作用于栈的一元函数
   并且具有数学函数的一致性
   也就是说稍微丰富一下数据结构
   然后 我们就在 具有结合性的 最纯粹的 程序语言中
   获得了类似λ-abstraction的语义
10. ><><>< joy强调要消除λ-ap 因为它不结合
    digrap也能消除λ-ap 但是提供出来的可能是一种``更不结合''的代数
    (并且digrap能够消除所有约束变元)
    但是其实digrap所提供的根本就不是代数
    因为想要谈一个代数的结合性
    那个代数必须是二元的 当然了 代数都是二元的
    但是digrap是三元的
11. 不知道joy给不给用户提供定义``诠释者''的机制
    但是我的语言一定要提供这种东西
    一方面是用户自制的编译器
    一方面是用户自制的解释器
    是吗?
    其实不是的
    因为我这里的解释器其实是假的
    它们是帮助编译器完成任务的工具而已
    并且在编译的过程中就已经指定好了
    但是
    当我有了动态内存管理之后
    只要换一个``诠释者''一段编译好的程序就可以被解释成一段数据了
    并且只要让word这个数据结构变丰富
    那么在很多地方我就能省略find而获得更快的运行速度
12. 不论如何首先我需要一个动态内存管理系统
    否则一些都不能进入实现阶段
13. 为什么想要写一个文本编辑器呢???
    因为以后如果我的算法是用有向图来表示的话
    我就希望能拥有一个有向图编辑器
    而写文本编辑器能够获得有关的一些基本技术
14. 为什么想要写一个文本编辑器呢???
    因为我发现
    我的forth系统中的字典编撰者就像是文本编辑器一样 !!!
    看那些函数的名字就知道了
    而Here这个指针 就像是一个光标一样
    只不过在没有动态内存管理的条件下
    我没有良好的list数据结构可用
    因而也就没法作插入和删除操作之类的
15. 为什么想要写一个文本编辑器呢???
    看上一个条目
    你就发现我把开发环境和程序语言结合起来了不是吗??
    语法解析之后 再文本编辑
    那么文本编辑器就能真正读懂它所编辑的语言了 !!
16. 但是上面夸大其词了
    是吗???
    因为用 比如说 双向链表 这个数据结构来实现文本编辑器的时候
    文本编辑本身就是链表处理
    + 但是是以代表光标位置的指针为参数的
      受joy的启发我就知道
      这里的双向链表处理操作也具有数学函数的性质!! 即一致性
17. joy中 那种所期待的结合律 就反映在forth系统的线性性之中
18. joy想要强调的当然就是combinatory logic了
    monoid幺半群
    都是一些堂而皇之的名字而已
19. 把forth理解为combinatory logic就能获得数学上的纯洁性
    而wordy-lisp能够提供实用的应用级别的函数式编程语言
    而digrap能够带来数学上的混乱 能够该来风暴
20. forth所能提供的函数之间的统一接口太重要了
    也就是栈
    栈就像一个市场一样
    函数们可以在这里自由地交换信息
    是这种统一的参数传递的市场使得模块化称为可能
    + >< 但是其实并不是如此!!!
      参数是有顺序的
      如何像wordy-lisp一样取消这种顺序??
21. 我的这个系统的一个特点可能是嵌套的readers
    比如对``if''这种基本条件控制结构的实现
    就可以利用一个特殊的reader来完成
22. 是后缀表达式使得我能够几乎完全不用语法分析 而线性的解读源代码
    所以很容易写出来针对forth的源代码的静态分析工具
    scheme也具有同样的简洁性
    只不过相比之下forth的简洁性已经达到极端了
23. 多个值在语义上形成一个结构化的值
    需要总结一下这里使用数据结构的方式
24. The whole point of Forth was that
    you didn't write programs in Forth
    you wrote vocabularies in Forth.
    When you devised an application
    you wrote a hundred words or so that discussed the application
    and you used those hundred words to write a one line definition to solve the application.
    It is not easy to find those hundred words,
    but they exist,
    they always exist.
25. 我在这里实现的forth
    是一个schemer眼中的forth
    我更改了forth中的传统术语来适应我对程序的理解
26. 有时(仅仅是有时)
    写forth程序有一种由下至上的感觉
    + 因为完成更多工作的字是用完成更少工作的字来定义的
      而forth虚拟机对整个代码文本的解释又是线性的
    而写scheme程序有一种由上至下的感觉
    + 我经常是先写勾勒大的函数的框架
      然后把小的辅助函数补充进去
      但是我发现这种写程序的方式很困难
      也许是因为scheme的某些局限性
      也许是因为我使用的这种方式本身就是错误的
    就程序设计而言这是非常不同的两种方法
    这两种方法之前的差异甚至比各种编程范式之间的差异还要重要
27. 另外一个非常重要的区别就是栈的深度
    古典的不支持递归的forth中的栈很浅
    而scheme对递归的依赖要求很深的栈
    + 也许
      浅的栈可以用来方便的实现多任务
      而scheme可以通过call/cc来以另一种方式实现多任务
28. 关于动态内存管理:
    思考和考察各种实现方式之后
    发现最简单的方式就是使用lisp中的cons
    也就是把类lisp的列表处理融合到forth中来
    只有这样才能保证垃圾回收器的简单性
29. 要想在实现动态的内存处理的同时
    还保持以明显的方式来自由的使用内存的能力
    就不能用那种复制的方式
    否则就要再实现一层虚拟内存
30. 需要使用一种mark-and-sweep式的垃圾回收器
    但是整个的策略并不改变
    是先写一个静态的基本的forth
    再在上面实现一层动态内存管理
31. 但是
    好消息是
    我可以先做好一个没有内存管理的forth
    然后在这个forth的内部实现一层对内存的管理!!!
    坏消息是
    这个底层的forth中有一个固定的字典了
    也就是说有两个字典
    一个是静态的
    一个是动态的
    这破坏了一致性
    但是我就能不用汇编而用forth来实现内存管理了
32. 这个链表数据结构必须在forth中实现
    + 而不是在我之后将要写的以forth为目标语言的编译器中实现
    因为对于forth的dictionary本身
    我也想使用动态的内存管理
33. 我有自己注释汇编代码的风格
    ;-- IF:
    ;-- WK: denote ``we know''
    ;-- EL: denote ``else''
    ;-- NT: denote ``note that''
    ;-- note that
34. forth is a kind of word processing language
    对于每个语言明白它主要善于处理的数据结构是很重要的
    一个语言拥有自己擅长处理的数据结构的语言是非常有趣的
    比如lisp和forth
    也许fortran对浮点数的处理也是有趣的
    + 然而说C是字符处理语言其实是对C的侮辱
      因为字符没啥好处理的
35. 只有在字典dictionary里的东西才是字word
    word
    被我理解为与dictionary中
    表示word数的数据结构中的body部分的起始地址等价
    word的分类:
    1) primitive-function
    2) compound-funcrtion
    3) var
    4) const
36. variable
    被我理解为是以寄存器名字为标识的存储空间
    或者是以内存地址值为标识的存储空间
37. pointer
    被我理解为是保存地址的variable
38. 约定:
    1) 变元名或地址名 开头字母用大写 用大写来断词 比如 CellWidth
       像德语中的名词一样
    2) 子程名或宏名 开头字母用小写 用大写来断词 比如 next, explainFunctionBody
       动词
    3) 只有某些地方不得不尊重C和linux的中的传统的时候
       才使用下划线来断词
39. myforth大小写敏感
    myforth中所有的函数名都用小写
    一般都是word所以用不到断词
40. 用间接线程的方式来实现线程
    这样数据段与代码段就能尽量分开
41. 在forth中有单纯的对fixnum的操作就够了
    对各种量的类型的编码与实现应该在编译器中完成
* 十诫
1. 汇编中每一个子程都有两个性质:
   1) 它所需要的寄存器
   2) 它所更改的寄存器
   当对代码感到困惑时就先把这两个值注释出来
   我的注释方式如下:
   ;== NEED: NextWordPointer
   ;== CHNG: NextWordPointer, CurrWordPointer
   + 好的汇编器应该把这两个性质直接添加到子程的数据结构当中
     正如sicp中的寄存器机所做的那样
2. marco里的jmp 必须用匿名标签 要不然就重复了
   这导致在别的代码里不能跨越macro来使用匿名标签
   所以规则是只在marco中使用匿名标签
   在任何其他地方都不要使用匿名标签
   + 尤其是当你使用很多macro的时候尤其要注意这条戒律
3. 在汇编中用defCode定义函数时 后面要加next
   在汇编中用defWord定义函数时 后面要加Exit (除非是非常特殊的函数才不用加Exit)
   在汇编中使用forth中的变元时 处理的是这个地址:[<var> + CellWidth]
4. 每个函数的参数个数不应该很多 多于三个的时候就要仔细检查必要性了
5. 用一个想像中的类型系统来帮助自己编程
   (其实这种类型推到应该被机器完成)
   当branch的时候注意类型的一致
6. 写一个大函数的时候发现需要把它分解成小函数
   然后你就去写那些小函数
   重要的是每写完一个小函数的时候 如果这个函数的正确性不是显然的
   那么就马上去测试这个小函数的正确性
   因为当回到大函数的时候 就很难发现是那里错误了
   + 其实不难发现是哪里错了
     因为forth系统的线性性
     使得当一段函数的执行出错了的时候
     找到真正出错的那个函数的过程非常容易
7. 如果要使用计数器
   那么等被计数的那件事干完了之后再增加或减少计数器
   而不要先更改计数器再去做计数器所计数的工作
8. 每次更改含有branch的函数的时候
   要记得更新branch后面的offset
9. 当变量保存的是地址的时候
   + 即 变量是一个指针的时候
   在呼唤这个变量的名字而得到这个变量的地址之后
   不要忘记在后面加一个fetch
   这样才能得到这个变量所保存的地址
10. 任何戒律在需要的时候都可以被打破
    但是你一定要明白为什需要打破这些戒律
    并且在打破旧的戒律的同时
    你要探寻新的规则
    不是要用这些规则限制自己
    而是要在观察中总结自然的规律
    以形成对自然的更好的认识
* ==================================================
* syscall numbers
/usr/include/asm/unistd_64.h (in archlinux)
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
;; parameters order of syscall:
define sys_6_r8  r8
define sys_5_r9  r9
define sys_4_r10 r10
define sys_3_rdx rdx
define sys_2_rsi rsi
define sys_1_rdi rdi
define sys_n_rax rax

;; syscall number:
define syscall_read                      0
define syscall_write                     1
define syscall_open                      2
define syscall_close                     3
define syscall_stat                      4
define syscall_fstat                     5
define syscall_lstat                     6
define syscall_poll                      7
define syscall_lseek                     8
define syscall_mmap                      9
define syscall_mprotect                  10
define syscall_munmap                    11
define syscall_brk                       12
define syscall_rt_sigaction              13
define syscall_rt_sigprocmask            14
define syscall_rt_sigreturn              15
define syscall_ioctl                     16
define syscall_pread64                   17
define syscall_pwrite64                  18
define syscall_readv                     19
define syscall_writev                    20
define syscall_access                    21
define syscall_pipe                      22
define syscall_select                    23
define syscall_sched_yield               24
define syscall_mremap                    25
define syscall_msync                     26
define syscall_mincore                   27
define syscall_madvise                   28
define syscall_shmget                    29
define syscall_shmat                     30
define syscall_shmctl                    31
define syscall_dup                       32
define syscall_dup2                      33
define syscall_pause                     34
define syscall_nanosleep                 35
define syscall_getitimer                 36
define syscall_alarm                     37
define syscall_setitimer                 38
define syscall_getpid                    39
define syscall_sendfile                  40
define syscall_socket                    41
define syscall_connect                   42
define syscall_accept                    43
define syscall_sendto                    44
define syscall_recvfrom                  45
define syscall_sendmsg                   46
define syscall_recvmsg                   47
define syscall_shutdown                  48
define syscall_bind                      49
define syscall_listen                    50
define syscall_getsockname               51
define syscall_getpeername               52
define syscall_socketpair                53
define syscall_setsockopt                54
define syscall_getsockopt                55
define syscall_clone                     56
define syscall_fork                      57
define syscall_vfork                     58
define syscall_execve                    59
define syscall_exit                      60
define syscall_wait4                     61
define syscall_kill                      62
define syscall_uname                     63
define syscall_semget                    64
define syscall_semop                     65
define syscall_semctl                    66
define syscall_shmdt                     67
define syscall_msgget                    68
define syscall_msgsnd                    69
define syscall_msgrcv                    70
define syscall_msgctl                    71
define syscall_fcntl                     72
define syscall_flock                     73
define syscall_fsync                     74
define syscall_fdatasync                 75
define syscall_truncate                  76
define syscall_ftruncate                 77
define syscall_getdents                  78
define syscall_getcwd                    79
define syscall_chdir                     80
define syscall_fchdir                    81
define syscall_rename                    82
define syscall_mkdir                     83
define syscall_rmdir                     84
define syscall_creat                     85
define syscall_link                      86
define syscall_unlink                    87
define syscall_symlink                   88
define syscall_readlink                  89
define syscall_chmod                     90
define syscall_fchmod                    91
define syscall_chown                     92
define syscall_fchown                    93
define syscall_lchown                    94
define syscall_umask                     95
define syscall_gettimeofday              96
define syscall_getrlimit                 97
define syscall_getrusage                 98
define syscall_sysinfo                   99
define syscall_times                     100
define syscall_ptrace                    101
define syscall_getuid                    102
define syscall_syslog                    103
define syscall_getgid                    104
define syscall_setuid                    105
define syscall_setgid                    106
define syscall_geteuid                   107
define syscall_getegid                   108
define syscall_setpgid                   109
define syscall_getppid                   110
define syscall_getpgrp                   111
define syscall_setsid                    112
define syscall_setreuid                  113
define syscall_setregid                  114
define syscall_getgroups                 115
define syscall_setgroups                 116
define syscall_setresuid                 117
define syscall_getresuid                 118
define syscall_setresgid                 119
define syscall_getresgid                 120
define syscall_getpgid                   121
define syscall_setfsuid                  122
define syscall_setfsgid                  123
define syscall_getsid                    124
define syscall_capget                    125
define syscall_capset                    126
define syscall_rt_sigpending             127
define syscall_rt_sigtimedwait           128
define syscall_rt_sigqueueinfo           129
define syscall_rt_sigsuspend             130
define syscall_sigaltstack               131
define syscall_utime                     132
define syscall_mknod                     133
define syscall_uselib                    134
define syscall_personality               135
define syscall_ustat                     136
define syscall_statfs                    137
define syscall_fstatfs                   138
define syscall_sysfs                     139
define syscall_getpriority               140
define syscall_setpriority               141
define syscall_sched_setparam            142
define syscall_sched_getparam            143
define syscall_sched_setscheduler        144
define syscall_sched_getscheduler        145
define syscall_sched_get_priority_max    146
define syscall_sched_get_priority_min    147
define syscall_sched_rr_get_interval     148
define syscall_mlock                     149
define syscall_munlock                   150
define syscall_mlockall                  151
define syscall_munlockall                152
define syscall_vhangup                   153
define syscall_modify_ldt                154
define syscall_pivot_root                155
define syscall__sysctl                   156
define syscall_prctl                     157
define syscall_arch_prctl                158
define syscall_adjtimex                  159
define syscall_setrlimit                 160
define syscall_chroot                    161
define syscall_sync                      162
define syscall_acct                      163
define syscall_settimeofday              164
define syscall_mount                     165
define syscall_umount2                   166
define syscall_swapon                    167
define syscall_swapoff                   168
define syscall_reboot                    169
define syscall_sethostname               170
define syscall_setdomainname             171
define syscall_iopl                      172
define syscall_ioperm                    173
define syscall_create_module             174
define syscall_init_module               175
define syscall_delete_module             176
define syscall_get_kernel_syms           177
define syscall_query_module              178
define syscall_quotactl                  179
define syscall_nfsservctl                180
define syscall_getpmsg                   181
define syscall_putpmsg                   182
define syscall_afs_syscall               183
define syscall_tuxcall                   184
define syscall_security                  185
define syscall_gettid                    186
define syscall_readahead                 187
define syscall_setxattr                  188
define syscall_lsetxattr                 189
define syscall_fsetxattr                 190
define syscall_getxattr                  191
define syscall_lgetxattr                 192
define syscall_fgetxattr                 193
define syscall_listxattr                 194
define syscall_llistxattr                195
define syscall_flistxattr                196
define syscall_removexattr               197
define syscall_lremovexattr              198
define syscall_fremovexattr              199
define syscall_tkill                     200
define syscall_time                      201
define syscall_futex                     202
define syscall_sched_setaffinity         203
define syscall_sched_getaffinity         204
define syscall_set_thread_area           205
define syscall_io_setup                  206
define syscall_io_destroy                207
define syscall_io_getevents              208
define syscall_io_submit                 209
define syscall_io_cancel                 210
define syscall_get_thread_area           211
define syscall_lookup_dcookie            212
define syscall_epoll_create              213
define syscall_epoll_ctl_old             214
define syscall_epoll_wait_old            215
define syscall_remap_file_pages          216
define syscall_getdents64                217
define syscall_set_tid_address           218
define syscall_restart_syscall           219
define syscall_semtimedop                220
define syscall_fadvise64                 221
define syscall_timer_create              222
define syscall_timer_settime             223
define syscall_timer_gettime             224
define syscall_timer_getoverrun          225
define syscall_timer_delete              226
define syscall_clock_settime             227
define syscall_clock_gettime             228
define syscall_clock_getres              229
define syscall_clock_nanosleep           230
define syscall_exit_group                231
define syscall_epoll_wait                232
define syscall_epoll_ctl                 233
define syscall_tgkill                    234
define syscall_utimes                    235
define syscall_vserver                   236
define syscall_mbind                     237
define syscall_set_mempolicy             238
define syscall_get_mempolicy             239
define syscall_mq_open                   240
define syscall_mq_unlink                 241
define syscall_mq_timedsend              242
define syscall_mq_timedreceive           243
define syscall_mq_notify                 244
define syscall_mq_getsetattr             245
define syscall_kexec_load                246
define syscall_waitid                    247
define syscall_add_key                   248
define syscall_request_key               249
define syscall_keyctl                    250
define syscall_ioprio_set                251
define syscall_ioprio_get                252
define syscall_inotify_init              253
define syscall_inotify_add_watch         254
define syscall_inotify_rm_watch          255
define syscall_migrate_pages             256
define syscall_openat                    257
define syscall_mkdirat                   258
define syscall_mknodat                   259
define syscall_fchownat                  260
define syscall_futimesat                 261
define syscall_newfstatat                262
define syscall_unlinkat                  263
define syscall_renameat                  264
define syscall_linkat                    265
define syscall_symlinkat                 266
define syscall_readlinkat                267
define syscall_fchmodat                  268
define syscall_faccessat                 269
define syscall_pselect6                  270
define syscall_ppoll                     271
define syscall_unshare                   272
define syscall_set_robust_list           273
define syscall_get_robust_list           274
define syscall_splice                    275
define syscall_tee                       276
define syscall_sync_file_range           277
define syscall_vmsplice                  278
define syscall_move_pages                279
define syscall_utimensat                 280
define syscall_epoll_pwait               281
define syscall_signalfd                  282
define syscall_timerfd_create            283
define syscall_eventfd                   284
define syscall_fallocate                 285
define syscall_timerfd_settime           286
define syscall_timerfd_gettime           287
define syscall_accept4                   288
define syscall_signalfd4                 289
define syscall_eventfd2                  290
define syscall_epoll_create1             291
define syscall_dup3                      292
define syscall_pipe2                     293
define syscall_inotify_init1             294
define syscall_preadv                    295
define syscall_pwritev                   296
define syscall_rt_tgsigqueueinfo         297
define syscall_perf_event_open           298
define syscall_recvmmsg                  299
define syscall_fanotify_init             300
define syscall_fanotify_mark             301
define syscall_prlimit64                 302
define syscall_name_to_handle_at         303
define syscall_open_by_handle_at         304
define syscall_clock_adjtime             305
define syscall_syncfs                    306
define syscall_sendmmsg                  307
define syscall_setns                     308
define syscall_getcpu                    309
define syscall_process_vm_readv          310
define syscall_process_vm_writev         311
define syscall_kcmp                      312
define syscall_finit_module              313
#+end_src
* dynamic call
#+begin_src fasm
include 'import64.inc'

;; parameters order of call <fun>:
define fun_6_r9  r9
define fun_5_r8  r8
define fun_4_rcx rcx
define fun_3_rdx rdx
define fun_2_rsi rsi
define fun_1_rdi rdi

;; example:
;; interpreter '/lib64/ld-linux-x86-64.so.2'
;; needed 'libc.so.6'
;; import printf,exit
#+end_src
* three ascii chars used in assembly
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
define ascii.linefeed       000Ah;; 10
define ascii.esc            001Bh;; 27
define ascii.space          0020h;; 32
#+end_src
* format header and entry
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
format elf64 executable 3
entry EntryPoint
#+end_src
* registers & pop & push
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
define CellWidth 8 ;; (unit : byte)

;; if you want to extend xiaolinguist in assembly,
;; the following four registers must not be used
;; =================================
define NextWordPointer      r15
define ReturnStackPointer   r14
define ArgumtStackPointer   r13
define GreyPairStackPointer r12
;; =================================

define ExplainerPointer      rax
define TemporaryRegister    r11
define TemporaryRegister2   r10

;; ``ReturnStackPointer'' always stores the address of TOC (top-of-stack),
;; NOT the address of first-free-place in the stack
macro pushReturnStack Register {
   lea ReturnStackPointer, [ReturnStackPointer - CellWidth]  ;; 入栈时先向上(低地址)移动指针
   mov [ReturnStackPointer], Register                        ;; 再放入值
   }
macro popReturnStack Register {
   mov Register, [ReturnStackPointer]                        ;; 出栈时先取出值
   lea ReturnStackPointer, [ReturnStackPointer + CellWidth]  ;; 再向下(高地址)移动指针
   }

macro pushArgumtStack Register {
   lea ArgumtStackPointer, [ArgumtStackPointer - CellWidth]
   mov [ArgumtStackPointer], Register
   }
macro popArgumtStack Register {
   mov Register, [ArgumtStackPointer]
   lea ArgumtStackPointer, [ArgumtStackPointer + CellWidth]
   }
#+end_src
* --------------------------------------------------
* *the dictionary*
** note
1. 字典的编撰是很多的字典编撰者们(lexicographers)分工协作完成的
   一个字典的编撰者在编撰字典的时候
   会用一些words来描述(description)一个新的word
   并且给这个新的word指定一个诠释者(explainer)
   这样的描述过程和对诠释者的指定过程 就是定义一个新的word的过程
   而当一个查字典的人查到某一个word的时候
   这个word的诠释者会为查字典的人来诠释字典编撰者对这个word的描述
   正式这些描述构成了对这个word的定义
2. 下面的BNF说明了word这个数据结构的主要部分
   #+begin_src bnf
   <Word>
      ::= <Var> | <Const> | <Function>
   <Var>
      ::= VarExplainer, value
   <Const>
      ::= ConstExplainer, value
   <Function>
      ::= FunctionBodyExplainer, <FunctionBody>
   <FunctionBody>
      ::= list of words and literals
   #+end_src
3. 注意由于汇编语言(fasm)的语法的限制
   有某些word在汇编中的名字 和在forth中的名字不一致
   每一个名字不一致的地方
   都应该在这里被集中地进行警告
   有一下几种情况:
   1) for syntax sugar :
      defWord ":", readWordListForLexicographer
      defCode "x|swap|xx", xswapxx
      (还有其他跟swap有关的)
      defWord ".", printLittleNumber
   2) for already used label-name :
      defConst "ReturnStackTop", ReturnStackTop, TheReturnStackTop
      (还有其他需要暴露给forth系统的label值)
** word-types & explainers & next & execute
1. 每一个类型的word都需要一个诠释者
2. word是有类型的
   这在于有些word可以共用一个诠释者
   但是它们的语义却不同
   比如作为变量的word的诠释者
   和作为数组的word的诠释者可以相同
   但是这确实两种不同类型的word它们的字典编撰者可能不同
   处理它们的函数也可能不同
3. 所以这里我又要维护一个类型编码表
   加上动态类型的类型编码表
   这个forth中已经有两个这样的表了
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
;; notations :
;; 1. ``the dictionary'' as a datastructure is a single-linked-list
;; 2. an entry in ``the dictionary'' is ``a word''
;; 3. ``a word'' as a datastructure looks like the following :
;;       (unit : CellWidth)
;;    ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
;;    ||  m : name-string  ||
;;    ||  1 : SizeOfFunctionBody  ||
;;    ||  1 : identification  ||
;;    ||  1 : link  ||
;;    ||  1 : type  ||
;;    ||  1 : address-of-name-string-header  ||
;;    ||  1 : address-of-explainer  ||
;;    ||  n : body  ||
;; 4. so, I adopt two notations to represent ``a word'' :
;;    word[link]      == address in a word where the link is stored
;;    word[explainer] == address in a word where the address-of-explainer is stored
;;    word[explainer] == address in a word before the function-body
;;    word[explainer] == address in a word as the head of a function-body


;; note that:
;;   there are only two ways to jump to a explainer
;;   1. next
;;   2. execute


;; not matter what way you use to set :
;;   [ExplainerPointer] == address-of-explainer (of a word you want to jump to)
;; then :
;;   jmp qword[ExplainerPointer]
;; it will works just well !!!

;; specially, about ``next'',
;; the way we use to set :
;;   [ExplainerPointer] == address-of-explainer (of a word you want to jump to)
;; is to find the address-of-explainer by :
;;    NextWordPointer  == an address in a function-body
;;   [NextWordPointer] == word-to-jump[explainer]
;; so, NextWordPointer is all that ``next'' needed
;; set [NextWordPointer] == word-to-jump[explainer]  correctly
;; then call ``next''
;; it will works just well !!!


;; 1. this ``next'' do tail-call-optimization
;; 2. in the following FASM marco, anonymous label of FASM is used
;;    (of course, label in marco must be anonymous !)
;;    hence, when using anonymous labels in assembly,
;;    they can not across ``next'' !


macro next {
   ;== NEED:
   ;==     NextWordPointer  points at an address in a function-body
   ;==    [NextWordPointer] == word-to-jump[explainer]
   ;== CHNG:
   ;==     NextWordPointer  points at next address in a function-body
   ;==    [NextWordPointer] == new-word-to-jump[explainer]
   ;==     ExplainerPointer  points at the address in a word
   ;==                      where the address-of-explainer is stored
   ;==    [ExplainerPointer] == address-of-explainer (of word-to-jump)
   mov ExplainerPointer, [NextWordPointer]
   add NextWordPointer, CellWidth
   ;; why not: cmp qword[NextWordPointer], Exit  ???
   cmp dword[NextWordPointer], Exit
   ;-- IF: [NextWordPointer] =/= Exit
   jne @f
   ;-- EL: [NextWordPointer] == Exit
   popReturnStack NextWordPointer
@@:
   jmp qword[ExplainerPointer]
   }
   ;; maybe need more optimization,
   ;; for the above ``popReturnStack NextWordPointer'' may be
   ;; followed by ``pushReturnStack NextWordPointer'' (in explainFunctionBody)



;; initial Link to point to NULL
Link = 0


;; example of macro expanding :
;; defWord "double", double
;;    dq duplicate
;;    dq plus
;;    dq Exit
;; ==expand to==>
;; WordStringHeaderOfdouble:
;;         dq (EndOfdouble - WordStringOfdouble)
;; WordStringOfdouble:
;;         db "double"
;; EndOfWordStringOfdouble:
;; LinkOfdouble:
;;         dq Link
;;         Link = LinkOfdouble
;; TypeOfdouble:
;;         dq 0
;; AddressOfWordStringHeaderOfdouble:
;;         dq WordStringHeaderOfdouble
;; double:
;;         dq explainFunctionBody
;;         dq duplicate
;;         dq plus
;;         dq Exit


macro defWord WordString, Word {
segment readable writeable
;;--------------------------------------
WordStringHeaderOf#Word:
        dq (EndOfWordStringOf#Word - WordStringOf#Word)
;;--------------------------------------
WordStringOf#Word:
        db WordString
EndOfWordStringOf#Word:
;;--------------------------------------
SizeOfFunctionBodyOf#Word:
        dq (EndOfFunctionBodyOf#Word - Word)/8 - 1
;;--------------------------------------
IdentificationOf#Word:
        dq IdentificationOf#Word
;;--------------------------------------
LinkOf#Word:
        dq Link
        Link = LinkOf#Word
;;--------------------------------------
TypeOf#Word:
        dq 0
;;--------------------------------------
AddressOfWordStringHeaderOf#Word:
        dq WordStringHeaderOf#Word
;;======================================
Word:   dq explainFunctionBody
;;--------------------------------------
        ;; here follows a list of word[explainer]
        }
macro defWordEnd Word {
EndOfFunctionBodyOf#Word:
}
;; 注意 ><><><
;;      只有这些explainer才是能够直接被执行的代码
;;      直接用jmp转跳到explainFunctionBody就可以执行了
;;      而那些用defCode定义的汇编代码(比如 addition)不是直接转跳过去就能执行的
;;      因为addition这个地址下保存的是地址 而不是指令

;; 1. if ``next'' meet ``Exit'',
;;    ``next'' will ``popReturnStack NextWordPointer''
;; 2. on the other hand,
;;    explainFunctionBody is the only explainer
;;    who ``pushReturnStack NextWordPointer''
;; 3. so, it is these two functions, ``next'' and ``explainFunctionBody'',
;;    which handle the nested function calls
segment readable executable
explainFunctionBody:
   ;== SAVE:
   ;==     NextWordPointer  points at an old address in a function-body
   ;==    [NextWordPointer] == old-word-to-jump[explainer]
   ;== NEED:
   ;==    ExplainerPointer == current-word[explainer]
   ;==        this value can be used to calculate
   ;==        the address in a word where the function-body is stored
   ;== CHNG:
   ;==    [ExplainerPointer] == new-word-to-jump[explainer]
   ;==    [NextWordPointer] == new-word-to-jump[explainer]
   pushReturnStack NextWordPointer
   ;; to calculate the address in a word where the function-body is stored
   ;; this address is as an ``argmnt'' of explainFunctionBody
   add ExplainerPointer, CellWidth
   mov NextWordPointer, ExplainerPointer
   next



;; assembly code have no explainer
macro defCode WordString, Word {
segment readable writeable
;;--------------------------------------
WordStringHeaderOf#Word:
        dq (EndOfWordStringOf#Word - WordStringOf#Word)
;;--------------------------------------
WordStringOf#Word:
        db WordString
EndOfWordStringOf#Word:
;;--------------------------------------
IdentificationOf#Word:
        dq IdentificationOf#Word
;;--------------------------------------
LinkOf#Word:
        dq Link
        Link = LinkOf#Word
;;--------------------------------------
TypeOf#Word:
        dq 0
;;--------------------------------------
AddressOfWordStringHeaderOf#Word:
        dq WordStringHeaderOf#Word
;;======================================
Word:   dq AssemblerCodeOf#Word
;;--------------------------------------
segment readable executable
AssemblerCodeOf#Word:
        ;; here follows the assembly code
        }




defCode "execute", execute
  ;; ( word[address of explainer] -- )
  popArgumtStack ExplainerPointer
  jmp qword[ExplainerPointer]

;; not matter what way you use to set :
;;   [ExplainerPointer] == address-of-explainer (of a word you want to jump to)
;; then :
;;   jmp qword[ExplainerPointer]
;; it will works just well !!!



;; 对于在我理解上不是primitive-function的word统一使用explainer
;; 我并没有比较两者的效率 这样作单纯是为了追求理解上的一致性
macro defVar WordString, InitialValue, Word {
segment readable writeable
;;--------------------------------------
WordStringHeaderOf#Word:
        dq (EndOfWordStringOf#Word - WordStringOf#Word)
;;--------------------------------------
WordStringOf#Word:
        db WordString
EndOfWordStringOf#Word:
;;--------------------------------------
IdentificationOf#Word:
        dq IdentificationOf#Word
;;--------------------------------------
LinkOf#Word:
        dq Link
        Link = LinkOf#Word
;;--------------------------------------
TypeOf#Word:
        dq 0
;;--------------------------------------
AddressOfWordStringHeaderOf#Word:
        dq WordStringHeaderOf#Word
;;======================================
Word:   dq explainVar
;;--------------------------------------
        dq InitialValue
;;--------------------------------------
        }


segment readable executable
explainVar:
   ;; ( -- address )
   add ExplainerPointer, CellWidth
   pushArgumtStack ExplainerPointer
   next



macro defConst WordString, InitialValue, Word {
segment readable writeable
;;--------------------------------------
WordStringHeaderOf#Word:
        dq (EndOfWordStringOf#Word - WordStringOf#Word)
;;--------------------------------------
WordStringOf#Word:
        db WordString
EndOfWordStringOf#Word:
;;--------------------------------------
IdentificationOf#Word:
        dq IdentificationOf#Word
;;--------------------------------------
LinkOf#Word:
        dq Link
        Link = LinkOf#Word
;;--------------------------------------
TypeOf#Word:
        dq 0
;;--------------------------------------
AddressOfWordStringHeaderOf#Word:
        dq WordStringHeaderOf#Word
;;======================================
Word:   dq explainConst
;;--------------------------------------
        dq InitialValue
;;--------------------------------------
        }

segment readable executable
explainConst:
   ;; ( -- value )
   add ExplainerPointer, CellWidth
   mov TemporaryRegister, [ExplainerPointer]
   pushArgumtStack TemporaryRegister
   next




;; in stack:
;;   string[address, length]
;; in memory:
;;   ||  1 : length  ||
;;   ||  n : string  ||
macro defConstString WordString, ConstStringValue, Word {
segment readable writeable
;;--------------------------------------
WordStringHeaderOf#Word:
        dq (EndOfWordStringOf#Word - WordStringOf#Word)
;;--------------------------------------
WordStringOf#Word:
        db WordString
EndOfWordStringOf#Word:
;;--------------------------------------
IdentificationOf#Word:
        dq IdentificationOf#Word
;;--------------------------------------
LinkOf#Word:
        dq Link
        Link = LinkOf#Word
;;--------------------------------------
TypeOf#Word:
        dq 0
;;--------------------------------------
AddressOfWordStringHeaderOf#Word:
        dq WordStringHeaderOf#Word
;;======================================
Word:   dq explainConstString
;;--------------------------------------
        dq (EndOfConstStringValueOf#Word - ConstStringValueOf#Word)
;;--------------------------------------
ConstStringValueOf#Word:
        db ConstStringValue
EndOfConstStringValueOf#Word:
;;--------------------------------------
        }


segment readable executable
explainConstString:
   ;; ( -- string[address, length] )
   add ExplainerPointer, CellWidth
   mov TemporaryRegister, [ExplainerPointer]
   add ExplainerPointer, CellWidth
   pushArgumtStack ExplainerPointer
   pushArgumtStack TemporaryRegister
   next



;; 下面是尾递归优化版本的Exit
;; 在这个版本中 需要一个唯一的值来判断FunctionBody的结束点
;; 而下面定义Exit的方式就是使用Exit这个label所代表的地址值来作这个判断
;; 并且下面的定义方式同时做到了当executer来执行它的时候 它会把这个地址入栈
;; 但是其实如果你把Exit写到一个词的定义中 这个常量Word是永远不会被执行的
;; 因为变成名词了 所以首字母大写
defConst "Exit", Exit, Exit
;; (* so, the following numbers are the same :
;;   Exit
;;   readWord Exit find wordLinkToWordExplainer
;;   *)

defConst "FunctionBodyExplainer", explainFunctionBody, FunctionBodyExplainer
defConst "VarExplainer",          explainVar,          VarExplainer
defConst "ConstExplainer",        explainConst,        ConstExplainer
defConst "ConstStringExplainer",  explainConstString,  ConstStringExplainer
#+end_src
** Var
变元和常元模仿德语的名词 首字母大写
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
defVar "Base", 10, Base

defVar "Here",  0, Here

;; 在这里的汇编代码内想要初始化FirstWordInDictionary的值
;; 就必须在这篇代码的最后面加一个词
;; 以确保FirstWordInDictionary能保存
;; 最后一个被定义到Dictionary中的word
;; 每次最后一个被定义到Dictionary中的word 都被认为是Dictronary中的第一个word
defVar "FirstWordInDictionary", LinkOfTheLatestWordInThisFile , FirstWordInDictionary
;; 注意: 上面是LinkOfTheLatestWordInThisFile
;;       而不是TheLatestWordInThisFile
#+end_src
** Const
1. 把一些常量暴露给xiaolinguist系统
   在很多代码段和数据段的末尾
   已经暴露了一些和局部的代码或数据相关的常量给xiaolinguist了
   这里是一些一般的常量
2. 常元这种语义对象的引入
   方便了把某些特定数值入栈的过程
   虽然它们的使用方式与变元不同 但是它们的命名方式与变元相似
   所以有时从命名上不能直接看出一个名词代表的是常元还是变元
   所以也许我应该只使用变元而不使用常元
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
defConst "CellWidth", CellWidth, TheCellWidth

defConst "Zero",  0, Zero
defConst "One",   1, One
defConst "Two",   2, Two
defConst "Three", 3, Three
defConst "Four",  4, Four
defConst "Five",  5, Five
defConst "Six",   6, Six
defConst "Seven", 7, Seven
defConst "Eight", 8, Eight
defConst "Nine",  9, Nine
defConst "Ten",  10, Ten

defConst "False", 0, False
defConst "True",  1, True

;; 在十进制下把Base变为2之后
;; 想要变回来 就需要
;; 在二进制下把Base变为1010
;; test:
;; 2 Base save
;; 101 011 bitwiseAnd . (* 1 *)
;; 101 bitwiseInvert 011 bitwiseInvert bitwiseOr bitwiseInvert . (* 1 *)
;; 1010 Base save
;; 所以最好定义常数来保存常用的进位基底
;; 并且为了让这些定义完全与做定义的时候的进位基底无关
;; 就应该把这些常数定义在汇编中
defConst "BinBase", 2,  BinBase
defConst "OctBase", 8,  OctBase
defConst "DecBase", 10, DecBase
defConst "HexBase", 16, HexBase
defConst "AphBase", 36, AphBase
;; test:
;; BinBase Base save
;; 101 011 bitwiseAnd . (* 1 *)
;; 101 bitwiseInvert 011 bitwiseInvert bitwiseOr bitwiseInvert . (* 1 *)
;; DecBase Base save

;; 字典编撰者也是要看Base这个变量的
;; test:
;; BinBase Base save
;; 10 : kkk defineVar
;; DecBase Base save
;; kkk fetch . (* 2 *)
#+end_src
** primitive functions
*** note
1. 每次在实现一个forth系统的时候
   定义primitive functions的集合的过程
   其实就是挖掘机器的能力的过程
2. 尽管如此
   如果想用primitive functions的集合来捕捉复杂指令集的CPU的所有指令
   那么所需要的primitive functions也太多了
   所以最好内嵌一个汇编器
3. 尽管每个机器都有自己的forth系统
   但是还是有方法能够让你来确定那些东西是可移植的那些东西是不可移植的
4. 定义各种primitive
   因为常常不用考虑嵌套
   所以就不用考虑各个primitive之间的影响
5. 注意在下面定义的所有primitive中
   就forth系统的编程而言 本质重要的有:
   1) stack processing
      可以发现
      这里实现的基本的对栈出处理都可以被看作二元函数
      因为在forth中
      一些基本的数据结构通常是一个地址和一个描述量
      比如:
      string[address, length]
      wordList[address, number of words]
   2) fixnum
      保持无类型的对fixnum的处理
      而数据结构都在用户级别实现
   3) memory
      现在只有一块静态的定义了就不能收回的空间
      这是为了以此为基础写出一些基本的word来在forth中实现动态内存管理
*** stack processing
1. forth系统提供了一个有趣的结合代数
   任意有限阶置换群
   都又这个有趣的结合代数的子代数与其同构
   下面的某些栈处理函数就是某些低阶的有限置换群中的元素
2. 当函数的前面有two这种数字前缀的时候
   其行为就像是把函数map到了list上
3. 而数字后缀却像是函数的参数
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
defCode "drop", drop
   ;; ( a -- )
   popArgumtStack rax
   next

defCode "twoDrop", twoDrop
   ;; ( a b -- )
   ;; drop是在抛弃栈中的元素
   popArgumtStack rax
   popArgumtStack rax
   next



defCode "duplicate", duplicate
   ;; ( a -- a a )
   mov  rax, [ArgumtStackPointer]
   pushArgumtStack rax
   next

defCode "twoDuplicate", twoDuplicate
   ;; ( a b -- a b a b )
   mov  rbx, [ArgumtStackPointer]
   mov  rax, [ArgumtStackPointer + CellWidth]
   pushArgumtStack rax
   pushArgumtStack rbx
   next

defCode "nonZeroDuplicate", nonZeroDuplicate
   ;; if a =/= 0
   ;; ( a -- a a )
   ;; else
   ;; ( a -- a )
   mov  rax, [ArgumtStackPointer]
   test rax, rax
   jz nonZeroDuplicate_meetZero
   pushArgumtStack rax
nonZeroDuplicate_meetZero:
   next



defCode "over", over
   ;; ( a b -- a b  a )
   mov  rax, [ArgumtStackPointer + CellWidth]
   pushArgumtStack rax
   next

defCode "x|over|xx", xoverxx
   ;; ( a  b c -- a  b c  a )
   mov  rax, [ArgumtStackPointer + (2 * CellWidth)]
   pushArgumtStack rax
   next

defCode "xx|over|x", xxoverx
   ;; ( a b  c -- a b  c  a b )
   mov  rax, [ArgumtStackPointer + (2 * CellWidth)]
   pushArgumtStack rax
   mov  rax, [ArgumtStackPointer + (2 * CellWidth)] ;; not (1 * CellWidth)
   pushArgumtStack rax
   next

defCode "xx|over|xx", xxoverxx
   ;; ( a b  c d -- a b  c d  a b )
   mov  rax, [ArgumtStackPointer + (3 * CellWidth)]
   pushArgumtStack rax
   mov  rax, [ArgumtStackPointer + (3 * CellWidth)] ;; not (3 * CellWidth)
   pushArgumtStack rax
   next

defCode "x|over|xxx", xoverxxx
   ;; ( a  b c d -- a  b c d  a )
   mov  rax, [ArgumtStackPointer + (3 * CellWidth)]
   pushArgumtStack rax
   next



defCode "tuck", tuck
   ;; ( a b -- b  a b )
   popArgumtStack  rbx
   popArgumtStack  rax
   pushArgumtStack rbx
   pushArgumtStack rax
   pushArgumtStack rbx
   next

defCode "x|tuck|xx", xtuckxx
   ;; ( a  b c -- b c  a  b c )
   popArgumtStack  rcx
   popArgumtStack  rbx
   popArgumtStack  rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   pushArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   next

defCode "xx|tuck|x", xxtuckx
   ;; ( a b  c -- c  a b  c )
   popArgumtStack  rcx
   popArgumtStack  rbx
   popArgumtStack  rax
   pushArgumtStack rcx
   pushArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   next

defCode "xx|tuck|xx", xxtuckxx
   ;; ( a b  c d -- c d  a b  c d )
   popArgumtStack  rdx
   popArgumtStack  rcx
   popArgumtStack  rbx
   popArgumtStack  rax
   pushArgumtStack rcx
   pushArgumtStack rdx
   pushArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   pushArgumtStack rdx
   next



defCode "swap", swap
   ;; ( a b -- b a )
   popArgumtStack  rbx
   popArgumtStack  rax
   pushArgumtStack rbx
   pushArgumtStack rax
   next

defCode "x|swap|xx", xswapxx
   ;; ( a  b c -- b c  a )
   popArgumtStack  rcx
   popArgumtStack  rbx
   popArgumtStack  rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   pushArgumtStack rax
   next

defCode "xx|swap|x", xxswapx
   ;; ( a b  c -- c  a b )
   popArgumtStack  rcx
   popArgumtStack  rbx
   popArgumtStack  rax
   pushArgumtStack rcx
   pushArgumtStack rax
   pushArgumtStack rbx
   next

defCode "x|swap|xxx", xswapxxx
   ;; ( a  b c d -- b c d  a )
   popArgumtStack  rdx
   popArgumtStack  rcx
   popArgumtStack  rbx
   popArgumtStack  rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   pushArgumtStack rdx
   pushArgumtStack rax
   next

defCode "xx|swap|xx", xxswapxx
   ;; ( a b  c d -- c d  a b )
   popArgumtStack  rdx
   popArgumtStack  rcx
   popArgumtStack  rbx
   popArgumtStack  rax
   pushArgumtStack rcx
   pushArgumtStack rdx
   pushArgumtStack rax
   pushArgumtStack rbx
   next

defCode "xx|swap|xxxx", xxswapxxxx
   ;; ( a b  c d e f -- c d e f  a b )
   popArgumtStack  r9 ;; f
   popArgumtStack  r8 ;; e
   popArgumtStack  rdx
   popArgumtStack  rcx
   popArgumtStack  rbx
   popArgumtStack  rax
   pushArgumtStack rcx
   pushArgumtStack rdx
   pushArgumtStack r8 ;; e
   pushArgumtStack r9 ;; f
   pushArgumtStack rax
   pushArgumtStack rbx
   next

defCode "xxxx|swap|xx", xxxxswapxx
   ;; ( a b c d  e f --  e f  a b c d )
   popArgumtStack  r9 ;; f
   popArgumtStack  r8 ;; e
   popArgumtStack  rdx
   popArgumtStack  rcx
   popArgumtStack  rbx
   popArgumtStack  rax
   pushArgumtStack r8 ;; e
   pushArgumtStack r9 ;; f
   pushArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   pushArgumtStack rdx
   next


defCode "|123->321|", abcTOcba
   popArgumtStack rax
   popArgumtStack rbx
   popArgumtStack rcx
   pushArgumtStack rax
   pushArgumtStack rbx
   pushArgumtStack rcx
   next
#+end_src
*** fixnum
关于符号数的二进制补码编码:
1. 二进制补码对符号数的编码的特点是
   fixnum的运算方式不变 但是却能够巧妙地形成负数的语义
2. 注意: CPU只会做fixnum的运算
   可以把这种运算抽象地看作是bit patterns上的二元变换
   + 即不必在意这种变换是如何实现的
   符号数与超出fixnum限制的数的语义是通过旗子来完成的
3. 注意: CPU是会做fixnum的减法的
   我以前一直以为它不会
4. ``取反加一''是(任意一个)fixnum的集合上的方幂为零的变换(双射)
   即这个变换以自身为逆变换
   并且它是[fixnum, +]上面的同构变换
5. 而要知道[Nature number, +]上的同构变换只有乘法
   而上面的``取反加一''作为乘法就是乘以负一
6. 但是其实不是的
   因为[fixnum, +]并不是一个代数结构
   但是它已经很接近一个代数结构了
   只有当CUP的overflow旗子被举起来的时候
   这种近似才出现了错误
   + 而利用举起旗子所传达出来的信息我们可以探测到并且更正这种错误
   因此``取反加一''是类[Nature number, +]集合上的同构变换
   这个变换的语义是``乘以负一''
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
defCode "add1", add1
   ;; ( n -- n+1 )
   inc qword[ArgumtStackPointer]
   next

defCode "add2", add2
   ;; ( n -- n+1 )
   add qword[ArgumtStackPointer], 2
   next

defCode "add3", add3
   ;; ( n -- n+1 )
   add qword[ArgumtStackPointer], 3
   next

defCode "add4", add4
   ;; ( n -- n+4 )
   add qword[ArgumtStackPointer], 4
   next

defCode "add8", add8
   ;; ( n -- n+8 )
   add qword[ArgumtStackPointer], 8
   next


defCode "sub1", sub1
   ;; ( n -- n-1 )
   dec qword[ArgumtStackPointer]
   next

defCode "sub2", sub2
   ;; ( n -- n-1 )
   sub qword[ArgumtStackPointer], 2
   next

defCode "sub3", sub3
   ;; ( n -- n-1 )
   sub qword[ArgumtStackPointer], 3
   next

defCode "sub4", sub4
   ;; ( n -- n-4 )
   sub qword[ArgumtStackPointer], 4
   next

defCode "sub8", sub8
   ;; ( n -- n-8 )
   sub qword[ArgumtStackPointer], 8
   next


defCode "twoAdd1", twoAdd1
   ;; ( m, n -- m+1, n+1 )
   inc qword[ArgumtStackPointer]
   inc qword[ArgumtStackPointer + CellWidth]
   next


defCode "+", addition
   ;; ( a b -- a+b )
   popArgumtStack rax
   add qword[ArgumtStackPointer], rax
   next

defCode "-", subtraction
   ;; ( a b -- a-b )
   popArgumtStack rax
   sub qword[ArgumtStackPointer], rax
   next

defCode "*", multiple
   ;; ( a b -- a*b )
   popArgumtStack  rbx ;; 2ed arg
   popArgumtStack  rax ;; 1st arg
   imul rbx, rax
   ;; imul will ignore overflow
   ;; 当有两个参数时 imul将会把乘法的结果保存在第一个参数寄存器中
   pushArgumtStack rbx
   next

defCode "mod/", divmod
   ;; ( a, b -- a mod b, a/b )
   ;; ( dividend, divisor -- remainder, quotient )
   ;; the arg of idiv is divisor(除数)
   ;; the lower half of dividend(被除数) is taken from rax
   ;; the upper half of dividend(被除数) is taken from rdx
   ;; 下面清空rdx 也就是说这里并不使用被除数的高位部分
   xor  rdx, rdx
   popArgumtStack  rbx ;; 2ed arg
   popArgumtStack  rax ;; 1st arg
   idiv rbx
   ;; the remainder is stored in rdx
   ;; the quotient  is stored in rax
   pushArgumtStack rdx ;; remainder
   pushArgumtStack rax ;; quotient
   next
#+end_src
*** memory
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
;; ``save'' and ``fetch'' default to a CellWidth (== 8 bytes)
;; the rule of ``fetchTwo'' and so on are:
;;   in memory:
;;     ||  1 : value-1  ||
;;     ||  1 : value-2  ||
;;     ||  1 : value-3  ||
;;     ...
;;   on stack:
;;     [ ... , value-3, value-2, value-1]
;; of course we have:
;;   fetchTwo : memory=copy=>stack
;;   saveTwo  : stack->memory

defCode "save", save
   ;; ( value, address -- )
   popArgumtStack rbx
   popArgumtStack rax
   mov qword[rbx], rax
   next

defCode "saveTwo", saveTwo
   ;; ( value-2, value-1, address -- )
   popArgumtStack rbx
   popArgumtStack rax
   mov qword[rbx], rax
   popArgumtStack rax
   mov qword[rbx + CellWidth], rax
   next


defCode "fetch", fetch
   ;; ( address -- value )
   popArgumtStack  rbx
   mov rax, qword[rbx]
   pushArgumtStack rax
   next

defCode "twoFetch", twoFetch
   ;; ( address-1, address-2 -- value-1, value-2 )
   popArgumtStack  rbx
   popArgumtStack  rax
   mov TemporaryRegister2, qword[rbx]
   mov TemporaryRegister, qword[rax]
   pushArgumtStack TemporaryRegister
   pushArgumtStack TemporaryRegister2
   next

defCode "fetchTwo", fetchTwo
   ;; ( address -- value-1, value-2 )
   popArgumtStack  rbx
   mov rax, qword[rbx + CellWidth]
   pushArgumtStack rax
   mov rax, qword[rbx]
   pushArgumtStack rax
   next


defCode "addSave", addSave
   ;; ( number to add, address -- )
   popArgumtStack rbx
   popArgumtStack rax
   add qword[rbx], rax
   next

defCode "subSave", subSave
   ;; ( number to add, address -- )
   popArgumtStack rbx
   popArgumtStack rax
   sub qword[rbx], rax
   next



defCode "saveByte", saveByte
   ;; ( value, address -- )
   popArgumtStack rbx
   popArgumtStack rax
   mov byte[rbx], al
   next

defCode "fetchByte", fetchByte
   ;; ( address -- value )
   popArgumtStack rbx
   xor rax, rax
   mov al, byte[rbx]
   pushArgumtStack rax
   next

defCode "twoFetchByte", twoFetchByte
   ;; ( address-1, address-2 -- value-1, value-2 )
   popArgumtStack TemporaryRegister2
   popArgumtStack TemporaryRegister
   xor rbx, rbx
   mov bl, byte[TemporaryRegister2]
   xor rax, rax
   mov al, byte[TemporaryRegister]
   pushArgumtStack rax
   pushArgumtStack rbx
   next


defCode "copyByte", copyByte
   ;; ( source address, destination address --
   ;;   source address + 1, destination address + 1 )
   mov rbx, [ArgumtStackPointer + CellWidth] ;; source address
   mov al,  byte[rbx]                        ;; get a char from source address
   popArgumtStack rdi                        ;; destination address
   stosb                                     ;; copy to destination
   pushArgumtStack rdi                       ;; destination address is incremented by stosb
   inc qword[ArgumtStackPointer + CellWidth] ;; increment source address
   next

defCode "copyByteString", copyByteString
   ;; ( source address, destination address, length -- )
   popArgumtStack rcx 
   popArgumtStack rdi 
   popArgumtStack rsi 
   rep movsb          
   next
#+end_src
*** string
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
;; defWord "compareString?", compareString?
;;    ;; ( address of string-1, address of string-2, length -- True or False )
;;    dq duplicate, zero?branch, 17;-- GOTO: drop, drop, drop, True, Exit

;;    dq xxswapx
;;    dq twoDuplicate, twoFetchByte
;;    dq equal?, false?branch, 6;-- GOTO: drop, drop, drop, False
;;    dq twoAdd1, xswapxx, sub1, branch, -13;-- GOTO: the beginning
;;    dq drop, drop, drop, False
;;    dq Exit

;;    dq drop, drop, drop, True, Exit

;; 上面的forth版本 在length为0的时候会返回True
;; 下面的汇编版本 在length为0的时候会返回False
;; >< 那一种行为才是正确的呢 ???

;; compareString?和equalString?之间的区别可能让人疑惑
defCode "compareString?", compareString?
   ;; ( address of string-1, address of string-2, length -- True or False )
   popArgumtStack rcx
   popArgumtStack rdi
   popArgumtStack rsi
   repe cmpsb
   sete al
   movzx rax, al
   pushArgumtStack rax
   next

defWord "equalString?", equalString?
   ;; ( string-1[address-1, length-1], string-2[address-2, length-2]
   ;;   -- True or False )
   dq xoverxx, equal?, false?branch, 4
   dq swap, compareString?, Exit
   dq drop, drop, drop, False
   dq Exit
defWordEnd equalString?
#+end_src
*** predicates
作为低级语言直接操作fixnum
因而没有严格的bool类型量
所以
赋予0以False的语义
赋予1以True的语义
它们是下面的谓词的返回值
+ notFalse?并不等价于true?
  因为 在没有严格bool类型的条件下True和False只不过是两个数而已
+ 注意这里的谓词并不是严格的判断数据类型的谓词
  因为在这里 对数据类型的编码还没有被实现呢
  false?和true?其实是zero?和one?
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
defCode "==", equal?
   popArgumtStack rbx
   popArgumtStack rax
   cmp   rbx, rax
   sete  al
   movzx rax, al
   pushArgumtStack rax
   next

defCode "=/=", notEqual?
   popArgumtStack rbx
   popArgumtStack rax
   cmp   rbx, rax
   setne al
   movzx rax, al
   pushArgumtStack rax
   next

defCode "<", lessThan?
   popArgumtStack rbx
   popArgumtStack rax
   cmp   rax, rbx
   setl  al
   movzx rax, al
   pushArgumtStack rax
   next

defCode ">", greaterThan?
   popArgumtStack   rbx
   popArgumtStack   rax
   cmp   rax, rbx
   setg  al
   movzx rax, al
   pushArgumtStack  rax
   next

defCode "<=", lessOrEqual?
   popArgumtStack rbx
   popArgumtStack rax
   cmp   rax, rbx
   setle al
   movzx rax, al
   pushArgumtStack rax
   next

defCode ">=", greaterOrEqual?
   popArgumtStack rbx
   popArgumtStack rax
   cmp   rax, rbx
   setge al
   movzx rax, al
   pushArgumtStack rax
   next

defCode "zero?", zero?
   popArgumtStack rax
   test  rax,rax
   setz  al
   movzx rax, al
   pushArgumtStack rax
   next

defCode "notZero?", notZero?
   popArgumtStack rax
   test  rax,rax
   setnz al
   movzx rax, al
   pushArgumtStack rax
   next


defWord "one?", one?
   dq One, equal?
   dq Exit
defWordEnd one?

defWord "true?", true?
   dq one?
   dq Exit
defWordEnd true?

defWord "false?", false?
   dq zero?
   dq Exit
defWordEnd false?
#+end_src
*** bitwise operations
bitwiseAnd 与 bitwiseOr 都是具有交换性的二元运算
每次二元运算的两个参数中的任意一个都可以被看作是筛子
而另一个被看作是要被筛子筛的东西
1. bitwiseAnd
   被筛的东西是1
   筛子上的1会让1穿过 而0会把1挡住
2. bitwiseOr
   被筛的东西是0
   筛子上的0会让0穿过 而1会把0挡住
3. ``mask''技巧正是利用了上面这种有趣的语义
3. bitwiseInvert 是
   [BitwiseNumbers, bitwiseAnd] 与 [BitwiseNumbers, bitwiseOr]
   之间的同构映射
   x y bitwiseAnd
   ==
   x bitwiseInvert y bitwiseInvert bitwiseOr bitwiseInvert
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
defCode "bitwiseAnd", bitwiseAnd
   ;; ( a, b -- a and b )
   popArgumtStack rbx
   and [ArgumtStackPointer], rbx
   next

defCode "bitwiseOr", bitwiseOr
   ;; ( a, b -- a or b )
   popArgumtStack rbx
   or  [ArgumtStackPointer], rbx
   next

defCode "bitwiseXor", bitwiseXor
   ;; ( a, b -- a xor b )
   popArgumtStack rbx
   xor [ArgumtStackPointer], rbx
   next

defCode "bitwiseInvert", bitwiseInvert
   ;; ( a -- invert a )
   not qword[ArgumtStackPointer]
   next

;; test:
;; 注意:
;;   在十进制下把Base变为2之后
;;   想要变回来 就需要
;;   在二进制下把Base变为1010
;;   所以最好定义常数来保存常用的进位基底
;; 2 Base save
;; 101 011 bitwiseAnd . ( 1 )
;; 101 bitwiseInvert 011 bitwiseInvert bitwiseOr bitwiseInvert . ( 1 )
;; 1010 Base save
#+end_src
*** single bit operations
bitwiseAnd bitwiseOr 等等都是64 bits的
下面需要定义函数来方便对二进制数的逐bit的操作
注意 下面的函数 需要对参数 step 和 offset 进行异常处理
0 <= offset <= 63 (offset is of LSB)
1 <=  step  <= 64
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
;; BT copies a bit from a given register to the carry flag
defCode "fetchBit", fetchBit
   ;; ( fixnum, offset -- bit )
   popArgumtStack rbx
   popArgumtStack rax
   bt rax, rbx
   setc al
   movzx rax, al
   pushArgumtStack rax
   next

defCode "setBit", setBit
   ;; ( fixnum, offset -- fixnum )
   popArgumtStack rbx
   popArgumtStack rax
   bts rax, rbx
   pushArgumtStack rax
   next

defCode "clearBit", clearBit
   ;; ( fixnum, offset -- fixnum )
   popArgumtStack rbx
   popArgumtStack rax
   btr rax, rbx
   pushArgumtStack rax
   next

defCode "invertBit", invertBit
   ;; ( fixnum, offset -- fixnum )
   popArgumtStack rbx
   popArgumtStack rax
   btc rax, rbx
   pushArgumtStack rax
   next



;; "bsf" "bsr"
;; instructions scan a word or double word for first set bit
;; and store the index of this bit into destination operand
;; which must be general register
;; The bit string being scanned is specified by source operand
;; it may be either general register or memory
;; The ZF flag is set if the entire string is zero (no set bits are found)
;; otherwise it is cleared

;; If no set bit is found
;; the value of the destination register is undefined
;; "bsf" scans from low order to high order (starting from bit index zero)
;; "bsr" scans from high order to low order

;; 下面的函数 如果没找到 SetBit 就返回-1

defCode "findLowestSetBit", findLowestSetBit
   ;; ( fixnum -- offset )
   popArgumtStack rax
   bsf rax, rax
   jz tryToFindLowestSetBit_But_NoSetBitIsFound
   pushArgumtStack rax
   next
tryToFindLowestSetBit_But_NoSetBitIsFound:
   mov rax, -1
   pushArgumtStack rax
   next

defCode "findHighestSetBit", findHighestSetBit
   ;; ( fixnum -- offset )
   popArgumtStack rax
   bsr rax, rax
   jz tryToFindHighestSetBit_But_NoSetBitIsFound
   pushArgumtStack rax
   next
tryToFindHighestSetBit_But_NoSetBitIsFound:
   mov rax, -1
   pushArgumtStack rax
   next
#+end_src

test:
#+begin_src xiaolinguist
BinBase Base save
010
DecBase Base save
duplicate
  1 fetchBit . ( 1 )
duplicate
  2 fetchBit . ( 0 )
duplicate
  0 fetchBit . ( 0 )
drop


BinBase Base save
10
DecBase Base save
duplicate
  0 setBit . ( 3 )
duplicate
  1 setBit . ( 2 )
duplicate
  2 setBit . ( 6 )
drop


BinBase Base save
11
DecBase Base save
duplicate
  0 clearBit . ( 2 )
duplicate
  1 clearBit . ( 1 )
duplicate
  2 clearBit . ( 3 )
drop


BinBase Base save
101
DecBase Base save
duplicate
  0 invertBit . ( 4 )
duplicate
  1 invertBit . ( 7 )
duplicate
  2 invertBit . ( 1 )
drop


BinBase Base save
101
findLowestSetBit . ( 0 )
101
findHighestSetBit . ( 2 )
00101010
findLowestSetBit . ( 1 )
00101010
findHighestSetBit . ( 5 )
DecBase Base save


BinBase Base save
000000000
findHighestSetBit 111 + . ( 6 )
000000000
findLowestSetBit 111 + . ( 6 )
DecBase Base save
#+end_src
*** bits shift & rotate
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
;; "shl"
;; shifts the destination operand left
;; by the number of bits specified in the second operand
;; The destination operand can be general register or memory
;; The second operand can be an immediate value or the CL register
;; as bits exit from the left, zeros in from the right
;; The last bit that exited is stored in CF
;; "sal" is a synonym for "shl"
defCode "shiftLeft", shiftLeft
   ;; ( fixnum, step -- fixnum * 2^step )
   popArgumtStack rcx
   shl qword[ArgumtStackPointer], cl
   next

defCode "shiftRight", shiftRight
   ;; ( fixnum, step -- fixnum / 2^step )
   popArgumtStack rcx
   shr qword[ArgumtStackPointer], cl
   next

defCode "shiftRightPreserveSign", shiftRightPreserveSign
   ;; ( fixnum, step -- new fixnum )
   popArgumtStack rcx
   sar qword[ArgumtStackPointer], cl
   next



;; 注意 double了之后就是128 bit的二进制数了

;; "shld"
;; shifts bits of the destination operand to the left
;; by the number of bits specified in third operand,
;; while shifting
;; move high order bits from the source operand
;; into the destination operand on the right.
;; The source operand remains unmodified.
;; The destination operand can be a word or double word general register or memory,
;; the source operand must be a general register,
;; third operand can be an immediate value or the CL register.
defCode "doubleShiftLeft", doubleShiftLeft
   ;; ( fixnum-1, fixnum-2, step --
   ;;   new fixnum-1, new fixnum-2 )
   popArgumtStack rcx
   popArgumtStack rax
   shld qword[ArgumtStackPointer], rax, cl
   shl rax, cl
   pushArgumtStack rax
   next


;; "shrd"
;; shifts bits of the destination operand to the right,
;; while shifting
;; move low order bits from the source operand
;; into the destination operand on the left.
;; The source operand remains unmodified.
;; Rules for operands are the same as for the "shld" instruction.
defCode "doubleShiftRight", doubleShiftRight
   ;; ( fixnum-1, fixnum-2, step --
   ;;   new fixnum-1, new fixnum-2 )
   popArgumtStack rcx
   popArgumtStack rbx
   popArgumtStack rax
   shrd rbx, rax, cl
   shr rax, cl
   pushArgumtStack rax
   pushArgumtStack rbx
   next

defCode "doubleShiftRightPreserveSign", doubleShiftRightPreserveSign
   ;; ( fixnum-1, fixnum-2, step --
   ;;   new fixnum-1, new fixnum-2 )
   popArgumtStack rcx
   popArgumtStack rbx
   popArgumtStack rax
   shrd rbx, rax, cl
   sar rax, cl
   pushArgumtStack rax
   pushArgumtStack rbx
   next




defCode "rotateLeft", rotateLeft
   ;; ( fixnum, step -- new fixnum )
   popArgumtStack rcx
   rol qword[ArgumtStackPointer], cl
   next

defCode "rotateRight", rotateRight
   ;; ( fixnum, step -- new fixnum )
   popArgumtStack rcx
   ror qword[ArgumtStackPointer], cl
   next
#+end_src

test:
#+begin_src xiaolinguist
BinBase Base save
00100
1 shiftLeft . ( 8 )
00101
1 shiftRight . ( 2 )
00100
1 shiftRightPreserveSign . ( 2 )
-100
1 shiftRightPreserveSign 111 + . ( 5 )
-101
1 shiftRightPreserveSign 111 + . ( not 5 ) ( but 4 )
-111
1 shiftRightPreserveSign 111 + . ( not 4 ) ( but 3 )
-111
10 shiftRightPreserveSign 11 + . ( not 2 ) ( but 1 )
DecBase Base save



BinBase Base save
10 10
1 doubleShiftLeft . . ( 4 4 )
11 10
1 doubleShiftRight . . ( 1 1 )
11 10
1 doubleShiftRight
  HexBase Base save 8000000000000001 == . . ( 1 1 )
DecBase Base save


HexBase Base save
1 ffffffffffffffff
1 doubleShiftLeft ffffffffffffffff 1 - == . . ( 1 3 )
DecBase Base save


1 64 rotateRight . ( 1 )
1 64 rotateLeft . ( 1 )
1 64 2 * rotateLeft . ( 1 )
1 63 rotateRight . ( 2 )
1 65 rotateLeft . ( 2 )
#+end_src
*** about ReturnStack
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
;; defCode ">r", toReturnStackPointer
;;    ;; ( address -- )
;;    popArgumtStack  rax
;;    pushReturnStack rax
;;    next

;; defCode "r>", fromReturnStackPointer
;;    ;; ( -- address )
;;    popReturnStack  rax
;;    pushArgumtStack rax
;;    next

;; ><><>< what is the use of the above two words ???


defCode "fetchReturnStackPointer", fetchReturnStackPointer
   ;; ( -- an address in the ReturnStack )
   pushArgumtStack ReturnStackPointer
   next

defCode "resetReturnStackPointer", resetReturnStackPointer
   ;; ( an address in the ReturnStack -- )
   popArgumtStack ReturnStackPointer
   next

defCode "dropReturnStack", dropReturnStack
   ;; ( -- )
   add ReturnStackPointer, CellWidth
   next
#+end_src
*** about ArgmntStack
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
;; to know why the following funny thing happens,
;; see the definition of the macro ``pushArgumtStack'',
defCode "makeSelfReferenceValue", makeSelfReferenceValue
   ;; ( -- address )
   pushArgumtStack ArgumtStackPointer
   next

defWord "fetchArgumtStackPointer", fetchArgumtStackPointer
   dq makeSelfReferenceValue, add8, Exit
defWordEnd fetchArgumtStackPointer

defCode "resetArgumtStackPointer", resetArgumtStackPointer
   ;; ( address -- )
   popArgumtStack ArgumtStackPointer
   next
#+end_src
*** about GreyPairStack
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
defCode "fetchGreyPairStackPointer", fetchGreyPairStackPointer
   ;; ( -- address )
   pushArgumtStack GreyPairStackPointer
   next

defCode "resetGreyPairStackPointer", resetGreyPairStackPointer
   ;; ( address -- )
   popArgumtStack GreyPairStackPointer
   next


defCode "pushGreyPairStack", pushGreyPairStack
   ;; ( pair[address] -- )
   ;; ( top of ArgumtStack --> top of GreyPairStack )
   popArgumtStack rax
   lea GreyPairStackPointer, [GreyPairStackPointer - CellWidth]
   mov [GreyPairStackPointer], rax
   next

defCode "popGreyPairStack", popGreyPairStack
   ;; ( -- pair[address] )
   ;; ( top of GreyPairStack --> top of ArgumtStack )
   mov rax, [GreyPairStackPointer]
   lea GreyPairStackPointer, [GreyPairStackPointer + CellWidth]
   pushArgumtStack rax
   next

defCode "emptyGreyPairStack?", emptyGreyPairStack?
   ;; ( -- True or False )
   mov rax, GreyPairStackTop
   cmp GreyPairStackPointer, rax
   ;; 注意栈的实现方式
   ;; GreyPairStackPointer >= GreyPairStackTop 代表栈的溢出
   setge al
   movzx rax, al
   pushArgumtStack rax
   next

;; test:
;; emptyGreyPairStack? . ( 1 )
;; 6 pushGreyPairStack emptyGreyPairStack? . ( 0 )
;; popGreyPairStack . ( 6 )
;; emptyGreyPairStack? . ( 1 )
#+end_src
*** WordList
readWordListForLexicographer will return a WordList
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
defCode "tailOfWordList", tailOfWordList
   ;; ( wordList[address, the number of words] -- wordList[new address, number - 1] )
   popArgumtStack rcx
   popArgumtStack rsi
   lodsq
   add rsi, rax
   pushArgumtStack rsi
   dec rcx
   pushArgumtStack rcx
   next

defCode "headOfWordList", headOfWordList
   ;; ( wordList[address, the number of words] -- wordString[address, length] )
   popArgumtStack rbx ;; do not need this arg
   popArgumtStack rsi
   mov rcx, qword[rsi]
   add rsi, CellWidth
   pushArgumtStack rsi
   pushArgumtStack rcx
   next

defWord "tailAndHeadOfWordList", tailAndHeadOfWordList
   ;; ( wordList[address, the number of words] --
   ;;   wordList[new address, number - 1], wordString[address, length] )
   dq twoDuplicate
   dq tailOfWordList
   dq xxswapxx
   dq headOfWordList
   dq Exit
defWordEnd tailAndHeadOfWordList
#+end_src
*** linux syscall
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
defCode "syscallWithZoreArgument", syscallWithZoreArgument
   ;; (* callNumber -- return value *)
   popArgumtStack sys_n_rax
   syscall
   pushArgumtStack rax
   next

defCode "syscallWithOneArgument", syscallWithOneArgument
   ;; (* callNumber, arg-1 -- return value *)
   popArgumtStack sys_1_rdi
   popArgumtStack sys_n_rax
   syscall
   pushArgumtStack rax
   next

defCode "syscallWithTwoArguments", syscallWithTwoArguments
   ;; (* callNumber, arg-1, arg-2 -- return value *)
   popArgumtStack sys_2_rsi
   popArgumtStack sys_1_rdi
   popArgumtStack sys_n_rax
   syscall
   pushArgumtStack rax
   next

defCode "syscallWithThreeArguments", syscallWithThreeArguments
   ;; (* callNumber, arg-1, arg-2, arg-3 -- return value *)
   popArgumtStack sys_3_rdx
   popArgumtStack sys_2_rsi
   popArgumtStack sys_1_rdi
   popArgumtStack sys_n_rax
   syscall
   pushArgumtStack rax
   next
#+end_src
** special key words
special key words are not functions
but all about defineFunction is to use old functions to make new function
so, more appropriately,
when using ``literal'' or ``branch''
we are making new functions,
in a way, which is different from function-composition.
hence :
1. ``literal'' is a set of function,
   ``literal 666'' is a function in this set.
   or ``literal'' is a function
   which takes ``666'' as an argumt, and returns a function.
2. ``branch'' by itself has no function-semantic.
3. it is obvious that,
   how ``== false?branch 6 ... ...'' is a means
   to make new function out of old functions.
4. note that to achieve the function-semantic,
   we have to constrain ourself when using these special key words,
   for example, ``infinite-loop'' built by ``branch''
   is definitely has no function-semantic.
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
defCode "literal", literal
   mov  rax, [NextWordPointer]
   add  NextWordPointer, CellWidth
   pushArgumtStack rax

   ;; why not: cmp qword[NextWordPointer], Exit  ???
   cmp dword[NextWordPointer], Exit
   ;-- IF: [NextWordPointer] =/= Exit
   jne @f
   ;-- EL: [NextWordPointer] == Exit
   popReturnStack NextWordPointer
@@:

   next


defCode "branch", branch
   ;; usage(in assembly): dq branch, number
   ;; the number denotes an offset
   ;; the base point of the offset is the place where the number stored
   ;; note that: in the function branch, [NextWordPointer] = offset
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister

   ;; why not: cmp qword[NextWordPointer], Exit  ???
   cmp dword[NextWordPointer], Exit
   ;-- IF: [NextWordPointer] =/= Exit
   jne @f
   ;-- EL: [NextWordPointer] == Exit
   popReturnStack NextWordPointer
@@:

   next


defCode "zero?branch", zero?branch
   ;; ( n -- )
   popArgumtStack rax
   test rax, rax
   jnz zero?branch_toBranch
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp zero?branch_help_toBranch
zero?branch_toBranch:
   add NextWordPointer, CellWidth
zero?branch_help_toBranch:

   ;; why not: cmp qword[NextWordPointer], Exit  ???
   cmp dword[NextWordPointer], Exit
   ;-- IF: [NextWordPointer] =/= Exit
   jne @f
   ;-- EL: [NextWordPointer] == Exit
   popReturnStack NextWordPointer
@@:

   next

defCode "false?branch", false?branch
   ;; ( n -- )
   ;; false?branch is identical to zero?branch
   ;; but we can not use defWord to define false?branch by false?branch
   ;; for it is a special key word
   popArgumtStack rax
   test rax, rax
   jnz false?branch_toBranch
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp false?branch_help_toBranch
false?branch_toBranch:
   add NextWordPointer, CellWidth
false?branch_help_toBranch:

   ;; why not: cmp qword[NextWordPointer], Exit  ???
   cmp dword[NextWordPointer], Exit
   ;-- IF: [NextWordPointer] =/= Exit
   jne @f
   ;-- EL: [NextWordPointer] == Exit
   popReturnStack NextWordPointer
@@:

   next

defCode "notFalse?branch", notFalse?branch
   ;; ( n -- )
   popArgumtStack rax
   test rax, rax
   jz notFalse?branch_toBranch
   mov  TemporaryRegister, [NextWordPointer]
   imul TemporaryRegister, CellWidth
   add  NextWordPointer, TemporaryRegister
   jmp notFalse?branch_help_toBranch
notFalse?branch_toBranch:
   add NextWordPointer, CellWidth
notFalse?branch_help_toBranch:

   ;; why not: cmp qword[NextWordPointer], Exit  ???
   cmp dword[NextWordPointer], Exit
   ;-- IF: [NextWordPointer] =/= Exit
   jne @f
   ;-- EL: [NextWordPointer] == Exit
   popReturnStack NextWordPointer
@@:

   next
#+end_src
* --------------------------------------------------
* EntryPoint
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
segment readable executable
EntryPoint:
        cld ;; set DF = 0, then rsi and rdi are incremented
        mov ReturnStackPointer,   ReturnStackTop
        mov ArgumtStackPointer,   ArgumtStackTop
        mov GreyPairStackPointer, GreyPairStackTop
        ;; initialise the variable Here to point at beginning of DataSegment
        mov TemporaryRegister, UserDataSegment
        mov [Here + CellWidth], TemporaryRegister
        mov NextWordPointer, LittleTest
        next

segment readable writeable
LittleTest:
        dq basicREPL
;;        dq assemblyDebug
#+end_src
* IO
** note
1. the words about IO are all very special
   they often have ``read'' or ``write'' as prefix
** implementation
*** basic IO : writeChar & readChar
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
segment readable writeable
ScratchUsedByWriteChar:
   rb 1

defCode "writeChar", writeChar
   ;; ( char --  ) write a char to stdin
   ;; just calls the Linux write system call
   popArgumtStack rax
   call writeChar_helperFunction
   next
writeChar_helperFunction:
   mov sys_1_rdi, 1 ;; stdout
   ;; write can not just write the char in al to stdout
   ;; write needs the address of the byte to write
   mov [ScratchUsedByWriteChar], al
   mov sys_2_rsi, ScratchUsedByWriteChar  ;; address
   mov sys_3_rdx, 1                       ;; max length to be write, just 1
   mov sys_n_rax, syscall_write
   syscall
   ret


;; Buffer for Linux syscall read
InputBufferSize = 10 * 1024 * 1024 ; bytes
segment readable writeable
InputBuffer:
   rb InputBufferSize

;; two local variables for readChar
segment readable writeable
readChar_CurrentChar:
   dq InputBuffer
readChar_TopOfBuffer:
   dq InputBuffer

defCode "readChar", readChar
   ;; read a char from stdin, return it into the ArgumtStack as following
   ;; (  -- char )
   ;; readChar calls the Linux read system call to fill InputBuffer
   ;; The other thing that readChar does is
   ;; if it detects that stdin has closed, it exits the program
   ;; which is why when you hit C-d, the FORTH system cleanly exits
   call readChar_helperFunction
   ;; .helperFunction will save the return value in rax
   pushArgumtStack rax
   next
readChar_helperFunction:
   ;; [readChar_CurrentChar] is a variable which contains a address in InputBuffer
   ;; TemporaryRegister is a helper-register for [readChar_CurrentChar]
   mov TemporaryRegister, [readChar_CurrentChar]
   cmp TemporaryRegister, [readChar_TopOfBuffer]
   ;-- IF: [readChar_CurrentChar] >= [readChar_TopOfBuffer]
   ;-- WK: all chars in InputBuffer has been processed
   ;-- DO: syscall read to fetch more input from stdin
   jge readChar_fetchMoreCharsFromStdinToInputBuffer
   ;-- EL: [readChar_CurrentChar] < [readChar_TopOfBuffer]
   ;-- WK: there is still some chars in the InputBuffer to be processed
   ;; for the following will just uses the al part of rax
   ;; it is necessary to clear rax
   xor rax, rax
   ;-- DO: fetch a char from InputBuffer to rax
   ;-- NT: after .helperFunction return rax will be pushArgumtStack
   mov al, byte[TemporaryRegister]
   ;-- DO: increment [readChar_CurrentChar]
   inc TemporaryRegister
   mov [readChar_CurrentChar], TemporaryRegister
   ret

readChar_fetchMoreCharsFromStdinToInputBuffer:
   ;; reset [readChar_CurrentChar] and [readChar_TopOfBuffer]
   ;; and syscall read to fetch more input chars from stdin to InputBuffer
   xor sys_1_rdi,     sys_1_rdi        ;; stdin
   mov sys_2_rsi,     InputBuffer      ;; buffer address
   mov [readChar_CurrentChar], sys_2_rsi        ;; reset [readChar_CurrentChar]
   mov sys_3_rdx,     InputBufferSize  ;; max length to be read
   mov sys_n_rax,     syscall_read
   syscall

   ;; the return value of syscall read
   ;; is a count of the number of bytes transferred
   test rax, rax
   ;-- IF: rax <= 0
   ;-- WK: there is an error or it is end of input
   ;-- DO: exit
   jz readChar_exit
   js readChar_exit
   ;-- EL: rax > 0
   ;-- WK: there are some chars has been fetched by syscall read
   ;-- DO: set [readChar_TopOfBuffer] to the right place
   ;--     readChar_TopOfBuffer = InputBuffer + the count of the number of bytes transferred
   ;-- NT: sys_2_rsi = InputBuffer
   ;--     rax = the count of the number of bytes transferred
   add sys_2_rsi, rax
   mov [readChar_TopOfBuffer], sys_2_rsi
   ;-- DO: jump back
   jmp readChar_helperFunction

readChar_exit:
   ;; exit with exit code = 0
   xor sys_1_rdi, sys_1_rdi
   mov sys_n_rax, syscall_exit
   syscall


#+end_src
*** readFirstNonBlankChar & readNonBlankChar
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
defWord "readFirstNonBlankChar", readFirstNonBlankChar
   ;; (* -- FirstNonBlankChar *)
   dq readChar, duplicate
   dq literal, 32 ;; ascii.space
   dq greaterThan?, false?branch, 2
   dq   Exit
   dq drop
   dq branch, -10
defWordEnd readFirstNonBlankChar

defWord "readNonBlankChar", readNonBlankChar
   ;; (* -- FirstNonBlankChar or Zero *)
   dq readChar, duplicate
   dq literal, 32 ;; ascii.space
   dq greaterThan?, false?branch, 2
   dq   Exit
   dq drop
   dq Zero
   dq Exit
defWordEnd readNonBlankChar
#+end_src
*** readWord
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
define MaxWordLength 1024


segment readable writeable
BufferForReadWord:
   ;; note that, Subsequent calls will overwrite BufferForReadWord
   ;; this is why there is another function ``readWordForRuntime''
   rb MaxWordLength

defWord "readWord", readWord
   ;; (*  -- wordString[address, length] *)
   ;; 1. skips any blanks (spaces, tabs, newlines)
   ;; 2. calls readChar to read characters into BufferForReadWord
   ;;    until it hits a blank
   ;; 3. returns the address of BufferForReadWord and length on the stack

   dq literal, BufferForReadWord ;; (* leave return one of the values *)
   dq Zero                       ;; (* leave length counter *)

   dq literal, BufferForReadWord
   dq readFirstNonBlankChar
   dq over, saveByte, add1
   dq swap, add1, swap

   dq readNonBlankChar, duplicate, zero?branch, 9
   dq   over, saveByte, add1
   dq   swap, add1, swap
   dq   branch, -11

   dq twoDrop
   dq Exit
defWordEnd readWord


segment readable writeable
BufferForReadWordForRuntime:
   rb MaxWordLength

defWord "readWordForRuntime", readWordForRuntime
   ;; (*  -- wordString[address, length] *)
   ;; 1. skips any blanks (spaces, tabs, newlines)
   ;; 2. calls readChar to read characters into BufferForReadWord
   ;;    until it hits a blank
   ;; 3. returns the address of BufferForReadWord and length on the stack

   dq literal, BufferForReadWordForRuntime ;; (* leave return one of the values *)
   dq Zero                                 ;; (* leave length counter *)

   dq literal, BufferForReadWordForRuntime
   dq readFirstNonBlankChar
   dq over, saveByte, add1
   dq swap, add1, swap

   dq readNonBlankChar, duplicate, zero?branch, 9
   dq   over, saveByte, add1
   dq   swap, add1, swap
   dq   branch, -11

   dq twoDrop
   dq Exit
defWordEnd readWordForRuntime
#+end_src
*** readStringInToBuffer
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
define MaxStringLength 1024*1024

segment readable writeable
BufferForReadStringInToBuffer:
   ;; note that, Subsequent calls will overwrite BufferForReadStringInToBuffer
   rb MaxStringLength

defWord "readStringInToBuffer", readStringInToBuffer
   ;; (*  -- string[address of BufferForReadStringInToBuffer, length] *)
   dq literal, BufferForReadStringInToBuffer ;; (* leave return one of the values *)
   dq Zero                         ;; (* leave length counter *)

   dq literal, BufferForReadStringInToBuffer

   dq readChar, duplicate
   dq literal, 34 ;; ascii.doublequote
   dq equal?, notFalse?branch, 9
   dq   over, saveByte, add1
   dq   swap, add1, swap
   dq   branch, -14

   dq twoDrop
   dq Exit
defWordEnd readStringInToBuffer
#+end_src
*** number
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
;; The function uses the variable BASE as the radix
;; If the word starts with a '-' character then the returned value is negative

;; If the string can't be parsed as a number
;; or contains characters outside the current BASE
;; then we need to return an error indication.
;; So we let NUMBER returns two items on the stack.

defCode "number", number
   ;; ( wordString[address, length] --
   ;;   parsed number, length of unparsed string )
   popArgumtStack  rcx        ;; length  of string
   popArgumtStack  rdi        ;; address of string
   call number_helperFunction
   pushArgumtStack rax        ;; parsed number
   pushArgumtStack rcx        ;; length of unparsed string (0 = no error)
   next

number_helperFunction:
   xor  rax, rax
   xor  rbx, rbx

   test rcx, rcx
   ;-- IF: rcx == 0
   ;-- WK: trying to parse a zero-length string, it is an error
   ;-- DO: but will return 0
   jz number_return
   ;-- EL: rcx =/= 0
   ;-- WK: we have a non-empty string to be parsed
   ;-- DO: parse this non-empty string
   ;; copy the the variable Base into dl (rdx)
   ;; the following shows how to use a forth-variable-word in assembler code
   mov rdx, [Base + CellWidth]
   ;; fetch a char
   mov bl,  byte[rdi]
   inc rdi
   ;; sign-indicater
   ;; top of ArgumtStack == 0,  indicating positive
   ;; top of ArgumtStack =/= 0, indicating negative
   ;; initialise sign-indicater
   pushArgumtStack rax     ;; top of ArgumtStack == 0, indicating positive
   cmp bl, '-'
   ;-- IF: bl =/= '-'
   ;-- WK: maybe positive number, maybe error
   ;-- DO: try to convert the number
   jnz number_convert
   ;-- EL: bl == '-'
   ;-- DO: reset sign-indicater
   ;--     update the counter
   ;--     go into a loop to read all the chars
   popArgumtStack  rax
   pushArgumtStack rbx     ;; top of ArgumtStack =/= 0, indicating negative
   dec rcx                 ;; update the counter
   jnz number_fetchNextDigits
   popArgumtStack  rbx     ;; error: string is only '-'.
   mov rcx, 1
   ret

number_update_the_counter_and_fetchNextDigits:
   dec rcx
number_fetchNextDigits:
   mov bl,  byte[rdi]     ;; bl = next character in string
   inc rdi

number_convert:
   cmp bl, '_'
   je number_update_the_counter_and_fetchNextDigits

   ;; from low to high along the ascii
   sub bl, '0'
   ;-- IF: char < '0'
   jb number_endThisParse
   cmp bl, 10
   ;-- IF: '0' <= char <= '9'
   jb number_tryToAddDigitUp

   ;-- EL: '9' < char
   sub bl, ('A' - '0')
   ;-- IF: '9'< char < 'A'
   jb number_endThisParse
   cmp bl, 26
   ;-- NOTE-THAT: if bl == 0, char == 'A'
   ;-- IF: 'Z' < char
   jge @f
   ;-- EL: 'A' <= char <= 'Z'
   add bl, 10 ;; for 'A' =Hex= 10
   jb number_tryToAddDigitUp

@@:;-- IF: 'Z' < char
   sub bl, ('a' - 'A')
   ;-- IF: 'Z' < char < 'a'
   jb number_endThisParse
   cmp bl, 26
   ;-- NOTE-THAT: if bl == 0, char == 'a'
   ;-- IF: 'z' < char
   jge number_endThisParse
   ;-- EL: 'a' <= char <= 'a'
   add bl, 10 ;; for 'a' =Hex= 10
   ;; jb number_tryToAddDigitUp


number_tryToAddDigitUp:
   cmp bl, dl
   ;-- IF: bl >= dl
   ;-- WK: this digit >= Base
   jge number_endThisParse
   ;-- EL: bl < dl
   ;-- WK: this is a good digit
   ;-- DO: so add it to rax and loop
   imul rax, rdx   ;; (set! rax (* Base rax))
   add  rax, rbx
   dec  rcx
   jnz  number_fetchNextDigits

number_endThisParse:
;; negate the result according to the sign-indicater on the top of ArgumtStack
   popArgumtStack rbx
   test rbx, rbx
   jz   number_return
   neg  rax
number_return:
   ret


;; the following kinds of strings denote number,
;; because the function ``number'' can handle them.
;; 1. string with '0' - '9' as first char
;; 2. string with '-' as first char and with '0' - '9' as second char
;; so "-->", "_0" do not denote number.
;; under HexBase,
;; "feed" does not denote number, but "0feed", "0_feed" denote number

defCode "stringDenoteNumber?", stringDenoteNumber?
   ;; ( wordString[address, length] -- true or false )
   popArgumtStack  rcx        ;; length  of string
   popArgumtStack  rdi        ;; address of string
   call stringDenoteNumber?_helperFunction
   pushArgumtStack rax        ;; true or false
   next

stringDenoteNumber?_helperFunction:
   xor rbx, rbx

   test rcx, rcx
   ;-- IF: rcx == 0
   ;-- WK: trying to parse a zero-length string, it is an error
   jz stringDenoteNumber?_returnFalse
   ;-- EL: rcx =/= 0
   ;-- WK: we have a non-empty string to be parsed
   mov bl,  byte[rdi]
   cmp bl, '-'
   ;-- IF: bl =/= '-'
   ;-- WK: maybe positive number, maybe error
   jnz @f
   ;-- EL: bl == '-'
   inc rdi
   dec rcx                 ;; update the counter
   test rcx, rcx
   ;-- IF: rcx == 0
   ;-- WK: string is only '-'
   jz stringDenoteNumber?_returnFalse
   ;; fetch next digit
   mov  bl,  byte[rdi]
   inc  rdi

@@:
   sub bl, '0'
   ;-- IF: char < '0'
   jb stringDenoteNumber?_returnFalse
   cmp bl, 10
   ;-- IF: '0' <= char <= '9'
   jb stringDenoteNumber?_returnTrue
   ;-- EL: returnFalse

stringDenoteNumber?_returnFalse:
   xor rax, rax
   ret

stringDenoteNumber?_returnTrue:
   xor rax, rax
   mov rax, qword 1
   ret
#+end_src
*** comment
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
defConstString "CommentBeginWordString",  "(*", CommentBeginWordString
defConstString "CommentEndingWordString", "*)", CommentEndingWordString

defWord "ignoreComment", ignoreComment
   ;; (* -- *)
   ;; (* ignore a list of comment words from stdin *)
   dq readWord
   dq CommentEndingWordString, equalString?, false?branch, -4
   dq Two, drop, Exit
defWordEnd ignoreComment


;; 在repl中和在define中对comment的处理方式是不一样的
defWord "(*", comment
   dq ignoreComment
   dq Exit
defWordEnd comment
#+end_src
*** readWordListForLexicographer
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
;; a WordList (unit : CellWidth = 8 bytes)
;;   ||  1 : length-of-Word-1     ||
;;   ||  a : Word-1--as-a-string  ||
;;   ||  1 : length-of-Word-2     ||
;;   ||  b : Word-2--as-a-string  ||
;;   ...

;; note that:
;;    Subsequent calls will overwrite BufferForReadWordListForLexicographer
segment readable writeable
BufferForReadWordListForLexicographer:
   rb 1024*1024

defConstString "EndingWordForReadWordListForLexicographer", ";", EndingWordForReadWordListForLexicographer

defVar "NextWordForReadWordListForLexicographer", BufferForReadWordListForLexicographer, NextWordForReadWordListForLexicographer

defWord ":", readWordListForLexicographer
   ;; (* read a WordList from stdin (ForLexicographer) *)
   ;; (* -- wordList[address, the number of words] *)

   ;; (* 初始化NextWordForReadWordListForLexicographer *)
   dq literal, BufferForReadWordListForLexicographer
   dq NextWordForReadWordListForLexicographer
   dq save

   ;; (* 准备好返回值: [buffer-address, counter] *)
   dq literal, BufferForReadWordListForLexicographer
   dq Zero

   dq readWord

   dq twoDuplicate
   dq CommentBeginWordString, equalString?, false?branch, 5
   dq twoDrop, ignoreComment, branch, -9

   dq twoDuplicate
   dq EndingWordForReadWordListForLexicographer, equalString?, false?branch, 3
   dq twoDrop
   dq Exit

   ;; (* 当字符串不相等的时候: 添加一个word到列表中, 计数器加1 *)
   dq addWordToListForLexicographer
   dq add1
   dq branch, -20
defWordEnd readWordListForLexicographer


;; 以下面的方式来实现这个函数就不具有一般性
;; 还好下面的函数并没有在别的地方被调用过
;; 一个具有一般性的addWordToList应该有两个参数
;; ( wordString[address, length], wordList[address, number of words] -- )
;; 但是也许这样写也没有错
;; 因为我需要一个极小的核心系统来实现self-hosting
defWord "addWordToListForLexicographer", addWordToListForLexicographer
   ;; ( wordString[address, length] -- )
   ;; leave a length behind, for update NextWordForReadWordListForLexicographer at the end
   dq duplicate, xxswapx
   ;;   ||  1 : length-of-Word-1     ||
   dq duplicate, NextWordForReadWordListForLexicographer, fetch, save
   ;; update NextWordForReadWordListForLexicographer
   dq NextWordForReadWordListForLexicographer, fetch, add8, NextWordForReadWordListForLexicographer, save
   ;;   ||  a : Word-1--as-a-string  ||
   dq NextWordForReadWordListForLexicographer, fetch, swap, copyByteString
   ;; update NextWordForReadWordListForLexicographer again
   dq NextWordForReadWordListForLexicographer, addSave
   dq Exit
defWordEnd addWordToListForLexicographer
#+end_src
* dictionary look up
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
;; recall
;; a word in the dictionary (unit : CellWidth = 8 bytes)
;; ==
;;   ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
;;   ||  m : name-string  ||
;;   ||  1 : link  ||
;;   ||  1 : type  ||
;;   ||  1 : address-of-name-string-header  ||
;;   ||  1 : address-of-explainer  ||
;;   ||  n : body  ||
;; where
;;   ||  1 : type  ||
;; ==
;;   | type-bit-63 | ... | type-bit-1 | type-bit-0 |
;; type-bit-0 is for HiddenWord
define WordType_HiddenMask 00000001h


defCode "find", find
   ;; (* wordString[address, length] -- word[address of link] or Zero *)
   ;; find doesn't find dictionary entries which are flagged as hidden
   popArgumtStack  rcx     ;; length
   popArgumtStack  rdi     ;; address
   call find_helperFunction
   ;; returns the address of the address of the link of the word in the dictionary (or null)
   pushArgumtStack rax
   next

find_helperFunction:
   ;; >< 不知道下面对rsi的保护有没有必要
   ;; pushArgumtStack rsi    ;; save rsi so we can use it in string comparison
   ;; initialise the searching point
   mov rdx, [FirstWordInDictionary + CellWidth]

find_lookThisPoint:
   test rdx, rdx
   ;-- IF: rdx == 0
   ;-- WK: we reach the end of the linked list
   je find_notFound
   ;-- EL: rdx == 0
   ;-- WK: we have a word to look up
   ;-- DO: look the type field of this word
   mov rax, [rdx + CellWidth]
   and rax, WordType_HiddenMask
   ;-- IF: type::0 of this word =/= 0
   ;-- WK: this word is hidden
   jnz find_lookNextPoint
   ;-- EL: type::0 of this word == 0
   ;-- WK: this word is not hidden
   ;; get word length into rax
   mov TemporaryRegister, [rdx + (2 * CellWidth)]
   mov rax, [TemporaryRegister]
   cmp rax, rcx
   ;-- IF: rax =/= rcx
   ;-- WK: length is not the same
   jne find_lookNextPoint
   ;-- EL: rax == rcx
   ;-- WK: length is the same
   ;-- DO: compare the strings in detail
   pushArgumtStack rcx                       ;; save the length
   pushArgumtStack rdi                       ;; save the address (repe cmpsb will move this pointer)
   lea rsi, [TemporaryRegister + CellWidth]  ;; dictionary string we are checking against.
   ;; >< 下面这个命令的参数是 rsi rdi rcx
   ;; 分别是两个地址和需要被比较的长度
   repe cmpsb                                ;; compare the strings.
   popArgumtStack rdi
   popArgumtStack rcx
   ;-- IF: not the same
   jne find_lookNextPoint
   ;-- EL: the strings are the same
   ;-- DO: return the address of link of this word in rax
   mov rax, rdx
   ;; popArgumtStack rsi
   ret

find_lookNextPoint:
   ;; move back through the link field to the previous word
   mov rdx, [rdx]
   ;; jump back
   jmp find_lookThisPoint

find_notFound:
   ;; return 0
   xor rax, rax
   ;; popArgumtStack rsi
   ret


;; usage;
;; 1 2 readWord + find wordLinkToWordExplainer execute . ( 3 )
defWord "wordLinkToWordExplainer", wordLinkToWordExplainer
   ;; (* word[address of link] -- word[address of explainer] or Zero *)
   dq add8, add8, add8
   dq Exit
defWordEnd wordLinkToWordExplainer
#+end_src
* the basic lexicographer
** note
1. the lexicographer who defines the words
2. 如何在forth中体现数据就是代码这一点呢???
   其实我可以说根本没有这种类比
   因为forth太过底层了
   它根本就没有主要数据结构
   如果一个人说forth是word-list处理语言是牵强的
   或者说forth是dictionary处理语言
   那都是很牵强的
   这与说scheme是列表处理语言有本质的不同
3. 有对wordlist的编译(使用define)的同时
   还可以有对wordlist的eval (explain ???)
4. 一个字符串的reader
   可以在读字符串的同时
   以特殊的方式把这个字符串结构化
   之后
   这些被结构化的信息
   可以被define这类特殊的函数处理
5. 一个REPL就代表一个系统
   一个虚拟机
   这里的REPL的行为方式和古典的forth的REPL的行为方式很不一样了
   这里的REPL没有隐含的状态
   也可以说每个进行input的函数(reader)都可以改变REPL的状态
   每个reader对状态的改变是明显的
6. 我的REPL单纯地在调用而已
   REPL不应该有多种状态
   有多种状态的REPL的某种多余的状态
   其实是在完成别的函数应该完成的工作
7. 从这里实现REPL的方式中我看到
   是一个函数在一个无限的循环中调用REP
   然后才形成了REPL
   这个用来形成无限循环的函数应该被作为高阶函数来实现
   即 REP是它的参数
   REP会处理输入的字符串
   说REP不如说是RE 因为有可能没有P
   当调用不同的reader的时候
   处理输入(比如标准输入)中的字符串的方式自然就改变了
   而古典的forth却把这种处理方式的改变放到了同一个函数中
   这个函数有一个旗子
   这个旗子标志了这个函数的两种状态
   而我的设计下各种处理状态之间的差异更清晰
   并且read和define是分离的
   这种分离性对于灵活性和清晰性来说是有利的
** implementation
在给下面的代码除错的时候我认识到了类型系统的重要性
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
defWord "appendNumberToHere", appendNumberToHere
   ;; (* a 64 bits number -- *)
   ;; reset ``Here'', which points next free memory
   dq Here, fetch
   dq save
   dq Here, fetch, add8
   dq Here ,save
   dq Exit
defWordEnd appendNumberToHere

;; note that:
;; a string in stack is string[address, length]
;; a string in memory is ||  1 : length  ||  n : string  ||
defWord "appendStringToHere", appendStringToHere
   ;; ( string[address, length] -- )
   ;; leave a length behind, for update Here
   dq duplicate, xxswapx
   ;;   ||  1 : length  ||
   dq duplicate, appendNumberToHere
   ;;   ||  n : string  ||
   dq Here, fetch, swap, copyByteString
   ;; update Here
   dq Here, fetch, addition, Here, save
   dq Exit
defWordEnd appendStringToHere

;; test: appendNumberToHere
;; 6 , Here fetch sub8 fetch .


;; recall
;; a word in the dictionary (unit : CellWidth = 8 bytes)
;;   ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
;;   ||  m : name-string  ||
;;   ||  1 : link  ||
;;   ||  1 : type  ||
;;   ||  1 : address-of-name-string-header  ||
;;   ||  1 : address-of-explainer  ||
;;   ||  n : body  ||

defWord "createWordHeader", createWordHeader
   ;; ( string[address, length] -- word[address of link] )
   dq Here, fetch, xxswapx ;; for address-of-name-string-header
   dq appendStringToHere
   dq Here, fetch, appendNumberToHere ;; (* identification *)
   dq Here, fetch ;; (* leave the word[link] *)
   dq Zero, appendNumberToHere ;; (* link *)
   dq Zero, appendNumberToHere ;; (* type *)
   dq swap
   dq appendNumberToHere ;; address-of-name-string-header
   dq Exit
defWordEnd createWordHeader


defWord "createWordHeaderForFunction", createWordHeaderForFunction
   ;; ( string[address, length] -- word[address of link] )
   dq Here, fetch, xxswapx ;; for address-of-name-string-header
   dq appendStringToHere
   dq Zero, appendNumberToHere ;; (* SizeOfFunctionBody *)
   dq Here, fetch, appendNumberToHere ;; (* identification *)
   dq Here, fetch ;; (* leave the word[link] *)
   dq Zero, appendNumberToHere ;; (* link *)
   dq Zero, appendNumberToHere ;; (* type *)
   dq swap
   dq appendNumberToHere ;; address-of-name-string-header
   dq Exit
defWordEnd createWordHeaderForFunction


;; 下面的函数其实可以处理任何函数返回的wordlist
;; 但是readWordListForLexicographer是专门为这里的函数而准备的
;; 之所以需要这种专门的reader
;; 是因为我实现这些reader的方式具有局限性
defWord "appendWordDescriptionToHere", appendWordDescriptionToHere
   ;; 这是一个处理列表的递归函数?? 其实是循环 因为我还没实现递归定义呢
   ;; 或者说这是一个尾递归优化了的递归函数
   ;; ( wordList[address, the number of words] -- )
   dq duplicate, zero?branch, 16;-- GOTO: twoDrop
   dq tailAndHeadOfWordList
   dq twoDuplicate, stringDenoteNumber?
   dq false?branch, 6;-- GOTO: 处理非数字
   ;; 处理数字, 这里放弃了对number的返回值作错误处理的机会
   dq number, drop, appendNumberToHere
   dq branch, -12;-- GOTO: the beginning
   ;; 处理非数字
   dq find, wordLinkToWordExplainer, appendNumberToHere
   dq branch, -17;-- GOTO: the beginning
   ;; 结束
   dq twoDrop
   dq Exit
defWordEnd appendWordDescriptionToHere

defWord "addNewWordToDictionary", addNewWordToDictionary
   ;; reset FirstWordInDictionary to point to the newly defined word
   ;; ( word[address of link] -- )
   dq duplicate
   dq FirstWordInDictionary, fetch
   dq swap
   dq save
   dq FirstWordInDictionary, save
   dq Exit
defWordEnd addNewWordToDictionary

defWord "setTheSizeOfFunctionBody", setTheSizeOfFunctionBody
   ;; (* wordList[address, the number of words], word[address of link] --
   ;;    wordList[address, the number of words], word[address of link] *)
   dq duplicate
   dq sub8, sub8
   dq xoverxx
   dq swap
   dq save
   dq Exit
defWordEnd setTheSizeOfFunctionBody

defWord "defineFunction", defineFunction
   ;; ( wordList[address, the number of words] -- )
   ;; to create a new word
   ;; is to use some words to describe the new word,
   ;; and let an explainer to explain the description of the new word.
   ;; to define a new word
   ;; is to add the new created word to the dictionary.
   dq tailAndHeadOfWordList
   dq createWordHeaderForFunction
   dq FunctionBodyExplainer, appendNumberToHere
   dq setTheSizeOfFunctionBody
   dq xxswapx
   dq appendWordDescriptionToHere
   dq addNewWordToDictionary
   dq Exit
defWordEnd defineFunction
#+end_src
* runtime
** note
REPL for xiaolinguist is ``read execute (maybe print) loop''
** implementation
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
defWord "basicREPL", basicREPL
   ;; ( unknown -- unknown )
   dq TheReturnStackTop, resetReturnStackPointer
   dq TheArgumtStackTop, resetArgumtStackPointer
   dq readAndExeute
   dq branch, -2
   ;; must not end with Exit here
defWordEnd basicREPL


defWord "readAndExeute", readAndExeute
   ;; ( unknown -- unknown )
   dq readWordForRuntime
   dq twoDuplicate, stringDenoteNumber?
   dq false?branch, 4;-- GOTO: find, 处理非数字

   ;; 处理数字, 这里放弃了对number的返回值作错误处理的机会
   dq number, drop
   dq Exit

   ;; 处理非数字
   dq find, duplicate, zero?branch, 4;-- GOTO: drop, errorOfReadAndExeute
   dq wordLinkToWordExplainer, execute
   dq Exit

   dq drop, errorOfReadAndExeute
   dq Exit
defWordEnd readAndExeute


defCode "errorOfReadAndExeute", errorOfReadAndExeute
   mov sys_3_rdx, errorOfReadAndExeute_massageSize
   mov sys_2_rsi, errorOfReadAndExeute_massage
   mov sys_1_rdi, 1; stdout
   mov sys_n_rax, syscall_write
   syscall
   next

segment readable writeable
errorOfReadAndExeute_massage   db ' <undefined word> ',ascii.linefeed
errorOfReadAndExeute_massageSize = ($ - errorOfReadAndExeute_massage)
#+end_src
* --------------------------------------------------
* memory allocation
** note
1. 注意有很多用户空间的大小都没有被保护到 !!!
   如果让操作系统处理这种错误就会导致程序崩溃
** UserDataSegment (for define new words)
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
SizeOfUserDataSegment = 11 * 1024 * 1024 ;; unit: byte
segment readable writeable
UserDataSegment:
        rb SizeOfUserDataSegment
EndOfUserDataSegment:
#+end_src
** ReturnStack & ArgumtStack
1. 当给栈中push入第一个元素的时候
   ArgumtStackPointer才会指向保存这个第一个元素的地址
2. 而在给栈中push入第一个元素之前
   ArgumtStackPointer所指向的是StackTop
   StackTop是不会被栈用到的
3. StackBottom 和 StackTop
   在人类语义上和在实现(机器语义)上刚好是相反的
   但是其实不同的人对这里的``正反''可能也会又不同的理解
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
SizeOfReturnStack = 100 * 1024 ;; unit: CellWidth

defConst "ReturnStackTop",    ReturnStackTop,    TheReturnStackTop
defConst "ReturnStackBottom", ReturnStackBottom, TheReturnStackBottom

segment readable writeable
ReturnStackBottom:
        rq SizeOfReturnStack
ReturnStackTop:
        rq 100


defConst "ArgumtStackTop",    ArgumtStackTop,    TheArgumtStackTop
defConst "ArgumtStackBottom", ArgumtStackBottom, TheArgumtStackBottom

SizeOfArgumtStack = 100 * 1024 ;; unit: CellWidth
segment readable writeable
ArgumtStackBottom:
        rq SizeOfArgumtStack
ArgumtStackTop:
        rq 100
#+end_src
** PairConstructionsArray & GreyPairStack (about gc)
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
;;   (unit : byte)
;; ========================
;;   ||  1 : color     ||
;; ------------------------
;;   ||  8 : type tag  ||
;;   ||  8 : value     ||
;; ------------------------
;;   ||  8 : type tag  ||
;;   ||  8 : value     ||
;; ========================

ClrBytesSize = 1
CarBytesSize = 16
CdrBytesSize = 16
ConsBytesSize = ClrBytesSize + CarBytesSize + CdrBytesSize
NumberOfPairConstructions = 1024;; unit: byte

defConst "ClrBytesSize"  , ClrBytesSize  , TheClrBytesSize
defConst "CarBytesSize"  , CarBytesSize  , TheCarBytesSize
defConst "CdrBytesSize"  , CdrBytesSize  , TheCdrBytesSize
defConst "ConsBytesSize" , ConsBytesSize , TheConsBytesSize

segment readable writeable
        rb ClrBytesSize
InFrontOfTheFirstPairConstruction:
        rb (CarBytesSize + CdrBytesSize)

        rb ClrBytesSize
FirstPairConstruction:
        rb (CarBytesSize + CdrBytesSize)

        ;; ==========================
        rb (NumberOfPairConstructions - 2) * ConsBytesSize
        ;; ==========================

        rb ClrBytesSize
LastPairConstruction:
        rb (CarBytesSize + CdrBytesSize)

defConst "NumberOfPairConstructions", NumberOfPairConstructions, TheNumberOfPairConstructions

defConst "InFrontOfTheFirstPairConstruction", InFrontOfTheFirstPairConstruction, TheInFrontOfTheFirstPairConstruction
defConst "FirstPairConstruction", FirstPairConstruction, TheFirstPairConstruction
defConst "LastPairConstruction",  LastPairConstruction,  TheLastPairConstruction

defVar "CurrFreePairConstruction", FirstPairConstruction, CurrFreePairConstruction


;;------------------------------------------
;; 需要专门为gc准备一个栈 这个栈用来存放grey的pair
;; 这个栈中并不需要存放 type-tag 因为其中的所有值都是pair类型

SizeOfGreyPairStack = 100 * 1024 ;; unit: CellWidth
segment readable writeable
GreyPairStackBottom:
        rq SizeOfGreyPairStack
GreyPairStackTop:
        rq 1
#+end_src
** HashTableForSymbol
using linear probing
so, the load factor must be lower then 0.5
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
;; a SymbolEntry (unit : byte)
;; ========================
;;   ||  1 : SymbolLength  ||
;; ------------------------
;;   || 56 : SymbolString  ||
;; ========================

SymbolLengthBytesSize = 1
;; 下面这个常数是多大应该根本不影响程序Symbol工作方式
SymbolStringBytesSize = 56 + 63;; 这样在SymbolEntry的末尾就可以保存一个word的地址
SymbolMaxLength = SymbolStringBytesSize
SymbolEntryBytesSize = SymbolLengthBytesSize + SymbolStringBytesSize
;; NumberOfSymbolEntrys = 1000003
;; NumberOfSymbolEntrys = 1000033
;; NumberOfSymbolEntrys = 1000333
;; ><><>< the numbers above are too big for ELF ???
;; NumberOfSymbolEntrys = 100003
NumberOfSymbolEntrys = 100333
;; NumberOfSymbolEntrys = 997
;; NumberOfSymbolEntrys = 499
;; NumberOfSymbolEntrys = 230


defConst "NumberOfSymbolEntrys",  NumberOfSymbolEntrys,  TheNumberOfSymbolEntrys
defConst "SymbolLengthBytesSize", SymbolLengthBytesSize, TheSymbolLengthBytesSize
defConst "SymbolStringBytesSize", SymbolStringBytesSize, TheSymbolStringBytesSize
defConst "SymbolMaxLength",       SymbolMaxLength,       TheSymbolMaxLength
defConst "SymbolEntryBytesSize",  SymbolEntryBytesSize,  TheSymbolEntryBytesSize

segment readable writeable

FirstSymbolEntry:
        rb SymbolEntryBytesSize

        ;; ========================
        rb (NumberOfSymbolEntrys - 2) * SymbolEntryBytesSize
        ;; ========================

LastSymbolEntry:
        rb SymbolEntryBytesSize


defConst "FirstSymbolEntry", FirstSymbolEntry, TheFirstSymbolEntry
defConst "LastSymbolEntry",  LastSymbolEntry,  TheLastSymbolEntry
#+end_src
** two StringHeaps
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
SizeOfStringHeap = 1024 ;; unit: byte
segment readable writeable
StringHeap1:
        rb SizeOfStringHeap
EndOfStringHeap1:
segment readable writeable
StringHeap2:
        rb SizeOfStringHeap
EndOfStringHeap2:

defConst "SizeOfStringHeap", SizeOfStringHeap, TheSizeOfStringHeap

defConst "StringHeap1", StringHeap1, TheStringHeap1
defConst "StringHeap2", StringHeap2, TheStringHeap2
#+end_src
** >< LambdaStack
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
SizeOfLambdaStack = 100 * 1024 ;; unit: CellWidth
segment readable writeable
LambdaStackBottom:
        rq SizeOfLambdaStack
LambdaStackTop:
        rq 1
#+end_src
* --------------------------------------------------
* assemblyDebug
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
defConst "ascii.zero", 48, ascii.zero
defWord ".", printLittleNumber
   dq ascii.zero, addition, writeChar
   dq Exit
defWordEnd printLittleNumber

defCode "exitWithTOS", exitWithTOS
   popArgumtStack sys_1_rdi
   mov sys_n_rax, syscall_exit
   syscall

defWord "assemblyDebug", assemblyDebug
   ;; dq ><><><
   dq exitWithTOS
defWordEnd assemblyDebug
#+end_src
* --------------------------------------------------
* TheLatestWordInThisFile
#+begin_src fasm :tangle ./play/xiaolinguist.fasm
defConst "TheLatestWordInThisFile", 0, TheLatestWordInThisFile
#+end_src
* ==================================================
* *self-hosting*
1. 纯粹的解释型语言的 incremental developing
   一定会导致我必须在前面的某些部分中
   用并不完美的方式来解决某些问题(定义某些函数)
   比如:
   ``cons''的定义中想要用到``debuger''
  但是定义``debuger''的时候
  还没有动态分配内存的 string 因为还没有gc
  也没有 string-literal 因为还没有``cons''也就没有 multi-pass
2. 要想实现真正的self-hosting 就必须形成编译语义
   在我看来 有两种方法来形成编译语义
   1) 在xiaolinguist内实现本地码的汇编其器
      可移植性 == 移植的简单性 == 在xiaolinguist中写一个汇编器的简单性
      这将非常简单 只差对文件的基本输入输出 我就可以开始写了
      但是其实最好在完成了良好的列表处理语义之后再写
      需要学习的是可执行文件的格式
      + 注意写完一个本地码汇编器之后
        还要用所实现的汇编语言实现一个xiaolinguist才算移植的完成
        这里有很大的灵活性
        但是可能每次所需要重写的xiaolinguist都非常不同
        >< 只有在充分实践之后才能回答这些问题
   2) 设计一个栈处理机的cpu架构 
      此时移植的简单性是最强的
      可移植性 == 移植的简单性 == 在目标平台的语言中写一个bytecode解释器的简单性
      并且可以很容易的嵌入用别的语言写成的程序而形成扩展语言 等等
      但是 虚拟机很难被设计成可扩展的
      尤其是考虑到在嵌入高级语言的同时
      还要作为汇编语言与源语言之间的中间语言
      并且 此时基本上无法真正地针对效率来优化编译器
      我不喜欢这种方式 因为:
      1. 这并不是在展示xiaolinguist这个语言本身的能力
         尤其是嵌入其他主流语言的行为 简直是在向主流语言臣服
      2. 有了xiaolinguist之后我基本上就不需要其他的语言了
* >< 十诫
1. 后面用到的函数和word要在前面先定义好
   一个 helper-function 一定要定义在被帮助的函数前面
2. if <body-1> then <body-2> 中
   1) <body-1>后面如果没有跟Exit
      那么<body-1>是一个在特定的条件下被执行的副作用
      那么它就一定不能变更栈的状态 即必须要有 <body-1> (* -- *)
   2) 而当<body-1>后面跟Exit的时候就可以实现真正的分支结构
      Exit是一个标记
      它表明在它前面的函数执行完毕之后就退出对这个函数的调用
      就这个函数而言这是一个全局退出
      也就是说if,then,Exit的组合控制机器运行方式的能力
      比if,else,then要弱
   在使用这种if,then,Exit的组合时
   代码的特点是:
   1) 没有嵌套的if
      必须用帮助函数(子程)来实现类似的效果
   2) 没有局部退出
      这是因为没有嵌套 当然也就无从局部退出
3. 尽管没有对命名空间的管理和保护
   但是那些只被某些特殊函数所使用的变量的名字
   却可以被取得很短
   这是因为在编译的时候
   这些word的地址被找(find函数)好了
   + 这样就实现了与closure所实现的lexical-scope类似的效果
4. 注意所有数据结构的实现方式
   因为可能有多种方式(比如:多个地址) 都能代表同一个数据结构
   而对这些不同的表示方式 又有不同的处理函数
   现在系统中的主要数据结构只有两个:
   1) Word in Directory
      表示方式有:
      word[address of link]
      word[address of explainer]
   2) PairConstruction in PairConstructionsArray
      表示方式有:
      <pair>[address, type]
      pair[address]
   这种同一个数据结构的多种表示方式
   也许应该被看成是非常不好的编程风格
   但是至少在上面这两个例子当中
   这种风格的使用是自然的
   + 并且我想这种风格在很多其他地方的使用也是自然的
     因此要注意这一条戒律
5. 写一个大函数的时候发现需要把它分解成小函数
   然后你就去写那些小函数
   重要的是每写完一个小函数的时候 如果这个函数的正确性不是显然的
   那么就马上去测试这个小函数的正确性
   因为当回到大函数的时候 就很难发现是那里错误了
   + 其实不难发现是哪里错了
     因为forth系统的线性性
     使得当一段函数的执行出错了的时候
     找到真正出错的那个函数的过程非常容易
   + 给函数加上类型声明
     然后给某些字典编撰者加上对类型的静态分析
     就很容易避免很多错误
   上面这个是非常重要的一诫
   我的感受是
   在没有类型系统的条件下
   当运行的时候出现了一个错误
   通常在十分钟之内就能找到引起错误的函数
   然后发现一个可笑的bug我自己都笑了
   这一诫的有趣之处在于我几乎不可能去遵守这条戒律
   在写下一个函数的时候
   我总是想单纯地通过看着这个函数就相信这个函数是正确的
   要想忽视这条戒律
   那么你就必须找出很好的设计函数接口的方式
   并且找出(发明出)一组极好的用来描述你想要解决的问题的words
   也许忽视这条戒律 并且 摒弃类型推导系统
   就能鞭策你设计出更优雅而简洁的程序呢 !!!
6. 在xiaolinguist中使用cons的方式和在scheme中很不同
   因为在scheme中一个表达式的返回值会直接被打印出来
   而在xiaolinguist中一个表达式的返回值会被放到ArgumtStack中
   因为被放到栈中的cons还可能被引用到 所以不能够被垃圾回收
   这就引出了forth编程中非常重要的一条戒律
   那就是要管理好自己的栈
   在一次计算之后 栈中所保存的应该只是我所需要的返回值
   而不能保存更多的东西
7.
8.
9.
10.
* --------------------------------------------------
* defineVar & defineConst (new lexicographers)
** implementation
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
(* to create a new word is to use some words to describe the new word,
 ,* and let an explainer to explain the description of the new word.
 ,* to define a new we just need to add the new created word to the dictionary.
 ,*)

: defineVar (* wordList[address, the number of words] -- *)
    tailAndHeadOfWordList
    createWordHeader
    VarExplainer appendNumberToHere
    xx|swap|x twoDrop (* drop zero-length wordlist *)
    swap (* leave wordHeader *)
    appendNumberToHere
    addNewWordToDictionary
    Exit
; defineFunction

: defineConst (* wordList[address, the number of words] -- *)
    tailAndHeadOfWordList
    createWordHeader
    ConstExplainer appendNumberToHere
    xx|swap|x twoDrop (* drop zero-length wordlist *)
    swap (* leave wordHeader *)
    appendNumberToHere
    addNewWordToDictionary
    Exit
; defineFunction
#+end_src
** test
#+begin_src xiaolinguist
0 : Yi ; defineVar

Yi fetch . (* 0 *)
1 Yi save
Yi fetch . (* 1 *)

7 : Qi ; defineConst
Qi . (* 7 *)

: QiJiaYi (* -- *)
    Qi Yi fetch + .
    Exit
; defineFunction
QiJiaYi (* 8 *)
#+end_src
* ><>< defineArray
** note
ArrayByteSize ArrayLength
* ascii chars
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
10  : 'linefeed' ; defineConst
10  : 'newline'  ; defineConst
27  : 'escape'   ; defineConst
32  : 'space'    ; defineConst
127 : 'delete'   ; defineConst

33 : '!' ; defineConst
34 : '"' ; defineConst
35 : '#' ; defineConst
36 : '$' ; defineConst
37 : '%' ; defineConst
38 : '&' ; defineConst
39 : ''' ; defineConst
40 : '(' ; defineConst
41 : ')' ; defineConst
42 : '*' ; defineConst
43 : '+' ; defineConst
44 : ',' ; defineConst
45 : '-' ; defineConst
46 : '.' ; defineConst
47 : '/' ; defineConst
    
48 : '0' ; defineConst
49 : '1' ; defineConst
50 : '2' ; defineConst
51 : '3' ; defineConst
52 : '4' ; defineConst
53 : '5' ; defineConst
54 : '6' ; defineConst
55 : '7' ; defineConst
56 : '8' ; defineConst
57 : '9' ; defineConst
    
58 : ':' ; defineConst
59 : ';' ; defineConst
60 : '<' ; defineConst
61 : '=' ; defineConst
62 : '>' ; defineConst
63 : '?' ; defineConst
64 : '@' ; defineConst
    
65 : 'A' ; defineConst
66 : 'B' ; defineConst
67 : 'C' ; defineConst
68 : 'D' ; defineConst
69 : 'E' ; defineConst
70 : 'F' ; defineConst
71 : 'G' ; defineConst
72 : 'H' ; defineConst
73 : 'I' ; defineConst
74 : 'J' ; defineConst
75 : 'K' ; defineConst
76 : 'L' ; defineConst
77 : 'M' ; defineConst
78 : 'N' ; defineConst
79 : 'O' ; defineConst
80 : 'P' ; defineConst
81 : 'Q' ; defineConst
82 : 'R' ; defineConst
83 : 'S' ; defineConst
84 : 'T' ; defineConst
85 : 'U' ; defineConst
86 : 'V' ; defineConst
87 : 'W' ; defineConst
88 : 'X' ; defineConst
89 : 'Y' ; defineConst
90 : 'Z' ; defineConst
    
91 : '[' ; defineConst
92 : '\' ; defineConst
93 : ']' ; defineConst
94 : '^' ; defineConst
95 : '_' ; defineConst
96 : '`' ; defineConst
    
97  : 'a' ; defineConst
98  : 'b' ; defineConst
99  : 'c' ; defineConst
100 : 'd' ; defineConst
101 : 'e' ; defineConst
102 : 'f' ; defineConst
103 : 'g' ; defineConst
104 : 'h' ; defineConst
105 : 'i' ; defineConst
106 : 'j' ; defineConst
107 : 'k' ; defineConst
108 : 'l' ; defineConst
109 : 'm' ; defineConst
110 : 'n' ; defineConst
111 : 'o' ; defineConst
112 : 'p' ; defineConst
113 : 'q' ; defineConst
114 : 'r' ; defineConst
115 : 's' ; defineConst
116 : 't' ; defineConst
117 : 'u' ; defineConst
118 : 'v' ; defineConst
119 : 'w' ; defineConst
120 : 'x' ; defineConst
121 : 'y' ; defineConst
122 : 'z' ; defineConst
    
123 : '{' ; defineConst
124 : '|' ; defineConst
125 : '}' ; defineConst
126 : '~' ; defineConst
#+end_src
* some constants about linux syscall
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
0 : Syscall,read  ; defineConst
1 : Syscall,write ; defineConst
2 : Syscall,open  ; defineConst
3 : Syscall,close ; defineConst

1 : Syscall,write,StandardOutput ; defineConst
#+end_src
* string & defineConstString (new lexicographer)
** implementation
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
(* ><><>< 对下面的函数来说 如果string的长度是0
 ,* 那么就应该报错 但是 在这里 我放弃这个报错的机会
 ,*)
: headOfString (* string[address, length] -- first char *)
    drop fetchByte
    Exit
; defineFunction

: tailOfString (* string[address, length] -- string[address + 1, length - 1] *)
    sub1 swap add1 swap
    Exit
; defineFunction

: tailAndHeadOfString
  (* string[address, length] --
     string[address + 1, length - 1], first char *)
    twoDuplicate tailOfString xx|swap|xx headOfString
    Exit
; defineFunction

: printString (* string[address, length] -- *)
   Syscall,write
   Syscall,write,StandardOutput
   xx|swap|xx
   syscallWithThreeArguments
   drop (* length is returned by this syscall *)
   Exit
; defineFunction


: :" (* -- string[address of BufferForReadStringInToBuffer, length] *)
    readStringInToBuffer
    Exit
; defineFunction

: ." (* -- string[address of BufferForReadStringInToBuffer, length] *)
    readStringInToBuffer printString
    Exit
; defineFunction

: defineConstString
  (* string[address, length],
     wordList[address, the number of words] -- *)
    tailAndHeadOfWordList
    createWordHeader
    ConstStringExplainer appendNumberToHere
    xx|swap|x twoDrop (* drop zero-length wordlist *)
    xx|swap|x (* leave wordHeader *)
    appendStringToHere
    addNewWordToDictionary
    Exit
; defineFunction
#+end_src
** test
#+begin_src xiaolinguist
:" kkk"
: k ; defineConstString
k printString (* kkk *)
#+end_src
* terminal escape sequences
1. 接口方面:
   境变量$TERM保存linux系统认为你当前所使用的terminal
   /usr/share/terminfo/*/*中保存着各种terminal的信息
2. man console_codes
----------------------------------------------
escape [ ``arg'' m
 0       reset all attributes to their defaults
 1       set bold
 2       set half-bright (simulated with color on a color display)
 4       set underscore (simulated with color on a color  display)
         (the  colors  used  to  simulate dim or underline are set
         using ESC ] ...)
 5       set blink
 7       set reverse video
 10      reset selected mapping, display control flag, and  toggle
         meta flag (ECMA-48 says "primary font").
 11      select null mapping, set display control flag, reset tog‐
         gle meta flag (ECMA-48 says "first alternate font").
 12      select null mapping, set display control flag, set toggle
         meta  flag  (ECMA-48  says "second alternate font").  The
         toggle meta flag causes the high bit of a byte to be tog‐
         gled before the mapping table translation is done.
 21      set normal intensity (ECMA-48 says "doubly underlined")
 22      set normal intensity
 24      underline off
 25      blink off
 27      reverse video off

 30      set black foreground
 31      set red foreground
 32      set green foreground
 33      set brown foreground
 34      set blue foreground
 35      set magenta foreground
 36      set cyan foreground
 37      set white foreground

 38      set underscore on, set default foreground color
 39      set underscore off, set default foreground color

 40      set black background
 41      set red background
 42      set green background
 43      set brown background
 44      set blue background
 45      set magenta background
 46      set cyan background
 47      set white background
 49      set default background color

#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
:" [2J"
: TerminalSequence,clearScreen ; defineConstString
: terminal,clearScreen (* -- *)
    'escape' writeChar
    TerminalSequence,clearScreen printString
    Exit
; defineFunction


:" [12;25H"
: TerminalSequence,moveCursor ; defineConstString
: terminal,moveCursor (* -- *)
    'escape' writeChar
    TerminalSequence,moveCursor printString
    Exit
; defineFunction


:" [31m"
: TerminalSequence,red ; defineConstString
: terminal,red (* -- *)
    'escape' writeChar
    TerminalSequence,red printString
    Exit
; defineFunction

:" [1;31m"
: TerminalSequence,bold,red ; defineConstString
: terminal,bold,red (* -- *)
    'escape' writeChar
    TerminalSequence,bold,red printString
    Exit
; defineFunction

:" [1;35m"
: TerminalSequence,bold,magenta ; defineConstString
: terminal,bold,magenta (* -- *)
    'escape' writeChar
    TerminalSequence,bold,magenta printString
    Exit
; defineFunction


:" [36m"
: TerminalSequence,cyan ; defineConstString
: terminal,cyan (* -- *)
    'escape' writeChar
    TerminalSequence,cyan printString
    Exit
; defineFunction

:" [49m"
: TerminalSequence,default,background ; defineConstString
: terminal,default,background (* -- *)
    'escape' writeChar
    TerminalSequence,default,background printString
    Exit
; defineFunction




:" [5m"
: TerminalSequence,blinkOn ; defineConstString
: terminal,blinkOn (* -- *)
    'escape' writeChar
    TerminalSequence,blinkOn printString
    Exit
; defineFunction


:" [25m"
: TerminalSequence,blinkOff ; defineConstString
: terminal,blinkOff (* -- *)
    'escape' writeChar
    TerminalSequence,blinkOff printString
    Exit
; defineFunction


:" [4m"
: TerminalSequence,underlineOn ; defineConstString
: terminal,underlineOn (* -- *)
    'escape' writeChar
    TerminalSequence,underlineOn printString
    Exit
; defineFunction


:" [24m"
: TerminalSequence,underlineOff ; defineConstString
: terminal,underlineOff (* -- *)
    'escape' writeChar
    TerminalSequence,underlineOff printString
    Exit
; defineFunction


:" linux programming is stupid"
: TerminalSequence,linux-programming-is-stupid ; defineConstString
: terminal,say,linux-programming-is-stupid (* -- *)
    terminal,clearScreen
    terminal,moveCursor
    (* terminal,red *)
    terminal,blinkOn
    terminal,underlineOn
    TerminalSequence,linux-programming-is-stupid printString
    terminal,underlineOff
    terminal,blinkOff
    Exit
; defineFunction
#+end_src
* recursive Function & decision (new lexicographers)
** note
1. 要知道(除了call/cc之外)每种用来实现对运行方式的控制的语法关键词
   其实都是某种模式的goto (或者说branch)
2. 在scheme中
   有对一般的函数的解释方式
   还有对特殊的语法关键词的解释方式
3. 而在我的forth虚拟机的repl中
   形成语法关键词的方式是调用特殊的reader
   也就是说
   1) 有一个一般的reader(repl中的基础reader)
      它读下一个word然后解释这个word 或者将一个数字入栈
   2 而当调用特殊的reader的时候)
      就将形成对word的特殊的解释方式
      reader都是以stdin为参数的函数
4. 关于分支语义的语法关键词:if,else,then
   在repl中 通过调用一个特殊的reader来实现
   而在用字典编撰者作编译的时候 可以设计任何一种方式来实现
   也就是说
   解释语义与编译语义之间有不一致性
   很遗憾我没办法弥补这种不一致性
下面是scheme中的对比
#+begin_src scheme
(cond [(<predicate-1> TOS)
       <body-1>]
      [(<predicate-2> TOS)
       <body-2>]
      [(<predicate-3> TOS)
       <body-3>]
      [else
       <body-4>])
==
(if (<predicate-1> TOS)
  <body-1>
  (if (<predicate-2> TOS)
    <body-2>
    (if (<predicate-3> TOS)
      <body-3>
      <body-4>)))
#+end_src
==
#+begin_src xiaolinguist
TOS
duplicate <predicate-1> if
   <body-1>
else
duplicate <predicate-2> if
   <body-2>
else
duplicate <predicate-3> if
   <body-3>
else
   <body-4>
then

(* 如果不用else的话 所有的谓词就都会被问到
  而使用else之后就像scheme中的cond一样
  只有一个谓词是真时 后面的谓词就不会再被问到了 *)

(* 如果不使用else而只使用then的话
  实现方式就简单多了
  这也许没那么坏
  毕竟除非谓词所代表的数据类型完全分离
  否则两种语义下
  谓词行的顺序都会影响程序的结果
  而当谓词能够完全分离的时候这两种语义就是统一的了
  所以写程序的时候应该定义性质良好的谓词
  使得数据类型之间完全分离 *)

(* 两种语义有不同的用途 都应该被实现 *)

TOS
duplicate <predicate-1> if
   <body-1>
then
duplicate <predicate-2> if
   <body-2>
then
duplicate <predicate-3> if
   <body-3>
then
   <body-4>
#+end_src

在repl中可以这样实现:
如果if看到TOS的值是True
它就执行if后面的<body>
然后找then
执行then后面的东西
如果if看到TOS的值是False
它就找else或then
执行then或else后面的东西

在define中实现方式是多种多样的:
可以把if是实现为特殊的函数(explainer)
也可以通过实现更复杂的defineFunction来实现
后者就是在扩展编译器
而前者是在扩展字的解释者

但是当嵌套的时候如何呢???
在语法上嵌套的if的特点是在一个if后面
还有语法else和then的时候
就又出现了一个if
栈这个数据结构正是为了解决这种嵌套而设计的
但是如何实现if的嵌套呢??
每个if根据它所看到的TOS的不同
而触发不同的repl
当然能够被if触发的只有两种不同的repl
这种repl会在看到不同的标志的时候终止自己
也就是说
是各种repl的嵌套在实现着这些语法关键词的语义
#+begin_src xiaolinguist
TOS
duplicate <predicate-1> if
  duplicate <predicate-1-1> if
     <body-1-1>
  else
  duplicate <predicate-1-2> if
     <body-1-2>
  else
     <body-1-3>
  then
else
duplicate <predicate-2> if
  duplicate <predicate-2-1> if
     <body-2-1>
  else
  duplicate <predicate-2-2> if
     <body-2-2>
  else
  duplicate <predicate-2-3> if
     <body-2-3>
  then
else
duplicate <predicate-3> if
   <body-3>
else
   <body-4>
else
   <body-5>
then

(* 注意: 下面所说的入栈的位置 不能影响函数的递归调用 *)

(* 注意: 因为是后缀表达式 所以划定scope的核心词是结尾的then 而不是开头的if
        如果then能够找到自己的scope
        那么就能定义好这种语法 *)

(* 每遇到一个if就会写下一个false?branch
  然后把这个位置的地址入栈 然后把一个计数器入栈
  之后遇到else的时候这对而入栈的东西就是需要被else处理的
  即 把计数器里数出来的word的个数写到那个地址里 *)

(* 遇到else的时候 除了需要作上面的工作之外
  还需要写下一个branch
  然后把这个位置的地址入栈 然后把一个计数器入栈
  之后遇到then的时候栈里面可能有很多else所入栈的东西
  这些入栈的东西就是需要被then所处理的 *)

(* 遇到then的时候 栈里需要被处理的东西是
  一个if留下的 后面又可能有多个else留下的
  也可能 后面没有else留下的 [当省略else的时候]
  这个时候必须能够判断一组else留下的东西的末尾在哪里
  所以上面所入栈的东西除了地址和计数器之外
  还比需要有一个字符串常量来表明类型
  >< 应该用什么东西来表示类型呢???
  >< 我是不是应该稍微丰富一下我的系统的数据结构呢??? *)
#+end_src

简单的条件执行的语法关键词:
用if和then
或许用when和then更能区分语义
#+begin_src xiaolinguist
TOS
duplicate <predicate-1> when
   <body-1>
then
   <body-2>
==
TOS
duplicate <predicate-1> if
   <body-1>
then
   <body-2>
#+end_src
** note 2
下面是一些可能的实现方式
要知道
在这里我根本就不必在性状的选择上有过多的犹豫和疑虑
因为以最基本的编译器:defineFunction为基础
我可以定义很多编译器 而每个编译器又都可以成为新的基础
性状的改变是非常自由而灵活的
所以在下面的代码中我先实现最简单的不能嵌套的if,then组合
#+begin_src xiaolinguist
duplicate <predicate-1> if
   <body-1>
then
(* 编译成结果: *)
duplicate <predicate-1> false?branch [then]
   <body-1>
[then]



duplicate <predicate-1> if
   <body-1>
then
duplicate <predicate-2> if
   <body-2>
then
duplicate <predicate-3> if
   <body-3>
then
   <body-4>
(* 编译成结果: *)
duplicate <predicate-1> false?branch [then]
   <body-1>
[then]
duplicate <predicate-2> false?branch [then]
   <body-2>
[then]
duplicate <predicate-3> false?branch [then]
   <body-3>
[then]
   <body-4>



duplicate <predicate-1> if
   <body-1>
else
duplicate <predicate-2> if
   <body-2>
else
   <body-3>
then
(* 编译成结果: *)
duplicate <predicate-1> false?branch [else]
   <body-1>
   branch [then]
[else]
duplicate <predicate-2> false?branch [else]
   <body-2>
   branch [then]
[else]
   <body-3>
[then]
#+end_src
** implementation
1. if there is one undefined word
   there will be crazy bug which is very hard to test !!
2. if there is one ``if,then'' pair mismatch
   there will be crazy bug which is very hard to test !!
3. after the implementation of ``debuger''
   I will fix the first
   after the implementation of ``list''
   I will fix the second
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
: defineRecursiveFunction (* wordList[address, the number of words] -- *)
    tailAndHeadOfWordList
    createWordHeaderForFunction
    setTheSizeOfFunctionBody
    addNewWordToDictionary
    FunctionBodyExplainer appendNumberToHere
    appendWordDescriptionToHere
    Exit
; defineFunction

:" if"   
: String,KeyWord,if ; defineConstString

:" then" 
: String,KeyWord,then ; defineConstString

: appendWordDescriptionToHereWith:if&then
  (* wordList[address, the number of words] -- *)
    duplicate zero? false?branch 3
      twoDrop Exit

    tailAndHeadOfWordList

    twoDuplicate String,KeyWord,if equalString? false?branch 12
      twoDrop
      literal false?branch appendNumberToHere
      Here fetch xx|swap|x
      duplicate appendNumberToHere
      appendWordDescriptionToHereWith:if&then Exit

    twoDuplicate String,KeyWord,then equalString? false?branch 8
      twoDrop
      x|swap|xx over swap subSave
      appendWordDescriptionToHereWith:if&then Exit

    twoDuplicate stringDenoteNumber? false?branch 6
      number drop appendNumberToHere
      appendWordDescriptionToHereWith:if&then Exit

      find wordLinkToWordExplainer appendNumberToHere
      appendWordDescriptionToHereWith:if&then Exit
; defineRecursiveFunction

: defineRecursiveFunctionWith:if&then
  (* wordList[address, the number of words] -- *)
    tailAndHeadOfWordList
    createWordHeaderForFunction
    setTheSizeOfFunctionBody
    addNewWordToDictionary
    FunctionBodyExplainer appendNumberToHere
    appendWordDescriptionToHereWith:if&then
    Exit
; defineFunction


(* redefine appendWordDescriptionToHere as test *)

: appendWordDescriptionToHere
  (* wordList[address, the number of words] -- *)
    duplicate zero? if
      twoDrop Exit
    then
    tailAndHeadOfWordList
    twoDuplicate String,KeyWord,if equalString? if
      twoDrop
      literal false?branch appendNumberToHere
      Here fetch xx|swap|x
      duplicate appendNumberToHere
      appendWordDescriptionToHere Exit
    then
    twoDuplicate String,KeyWord,then equalString? if
      twoDrop
      x|swap|xx over swap subSave
      appendWordDescriptionToHere Exit
    then
    twoDuplicate stringDenoteNumber? if
      number drop appendNumberToHere
      appendWordDescriptionToHere Exit
    then
      find wordLinkToWordExplainer appendNumberToHere
      appendWordDescriptionToHere Exit
; defineRecursiveFunctionWith:if&then


(* redefine defineRecursiveFunction & defineFunction *)

: defineFunction
  (* wordList[address, the number of words] -- *)
    tailAndHeadOfWordList
    createWordHeaderForFunction
    setTheSizeOfFunctionBody
    xx|swap|x
    FunctionBodyExplainer appendNumberToHere
    appendWordDescriptionToHere
    addNewWordToDictionary
    Exit
; defineFunction

: defineRecursiveFunction
  (* wordList[address, the number of words] -- *)
    tailAndHeadOfWordList
    createWordHeaderForFunction
    setTheSizeOfFunctionBody
    addNewWordToDictionary
    FunctionBodyExplainer appendNumberToHere
    appendWordDescriptionToHere
    Exit
; defineFunction
#+end_src
** test
#+begin_src xiaolinguist
: factorial (* n -- n! *)
    duplicate one? if
      Exit
    then
    duplicate sub1 factorial * Exit
; defineRecursiveFunction

1 factorial .
2 factorial .
3 factorial .
4 factorial .
5 factorial .
6 factorial .
7 factorial .
8 factorial .
9 factorial .
10 factorial .
11 factorial .
12 factorial .
13 factorial .
14 factorial .
15 factorial .
16 factorial .
17 factorial .
18 factorial .
19 factorial .
20 factorial .
#+end_src
* predicates
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
: specialKeyWord? (* word[explainer] -- True or False *)
    duplicate literal literal          == if drop True Exit then
    duplicate literal branch           == if drop True Exit then
    duplicate literal zero?branch      == if drop True Exit then
    duplicate literal false?branch     == if drop True Exit then
    duplicate literal notFalse?branch  == if drop True Exit then
    drop False
    Exit
; defineFunction
#+end_src
* fixnum
** implementation
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
: /mod (* a, b -- quotient, a mod b *)
    mod/ swap
    Exit
; defineFunction

: / (* a, b -- a mod b *)
    /mod drop
    Exit
; defineFunction

: mod (* a, b -- a mod b *)
    mod/ drop
    Exit
; defineFunction

: negate (* n --  -n *)
    Zero swap -
    Exit
; defineFunction
#+end_src
** test
#+begin_src xiaolinguist
10 3 / . (* 3 *)
10 3 mod . (* 1 *)
#+end_src
* ><>< readers
1. when you want to read, say, hex based number in a REPL
   just set the variable ``Base'', and restore it after then.
-----------------------------------------------
字符串 --reader--> 内存中的数据结构
关于各种进制的数的read有多种方案:
1. 为各种不同的进位制定义不同的reader
2. 为各种进位制的数字设计不同的书写格式
   在一个reader中分类处理这些数字
3. 通过改变全局变量Base而实现对一个单一的reader控制
   进而实现对各种不同进位制的数read
一般的语言都采用这种方式2.
而方式3.是最不好的方式 因为它使得代码的语义依赖于语境
我选择方式1.
这样现有的literal就是不够的了
必须根据不同的进制写多种literal
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl

#+end_src
* writers
** note
1. 内存中的数据结构 --writer--> 字符串
2. writer所写出来的东西要能够不经更改就被reader所读入
   如果有这样的要求的话 那么就必须在每个Hex数前面加一个'0'
3. 还要形成对结构化的数据(比如sexp)的直接读写
   这是最重要的
   也就是要形成一对互逆的函数
   + 但是其实不是函数
     因为reader是在解析字符串 然后形成副作用
4. 需要一些够按不同的进制打印出数字来的函数
   我不想要依赖于Base这个全局变量
5. due to the lack of the ``semantic of substitution''
   to achieve the following functions,
   I have to copy lots of code,
   instead of just using lambda-abstraction
** implementation
*** writeDecNumber
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
: writeDecNumberChar (* byte -- *)
    '0' + writeChar
    Exit
; defineFunction

: help,writeDecNumber,pushChars
  (* ... , number of small DecNumbers, fixnum --
    ... , number of small DecNumbers *)
    DecBase mod/
    duplicate zero? if
      drop swap add1 Exit
    then
    xx|swap|x xx|swap|x add1 swap
    help,writeDecNumber,pushChars
    Exit
; defineRecursiveFunction

: help,writeDecNumber,writeChars
  (* ... , number of small DecNumbers -- *)
    duplicate zero? if drop Exit
    then
    sub1 swap writeDecNumberChar
    help,writeDecNumber,writeChars
    Exit
; defineRecursiveFunction

: writeDecNumber (* fixnum -- *)
    Zero swap
    help,writeDecNumber,pushChars
    help,writeDecNumber,writeChars
    Exit
; defineFunction

: writeDecNumber,signed (* fixnum -- *)
    duplicate Zero < if
      '-' writeChar
      negate
    then
    writeDecNumber
    Exit
; defineFunction
#+end_src
*** writeBinNumber
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
: writeBinNumberChar (* byte -- *)
    '0' + writeChar
    Exit
; defineFunction

: help,writeBinNumber,pushChars
  (* ... , number of small BinNumbers, fixnum --
    ... , number of small BinNumbers *)
    BinBase mod/
    duplicate zero? if
      drop swap add1 Exit
    then
    xx|swap|x xx|swap|x add1 swap
    help,writeBinNumber,pushChars
    Exit
; defineRecursiveFunction

: help,writeBinNumber,writeChars
  (* ... , number of small BinNumbers -- *)
    duplicate zero? if drop Exit
    then
    sub1 swap writeBinNumberChar
    help,writeBinNumber,writeChars
    Exit
; defineRecursiveFunction

: writeBinNumber (* fixnum -- *)
    Zero swap
    help,writeBinNumber,pushChars
    help,writeBinNumber,writeChars
    Exit
; defineFunction

: writeBinNumber,signed (* fixnum -- *)
    duplicate Zero < if
      '-' writeChar
      negate
    then
    writeBinNumber
    Exit
; defineFunction
#+end_src
*** writeOctNumber
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
: writeOctNumberChar (* byte -- *)
    '0' + writeChar
    Exit
; defineFunction

: help,writeOctNumber,pushChars
  (* ... , number of small OctNumbers, fixnum --
    ... , number of small OctNumbers *)
    OctBase mod/
    duplicate zero? if
      drop swap add1 Exit
    then
    xx|swap|x xx|swap|x add1 swap
    help,writeOctNumber,pushChars
    Exit
; defineRecursiveFunction

: help,writeOctNumber,writeChars
  (* ... , number of small OctNumbers -- *)
    duplicate zero? if drop Exit
    then
    sub1 swap writeOctNumberChar
    help,writeOctNumber,writeChars
    Exit
; defineRecursiveFunction

: writeOctNumber (* fixnum -- *)
    Zero swap
    help,writeOctNumber,pushChars
    help,writeOctNumber,writeChars
    Exit
; defineFunction

: writeOctNumber,signed (* fixnum -- *)
    duplicate Zero < if
      '-' writeChar
      negate
    then
    writeOctNumber
    Exit
; defineFunction
#+end_src
*** writeHexNumber
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
: writeHexNumberChar (* byte -- *)
    duplicate Ten < if
      '0' + writeChar Exit
    then
    Ten -
    'a' + writeChar
    Exit
; defineFunction

: writeHexNumberChar,capital (* byte -- *)
    duplicate Ten < if
      '0' + writeChar Exit
    then
    Ten -
    'A' + writeChar
    Exit
; defineFunction

: help,writeHexNumber,pushChars
  (* ... , number of small HexNumbers, fixnum --
    ... , number of small HexNumbers *)
    HexBase mod/
    duplicate zero? if
      drop swap add1 Exit
    then
    xx|swap|x xx|swap|x add1 swap
    help,writeHexNumber,pushChars
    Exit
; defineRecursiveFunction

: help,writeHexNumber,writeChars
  (* ... , number of small HexNumbers -- *)
    duplicate zero? if drop Exit
    then
    sub1 swap writeHexNumberChar
    help,writeHexNumber,writeChars
    Exit
; defineRecursiveFunction

: help,writeHexNumber,writeChars,capital
  (* ... , number of small HexNumbers -- *)
    duplicate zero? if drop Exit
    then
    sub1 swap writeHexNumberChar,capital
    help,writeHexNumber,writeChars,capital
    Exit
; defineRecursiveFunction

: writeHexNumber (* fixnum -- *)
    Zero swap
    help,writeHexNumber,pushChars
    help,writeHexNumber,writeChars
    Exit
; defineFunction

: writeHexNumber,capital (* fixnum -- *)
    Zero swap
    help,writeHexNumber,pushChars
    help,writeHexNumber,writeChars,capital
    Exit
; defineFunction

: writeHexNumber,signed (* fixnum -- *)
    duplicate Zero < if
      '-' writeChar
      negate
    then
    writeHexNumber
    Exit
; defineFunction

: writeHexNumber,signed,capital (* fixnum -- *)
    duplicate Zero < if
      '-' writeChar
      negate
    then
    writeHexNumber,capital
    Exit
; defineFunction

#+end_src
*** writeAphNumber
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
: writeAphNumberChar (* byte -- *)
    duplicate Ten < if
      '0' + writeChar Exit
    then
    Ten -
    'a' + writeChar
    Exit
; defineFunction

: writeAphNumberChar,capital (* byte -- *)
    duplicate Ten < if
      '0' + writeChar Exit
    then
    Ten -
    'A' + writeChar
    Exit
; defineFunction

: help,writeAphNumber,pushChars
  (* ... , number of small AphNumbers, fixnum --
    ... , number of small AphNumbers *)
    AphBase mod/
    duplicate zero? if
      drop swap add1 Exit
    then
    xx|swap|x xx|swap|x add1 swap
    help,writeAphNumber,pushChars
    Exit
; defineRecursiveFunction

: help,writeAphNumber,writeChars
  (* ... , number of small AphNumbers -- *)
    duplicate zero? if drop Exit
    then
    sub1 swap writeAphNumberChar
    help,writeAphNumber,writeChars
    Exit
; defineRecursiveFunction

: help,writeAphNumber,writeChars,capital
  (* ... , number of small AphNumbers -- *)
    duplicate zero? if drop Exit
    then
    sub1 swap writeAphNumberChar,capital
    help,writeAphNumber,writeChars,capital
    Exit
; defineRecursiveFunction

: writeAphNumber (* fixnum -- *)
    Zero swap
    help,writeAphNumber,pushChars
    help,writeAphNumber,writeChars
    Exit
; defineFunction

: writeAphNumber,capital (* fixnum -- *)
    Zero swap
    help,writeAphNumber,pushChars
    help,writeAphNumber,writeChars,capital
    Exit
; defineFunction

: writeAphNumber,signed (* fixnum -- *)
    duplicate Zero < if
      '-' writeChar
      negate
    then
    writeAphNumber
    Exit
; defineFunction

: writeAphNumber,signed,capital (* fixnum -- *)
    duplicate Zero < if
      '-' writeChar
      negate
    then
    writeAphNumber,capital
    Exit
; defineFunction
#+end_src
*** usage
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
: . (* fixnum -- *)
    writeDecNumber
    'space' writeChar
    Exit
; defineFunction

: .signed (* fixnum -- *)
    writeDecNumber,signed
    'space' writeChar
    Exit
; defineFunction

: .bin (* fixnum -- *)
    writeBinNumber
    'space' writeChar
    Exit
; defineFunction

: .bin,signed (* fixnum -- *)
    writeBinNumber,signed
    'space' writeChar
    Exit
; defineFunction

: .oct (* fixnum -- *)
    writeOctNumber
    'space' writeChar
    Exit
; defineFunction

: .oct,signed (* fixnum -- *)
    writeOctNumber,signed
    'space' writeChar
    Exit
; defineFunction

: .hex (* fixnum -- *)
    writeHexNumber
    'space' writeChar
    Exit
; defineFunction

: .hex,signed (* fixnum -- *)
    writeHexNumber,signed
    'space' writeChar
    Exit
; defineFunction

: .hex,capital (* fixnum -- *)
    writeHexNumber,capital
    'space' writeChar
    Exit
; defineFunction

: .hex,signed,capital (* fixnum -- *)
    writeHexNumber,signed,capital
    'space' writeChar
    Exit
; defineFunction


: .aph (* fixnum -- *)
    writeAphNumber
    'space' writeChar
    Exit
; defineFunction

: .aph,signed (* fixnum -- *)
    writeAphNumber,signed
    'space' writeChar
    Exit
; defineFunction

: .aph,capital (* fixnum -- *)
    writeAphNumber,capital
    'space' writeChar
    Exit
; defineFunction

: .aph,signed,capital (* fixnum -- *)
    writeAphNumber,signed,capital
    'space' writeChar
    Exit
; defineFunction

: cr (* -- *)
    'newline' writeChar
    Exit
;  defineFunction


: writeSpace (* -- *)
  'space' writeChar Exit
; defineFunction

: writeSomeSpace (* n -- *)
    duplicate zero? if
      drop Exit
    then
    sub1
    writeSpace
    writeSomeSpace
    Exit
; defineRecursiveFunction
#+end_src
** test
*** about number
#+begin_src xiaolinguist
123 321 123321 . . .
-123 321 -123321 .signed .signed .signed

123 321 123321 .bin .bin .bin
-123 321 -123321 .bin,signed .bin,signed .bin,signed

123 321 123321 .oct .oct .oct
-123 321 -123321 .oct,signed .oct,signed .oct,signed

123 321 123321 .hex .hex .hex
123 321 123321 .hex,capital .hex,capital .hex,capital
-123 321 -123321 .hex,signed .hex,signed .hex,signed
-123 321 -123321 .hex,signed,capital .hex,signed,capital .hex,signed,capital

123 321 123321 .aph .aph .aph
123 321 123321 .aph,capital .aph,capital .aph,capital
-123 321 -123321 .aph,signed .aph,signed .aph,signed
-123 321 -123321 .aph,signed,capital .aph,signed,capital .aph,signed,capital
#+end_src
* debugREPL & traceFunction
** note
1. after type tag encoding
   we should handle type error as possible as we could
2. the ``IdentificationOf#Word'' in ``def*'' macros is for ``debuger''
** implementation
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
: countReturnStack (* -- the length of ReturnStack *)
    ReturnStackTop fetchReturnStackPointer -
    Eight /
    sub1 (* for we are in this function call *)
    Exit
; defineFunction

: countArgumtStack (* -- the length of ArgumtStack *)
    ArgumtStackTop fetchArgumtStackPointer -
    Eight /
    Exit
; defineFunction


0 : ReturnStackPosition ; defineVar
0 : ArgumtStackPosition ; defineVar

(* the following two function are as interface *)
: debuger,fetchFromReturnStack (* n -- *)
    sub1 Eight *
    ReturnStackPosition fetch +
    fetch
    Exit
; defineFunction

: debuger,fetchFromArgumtStack (* n -- *)
    sub1 Eight *
    ArgumtStackPosition fetch +
    fetch
    Exit
; defineFunction


:" bye,debuger"
: "bye,debuger" ; defineConstString

: debugerREPL (* unknown -- unknown *)
    readWordForRuntime
    twoDuplicate
    stringDenoteNumber? if
      number drop
      debugerREPL
      Exit
    then
    twoDuplicate
    "bye,debuger" equalString? if
      twoDrop
      Exit
    then
    find duplicate notZero? if
      wordLinkToWordExplainer execute
      debugerREPL
      Exit
    then
    drop
    errorOfReadAndExeute
    debugerREPL
    Exit
; defineRecursiveFunction

:" debuger said: ``Welcome! Hope you find what's wrong.''"
: String,debuger,Welcome ; defineConstString

:" the length of ReturnStack is: "
: String,debuger,theLengthOfReturnStack ; defineConstString

:" the length of ArgumtStack is: "
: String,debuger,theLengthOfArgumtStack ; defineConstString

:" debuger said: ``Good bye! The computation will go on!''"
: String,debuger,Goodbye ; defineConstString

: debuger (* unknown -- unknown *)
   String,debuger,Welcome printString cr
   Three writeSomeSpace String,debuger,theLengthOfReturnStack printString
     countReturnStack writeDecNumber cr
   Three writeSomeSpace String,debuger,theLengthOfArgumtStack printString
     countArgumtStack writeDecNumber cr
   fetchReturnStackPointer ReturnStackPosition save
   fetchArgumtStackPointer ArgumtStackPosition save
   debugerREPL
   String,debuger,Goodbye printString cr
   Exit
; defineFunction

(* ><><>< bug ><><>< *)
(* ``1 fetch'' will cause core dump *)
: identificationOfWord? (* an address in a word -- *)
    duplicate fetch ==
    Exit
; defineFunction

(* ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
 ,* || m(bytes) : name-string  ||
 ,* ||  1 : size of function body  ||
 ,* ||  1 : identification  ||
 ,* ||  1 : link  ||
 ,* ||  1 : type  ||
 ,* ||  1 : address-of-name-string-header  ||
 ,* ||  1 : address-of-explainer  ||
 ,* ||  n : body  ||
 ,*)

: word,body->id
  (* [an address of a cell in a word] -- word[identification] *)
    duplicate
    identificationOfWord? if
      Exit
    then
    CellWidth -
    word,body->id
    Exit
; defineRecursiveFunction

: word,id->name
  (* word[identification] -- string[address, length] *)
    CellWidth Three * +
    fetch duplicate
    add8 swap
    fetch
    Exit
; defineFunction

: word,id->explainer
  (* word[identification] -- explainer *)
    CellWidth Four * +
    fetch
    Exit
; defineFunction

: word,id->body-size
  (* word[identification] -- body-size *)
    CellWidth -
    fetch
    Exit
; defineFunction

: word,id->body-list
  (* word[identification] -- body-list[address, length] *)
    duplicate
      CellWidth Five * +
    swap
    word,id->body-size
    Exit
; defineFunction

: printNameOfExplainer (* explainer -- *)
    duplicate FunctionBodyExplainer == if
      literal FunctionBodyExplainer
      word,body->id
      word,id->name
      printString
      drop Exit
    then
    duplicate VarExplainer == if
      literal VarExplainer
      word,body->id
      word,id->name
      printString
      drop Exit
    then
    duplicate ConstExplainer == if
      literal ConstExplainer
      word,body->id
      word,id->name
      printString
      drop Exit
    then
    duplicate ConstStringExplainer == if
      literal ConstStringExplainer
      word,body->id
      word,id->name
      printString
      drop Exit
    then
    drop
    Exit
; defineFunction

: printFunctionBodyList (* body-list[address, length] -- *)
    duplicate zero? if
      twoDrop Exit
    then
    Six writeSomeSpace
    over fetch word,body->id word,id->name printString cr
    sub1 swap
    CellWidth + swap
    printFunctionBodyList
    Exit
; defineRecursiveFunction

:"  -->  "
: String,withPointer,printFunctionBodyList ; defineConstString

(* the following function is the first function
   on which I must use ``if,else,then'' *)
: withPointer,printFunctionBodyList
  (* [an address of a cell in a word], body-list[address, length] -- *)
  duplicate zero? if
    twoDrop drop Exit
  then
  x|over|xx x|over|xx == false?branch 5
    String,withPointer,printFunctionBodyList printString
    branch 3
    Six writeSomeSpace
  over
  duplicate fetch specialKeyWord? if
    fetch word,body->id word,id->name printString cr
    sub2 swap
    duplicate
    Six writeSomeSpace
    CellWidth + fetch writeDecNumber cr
    CellWidth Two * + swap
    withPointer,printFunctionBodyList
    Exit
  then
  fetch word,body->id word,id->name printString cr
  sub1 swap
  CellWidth + swap
  withPointer,printFunctionBodyList
  Exit
; defineRecursiveFunction


:" traceFunction said: ``Ya! Let's trace a function!''"
: String,traceFunction,Welcome ; defineConstString

:" The function we use to trace is:"
: String,traceFunction,FunctionToTrace ; defineConstString

:" The function be traced to is:"
: String,traceFunction,FunctionBeTracedTo ; defineConstString

:" The size of the body of this function is:"
: String,traceFunction,FunctionBodySize ; defineConstString

:" The body of this function is:"
: String,traceFunction,FunctionBody ; defineConstString

:" traceFunction said: ``The end of a tracing.''"
: String,traceFunction,Goodbye ; defineConstString

: traceFunction
  (* [an address of a cell in a word] -- *)
  String,traceFunction,Welcome printString cr
  duplicate
    Three writeSomeSpace String,traceFunction,FunctionToTrace printString cr
    Six writeSomeSpace fetch word,body->id word,id->name printString cr
  duplicate (* withPointer,printFunctionBodyList still uses original arg *)
  word,body->id
    duplicate
      Three writeSomeSpace String,traceFunction,FunctionBeTracedTo printString cr
      Six writeSomeSpace word,id->name printString cr
    duplicate
      Three writeSomeSpace String,traceFunction,FunctionBodySize printString cr
      Six writeSomeSpace word,id->body-size writeDecNumber cr
    Three writeSomeSpace String,traceFunction,FunctionBody printString cr
    word,id->body-list withPointer,printFunctionBodyList
  String,traceFunction,Goodbye printString cr
  Exit
; defineFunction
#+end_src
** test
#+begin_src xiaolinguist
(* test: traceFunction *)


: kkk (* n, m -- *)
   debuger
   +
   literal 666 .
   .
   Exit
; defineFunction

10 1 kkk
  1 debuger,fetchFromReturnStack  traceFunction
  2 debuger,fetchFromReturnStack  traceFunction
  bye,debuger
(* 666 11 *)


: factorial (* n -- n! *)
    duplicate one? if
      debuger
      Exit
    then
    duplicate sub1 factorial * Exit
; defineRecursiveFunction

10 factorial
  1 debuger,fetchFromReturnStack
    traceFunction
  9 debuger,fetchFromReturnStack
    traceFunction
  10 debuger,fetchFromReturnStack
    traceFunction
  bye,debuger
. (* 3628800 *)



(* about tail call *)
: writeSomeSpace (* n -- *)
    duplicate zero? if
      drop Exit
    then
    sub1
    'space' writeChar
    debuger
    writeSomeSpace
    Exit
; defineRecursiveFunction

100 writeSomeSpace
  1 debuger,fetchFromReturnStack
    traceFunction
  2 debuger,fetchFromReturnStack
    traceFunction
  bye,debuger
(* Ya! you can never say ``bye,debuger'' to this call of ``debuger'' *)
(* when ever you call ``debuger'' in front of a recursive call, this happens *)
basicREPL
countArgumtStack . (* 0 *)
countReturnStack . (* 0 *)
#+end_src
* new lexicographers with debuger
** note
1. the following redefined ``appendWordDescriptionToHere''
   will call debuger if it meets a undefined word
2. there will be syntax-check after the implementation of ``list''
** implementation
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
: printWordList (* WordList[address, the number of words] -- *)    
  duplicate zero? if
    twoDrop
    cr Exit
  then
  Three writeSomeSpace
  tailAndHeadOfWordList printString cr  
  printWordList
  Exit  
; defineRecursiveFunction


:" an error occurs!
appendWordDescriptionToHere said:
   ``I am a tail-recursive-function.
     My function-type is (* WordList[address, the number of words] -- *).
     `defineRecursiveFunction' and `defineFunction' call me.
     The following word is undefined.
     I will print the rest of the WordList and call debuger.''
   --> "
: String,appendWordDescriptionToHere,meetUndefinedWord 
; defineConstString

:" The length of the rest of the WordList is: "
: String,appendWordDescriptionToHere,LengthOfTheRestOfTheWordList
; defineConstString

:" The rest of the WordList is: "
: String,appendWordDescriptionToHere,TheRestOfTheWordList
; defineConstString

: appendWordDescriptionToHere
  (* WordList[address, the number of words] -- *)
  duplicate zero? if
    twoDrop Exit
  then
  tailAndHeadOfWordList
    twoDuplicate String,KeyWord,if equalString? if
      twoDrop
      literal false?branch appendNumberToHere
      Here fetch xx|swap|x
      duplicate appendNumberToHere
      appendWordDescriptionToHere Exit
    then
    twoDuplicate String,KeyWord,then equalString? if
      twoDrop
      x|swap|xx over swap subSave
      appendWordDescriptionToHere Exit
    then
    twoDuplicate stringDenoteNumber? if
      number drop appendNumberToHere
      appendWordDescriptionToHere Exit
    then
    twoDuplicate
    find duplicate notZero? if
      wordLinkToWordExplainer appendNumberToHere
      twoDrop (* drop the string[address, length], which is for debuger *)
      appendWordDescriptionToHere      
      Exit
    then
    drop (* drop the Zero *)
  String,appendWordDescriptionToHere,meetUndefinedWord printString 
  printString cr
  String,appendWordDescriptionToHere,LengthOfTheRestOfTheWordList
  printString duplicate writeDecNumber cr
  String,appendWordDescriptionToHere,TheRestOfTheWordList printString cr 
  printWordList
  debuger
  Exit
; defineRecursiveFunction


: defineFunction
  (* wordList[address, the number of words] -- *)
    tailAndHeadOfWordList
    createWordHeaderForFunction
    setTheSizeOfFunctionBody
    xx|swap|x
    FunctionBodyExplainer appendNumberToHere
    appendWordDescriptionToHere
    addNewWordToDictionary
    Exit
; defineFunction

: defineRecursiveFunction
  (* wordList[address, the number of words] -- *)
    tailAndHeadOfWordList
    createWordHeaderForFunction
    setTheSizeOfFunctionBody
    addNewWordToDictionary
    FunctionBodyExplainer appendNumberToHere
    appendWordDescriptionToHere
    Exit
; defineFunction
#+end_src
* ><>< string literal & array literal (new lexicographers)
** note
1. 比如debuger那一节的函数就包含了很多要打印出来的字符串
   如果这些字符串是不被别的地方引用的
   那么用``defineConstString''来定义它们就是不合理的
2. 要知道被定义到字典中的东西是永远不能被删除的
   因此也就是不需要被垃圾回收的
   所以让这gc去mark这些量是不合理的
   所以就像在汇编中一样
   每个函数中的结构化的literal量 就是这个函数的数据段
   在编译函数的时候应该把这些数据也写到字典里
3. 因为 使用string literal的方式是与它的实现方式无关的
   所以 我先接受目前这种用``defineConstString''来使用string literal的方式
   我将先实现 multi-pass
   这样 string literal 和 array literal 就简单多了
   之后再重写相关的函数就行了 
* --------------------------------------------------
* type tag encoding (dynamic type system)
** note
1. atom :
   TypedValue[valus, type tag]
2. non-atom :
   TypedValue[address, type tag]
--------------------------------------------------
about xiaolinguist words,
I make the following conventions:
1. ><><>< named-with-dashes instead_of_underscores CamelCase
2. 所有处理带类型的值的函数以'-'为词界 并且单纯地小写
   比如: list-copy 类型总写在前面
   + 注意这些函数一定都是在forth系统中实现的
3. 而带类型的常量和变量也以'-'为界
   第一个词的首字母必须大写
   其他词的首字母按需要大写(那些小的介词可以小写)
   比如: Current-Pair 类型总写在后面
   每个这种常量因为都至少要入栈两个值
   所把它们统一地实现为函数也就是defineFunction来定义
4. 上面的约定无疑是在说
   为了区分两类函数
   其中处理带类型标签的值的那类函数必须不能是单个的词
   因为如果词界'-'不出现 就没法作区分
5. 类型本身用'<>'表示 比如: <bool>和<pair>和<fixnum>和<type>
   这些值是基础forth系统中的常量
   它们代表type-tag的值
   + 虽然<bool>是一个名词 但是还是使用小写了
     因为<>已经足够用来区分语义了 并且这种名词非常特殊
6. 用户在定义新的数据类型的时候
   需要以文档的形式描述清楚数据类型是如何用列表实现的
   以及数据类型的接口
   + 之后当实现了类型推到系统之后
     就将不是用文档
     而是用内置的数据结构来描述数据类型的这些性质了
--------------------------------------------------
1. 我发现这样的对类型的编码比scheme中所使用的要灵活的多
   现在我可以真正写出严格的谓词来区分<pair>,<list>,<graph>等等
   用列表来实现的语义上不同的数据结构
   这在古典的scheme中是没法被真正地有效区分的
2. 但是这种编码方式也允许个给值乱贴标签
3. 为了gc其实只需要区分 <pair> 和 non <pair>
4. 考虑下面的谓词的返回值 就发现出现了语义过载(semantic overload)现象
   即有很多方式能够表示同一种语义
   现在我不得不忍受两对真值
   一对是False与True 一对是False-Bool与True-Bool
   我不得不使用两种if ???
   + 或者 swap if drop ... then drop ...
     这样就能达到第二种if所需要的效果
     但是先忍受这种使用if的方式
   语义过载确实是可怕的现象
   这是为了使得我的forth系统同时具有动态类型和低级性
   我不知到这种现象如何能被避免
5. 注意: 我不能简单地用 swap if drop 来定义新的"if"
   而用 then drop 来定义新的"then"
   也就是说使用简单而直观的代换模型
   并不能形成对这个forth系统的正确理解
** implementation
1. 下面只是简单的用数字来给类型编码而已
2. 一共有64 bits可用
3. 前32 bits用来区分``就机器而言的语义''
   即 机器对这个数据类型的实现方式
   0 -- 64 bits fixnum
   1 -- 64 bits address of pair
   2 -- 64 bits address of string
4. 后32 bits用来区分``就人类而言的语义''
   即 人类对这个数据类型的理解方式
5. 当用户想要定义个数据类型的时候
   首先 他需要选择一种机器实现他想要定义的数据类型的方式
   其次
   如果他选择一个已有的``就人类而言的语义''
   那么他就将给已有的数据类型增加一个别名
   如果他想要设置一个新的``就人类而言的语义''
   那么他就总是能够把他所定义的新数据类型和其他的所有的数据类型区分开来
6. 注意 当机器对一个东西的实现方式不同的时候
   人是不能给这种东西赋予相同的语义的
7. 有这样的无聊区分其实是因为:
   每种用<pair>来实现的新的数据结构
   都必须完全继承<pair>在垃圾回收方面的性质
   是这样的吗 ??? 这种使用方式很麻烦吗 ???
   如果使用起来麻烦的话 就必须用心设计用户接口
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
HexBase Base save
0_ffff_ffff_0000_0000 : TypeMaskOfSemanticForMachine ; defineConst
  0000_0000_ffff_ffff : TypeMaskOfSemanticForHuman   ; defineConst
DecBase Base save

(* <fixnum> must be Zero *)
0 : <fixnum> ; defineConst
1 : <bool>   ; defineConst
2 : <type>   ; defineConst
3 : <char>   ; defineConst
4 : <symbol> ; defineConst
5 : <substring> ; defineConst
6 : <null>   ; defineConst

0 : Null ; defineConst


: <fixnum-like>? (* type -- True or False *)
    TypeMaskOfSemanticForMachine bitwiseAnd
    <fixnum> ==
    Exit
; defineFunction

: True-Bool  True  <bool> Exit ; defineFunction
: False-Bool False <bool> Exit ; defineFunction


HexBase Base save
1_0000_0000 : <pair>   ; defineConst
1_0000_0001 : <string> ; defineConst
DecBase Base save

: <pair-like>? (* type -- True or False *)
    TypeMaskOfSemanticForMachine bitwiseAnd
    <pair> ==
    Exit
; defineFunction

: <not-pair-like>? (* type -- True or False *)
    TypeMaskOfSemanticForMachine bitwiseAnd
    <pair> =/=
    Exit
; defineFunction


:" <fixnum>" : String,<fixnum> ; defineConstString
:" <bool>"   : String,<bool>   ; defineConstString
:" <type>"   : String,<type>   ; defineConstString
:" <char>"   : String,<char>   ; defineConstString
:" <symbol>" : String,<symbol> ; defineConstString
:" <pair>"   : String,<pair>   ; defineConstString
:" <string>" : String,<string> ; defineConstString
:" <substring>" : String,<substring> ; defineConstString
:" <null>" : String,<null> ; defineConstString
:" <unknow>" : String,<unknow> ; defineConstString

: printTypeTag (* type-tag -- *)
  duplicate <fixnum> == if String,<fixnum> printString drop Exit then 
  duplicate <bool>   == if String,<bool>   printString drop Exit then 
  duplicate <type>   == if String,<type>   printString drop Exit then 
  duplicate <char>   == if String,<char>   printString drop Exit then 
  duplicate <symbol> == if String,<symbol> printString drop Exit then 
  duplicate <pair>   == if String,<pair>   printString drop Exit then 
  duplicate <string> == if String,<string> printString drop Exit then 
  duplicate <substring> == if String,<substring> printString drop Exit then 
  duplicate <null> == if String,<null> printString drop Exit then 
  String,<unknow> printString drop Exit 
; defineFunction
#+end_src
* dictionary operations
** >< note
** implementation
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
(*
 ,* a word in the dictionary [unit : CellWidth = 8 bytes]
 ,*   ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
 ,*   ||  m : name-string  ||
 ,*   ||  1 : SizeOfFunctionBody ||
 ,*   ||  1 : identification  ||
 ,*   ||  1 : link  ||
 ,*   ||  1 : type  ||
 ,*   ||  1 : address-of-name-string-header  ||
 ,*   ||  1 : address-of-explainer  ||
 ,*   ||  n : body  ||
 ,* where
 ,*   ||  1 : type  ||
 ,* ==
 ,*   | type-bit-63 | ... | type-bit-1 | type-bit-0 |
 ,* type-bit-0 is for HiddenWord
 ,* type-bit-1 is for VariableOfTypedValue [DynamicVar]
 ,*)

: lastWordInTheDictionary? (* word[address of link] -- True or False *)
    zero? Exit
; defineFunction

: nextWordInTheDictionary
  (* word[address of link] -- next-word[address of link] *)
    fetch Exit
; defineFunction

: fetchWordType (* word[address of link] -- WordType *)
    add8 fetch
    Exit
; defineFunction

: saveWordType (* word[address of link], WordType -- *)
    swap add8 save
    Exit
; defineFunction


0 : offsetForHiddenWord          ; defineConst
1 : offsetForDynamicVariableWord ; defineConst

: dynamicVariableWord? (* word[address of link] -- True or False *)
    fetchWordType offsetForDynamicVariableWord fetchBit one?
    Exit
; defineFunction
#+end_src
** test
#+begin_src xiaolinguist
: ~ (* word[address of link] -- word[address of link] *)
    duplicate dynamicVariableWord? .
    (* duplicate lastWordInTheDictionary? . *)
    nextWordInTheDictionary
  Exit
; defineFunction

FirstWordInDictionary fetch

~ ~ ~ ~ ~ ~ ~ ~ ~ ~
~ ~ ~ ~ ~ ~ ~ ~ ~ ~

#+end_src
* incremental-gc & <pair> & <string>
** note
1. my gc is a marking-gc, a incremental-gc,
   and it takes time proportional to the number of reachable cells,
   the time complexity is independent of the number of garbage cells.
   (it is still a marking-gc !!)
   freeing a heap cell by garbage collection is cheaper
   (if there is enough memory) than popping a stack.
   ><><>< 其实不是的因为把寻找下一个自由的pair所消耗的时间加上之后
   分配一个pair的平均时间复杂度就增加了
   所以这个gc只不过是渐进性更强而已
   因为它把更多原本需要在gc周期点进行的计算分配到了别的地方
2. 那么 如果是这样的话我根本就没有理由不使用copy-gc了 ???
   是这样么?? marking-gc 的优点在哪里呢 ??
   多引用的时候不用改变引用点 !
3. my gc is a incremental-gc
4. 渐进垃圾回收的目的是:
   不要让取一个<non-reachable>节点给构造子cons的时间太长
5. 如果只考虑<pair>
   那么就人类的理解而言
   被操作的对象是一个二叉有向图
   这个有向图的节点个数是个常数
6. 就机器的理解而言
   被操作的对象是一个PairConstruction所组成的数组
   这个数组的长度是个常数(SizeOfPairConstructionsArray)
   每一个PairConstruction对应于有向图中的一个节点
   每一个PairConstruction的car和cdr部分 分别对应于一个节点的两个出边
   一个出边可以连接到一个atom 或者 有向图中的另外一个节点
   + 被链接到的atom并不被看作图的节点
7. 要知道 既然是PairConstruction所组成的数组
   那么从人类的角度来说
   那个二叉有向图中的点之间就是有一个全序关系的
8. 以我的方式实现的动态内存管理其实已经不适合被称作垃圾回收了
   它的工作方式是这样的:
   1) 它是有一个工作周期的
      除了第一个工作周期之外
      一个工作周期的开始和结束都是在
      cons把LastPairConstruction这块内存空间分配给程序之后
      + 我把这个地方称为``工作循环点''
   2) 有三个部分在配合工作来完成我所需要让它们完成的任务
      一个marking 一个finding 还有一个cleaning
      其中cleaning的工作是伴随finding而进行的
      而marking会在这个工作周期中标记出那些
      它认为不能在下一个工作周期被finding找到的PairConstructions
      要知道在上面的二叉有向图中
      指定一些根节点
      就赋予了每个节点一个性质: <reachable> 或 <non-reachable>
      reachable当热是就那些被指定的根节点而言的
      而marking所做的就是在这个工作周期中标记出那些它认为<reachable>的点
      然后剩下的点就是<non-reachable>的
      也就是可以被finding找到而被重新利用的
   3) 值得注意的是
      为了看一个点能不能被重新分配
      我需要的只是去肯定这个点是<non-reachable>的
      但是 给我一个点 我并不是是去直接判断它是不是<non-reachable>
      因为这样太消耗计算能力了
      我所做的是去标记出所有<reachable>的点
      然后我就知道哪些是<non-reachable>的点了
   4) marking其实有点笨
      如果它能精确的标记出所有的<reachable>的点就最好了
      但是其实
      每次它所标记出的不能被下一个工作周期的finding找到的点中
      在包含了所有的<reachable>的点的同时
      也可能会错误地包含了很多<non-reachable>的点
      + 但是只要它能标记出所有的<reachable>的点
        那么它的这点笨拙就不会影响整个工作的正确性
      + 并且被它在这个工作周期中错误地标记了的<non-reachable>的点
        总是有机会在下一个工作周期被marking认为是<non-reachable>的而不去标记
        也就是说marking总是有在下一个工作周期改正自己错误的机会
        所以也许marking没有笨到无可救药的地步
   5) 首先每个PairConstruction中包含三个可以被``染色''的bit
      1. 一个为本次工作周期中的marking
         这是为了下一个工作周期中的finding准备的
      2. 一个为本次工作周期中的finding
         在这个工作周期中finding用完它们之后它们就没用了
         在下一个工作周期就可以把它们交给cleaning来处理了
      3. 一个为本次工作周期中的cleaning
         这是为了下一个工作周期中的marking准备的
   6) 所以在每个工作循环点
      只需要对这三个bits做一个置换就可以了
      所使用的置换显然是三阶置换群中的两个三循环置换之一
   7) marking和finding的工作是相互独立的
      这在于它们读写的color-bit不同
      还在于finding的工作被CurrFreePairConstruction这个全局变量来指示
      + 也就是说finding依赖于上面提到的二叉有向图的节点之间的全序关系
      而marking的工作被GreyPairStack这个栈中的元素和这些元素的个数而指示
9. marking对一个PairConstruction的标记就在于
   去把这个PairConstruction的为marking所准备的bit染黑(即 把这个bit set为1)
   而GreyPairStack是用来记录marking的工作进度的
   用black,grey,white三种颜色去描述marking的工作方式就很形象
10. ><><>< 有一个问题
    在每个工作周期循环点
    在初始化GreyPairStack的时候
    ArgumtStack中已经保存的pair并不会被加入GreyPairStack !!!
    ><><>< 我必须引入额外的机制吗 ???
    初始化GreyPairStack的时候 不可能到ArgumtStack中去把所有的pair都找出来
    但是我好像必须要这样做才行
    要注意每次调用cons的时候
    都可能是在一个工作循环点
    因而触发对GreyPairStack的初始化
    但是每次调用cons的时候栈可能已经被递归地非常深了
    + 所有这些困难的产生都在于我没有用一个free-list来记录能被我使用的点
    所以这种寻找可能会非常消耗计算
    并且我所使用的动态类型系统并不足以以严格的方式来判断那些东西是<pair>
    如果重新初始化GreyPairStack的过程中没有考虑到栈中的这些cons那会有什么后果呢?
    这些cons其实是可以被引用到的
    毕竟它们在栈中呢
    但是finding所见的它们却是可以被重新利用的
    还有一个问题就是如果我把栈中的cons初始化入了GreyPairStack中
    那么marking就可能错误标记很多节点了
    因为 毕竟这些在栈中的点都可能只有很短的生存时间而已
    在一个工作周期循环点
    栈中的这些cons应该是在下一个工作周期的finding所不能找到的点
    而不是下一个功能工作周期marking应该标记的点
    所以初始化GreyPairStack的时候不用将这些东西全部都放到GreyPairStack中
    将这些cons的color-bit-for-finding涂黑就行了
    这样就保证了整个工作的正确性
    但是每当垃圾回收的时候还是要扫描整个ArgumtStack !!!
    >< 我先这样来实现我的gc系统吧
11. 一个工作周期结束之后
    在工作周期循环点
    <reachable-note> 是那些不应该被下一个工作周期的finding找到的点
    而我所设计的gc系统中
    不能被下一个工作周期的finding找到的点有两个来源
    一个是上一个工作周期的marking所标记的黑点
    一个是在工作周期循环点的时候 ArgumtStack中的所有cons
    所以在工作周期循环点
    所需要做的额外工作就是在ArgumtStack中找到所有的cons
    然后把它们为下一个工作周期的finding涂黑
12. >< gc的这种工作方式是可以接受的吗 ???
    这就需要更多的测试和实际的使用才能知道
    也许是可以的
    因为ArgumtStack的深度应该总是远远小于整个PairConstructionsArray的大小
13. 上面扫描整个栈的那些计算
    对与forth的垃圾回收器来说可能是不可避免的
    这种不可避免性其实来源于我的垃圾回收器的这样一种性质
    那就是工作循环点的位置是固定的
    在工作循环点有要很多额外的工作要做
    其实在我遵从的垃圾回收器的这中设计方式下的垃圾回收器
    总是要在工作周期的循环点集中地做很多工作的
    而渐进性就在于把这些被集中地做的工作中的某一些分散到别的地方
    我完全分散了marking部分工作
    并且我完全消除了传统的垃圾回收器中的sweep部分的工作
    但是我的设计也可能是失败的
    因为看来我引入了(是我引入的吗??)其他的需要被集中进行的工作
14. 在栈中的或者是保存在变元中的cons
    永远不会被垃圾回收器回收
15. ><><>< 也许我应该仔细学习更多的别的gc的设计与实现方式
16. ><><>< 关于上面的问题
    forth系统中如何使用局部变量 !!!
    关于forth中的局部变量的思考是否能启示我解决上面的问题的更好的方法
17. 总结一下数据类型:
    <value>是我的forth系统中所有的动态类型的量的集合
    而<atom>是这些动态的量中除了<pair>之外的所有动态类型的量的集合
    #+begin_src bnf
    <value> ::= <pair> | <atom>
    <pair>  ::= <reachable-note>
    <reachable-note>
            ::= 可能是从根节点可以引用到的点
                  比如: (car <variable>)
                也可能是在栈中的点
                  比如: (cons <value> <value>)
    #+end_src
    上面的(cons <value> <value>)其实就是把一个<pair>返回到栈中
    而这些在栈中的<pair>就被看作是<reachable-note>
18. 促使marking去标记一个PairConstruction的列表处理操作
    有且只有下面两种(三个)(涉及到set-car!&set-cdr!的时候我只用set-car!作为例子)
    我同时用scheme和xiaolinguist这两种语言来描述这些操作
    1) scheme :
       #+begin_src scheme
       (set-car! <pair> <value>)
       #+end_src
       xiaolinguist :
       #+begin_src xiaolinguist
       <pair>[address, type] <value>[value, type] set-car!
       #+end_src
       + 如果<pair>的color-bit-for-marking是黑色的
         又如果<value>也是<pair>
         那么就尝试去染灰<pair>的color-bit-for-marking
    2) scheme :
       #+begin_src scheme
       (set! <variable> <pair>)
       #+end_src
       xiaolinguist :
       #+begin_src xiaolinguist
       <variable>[address] <pair>[address, type] set!
       #+end_src
       + 如果<value>是<pair>
         那么就尝试去染灰<pair>的color-bit-for-marking
19. 申请一个可用的内存空间(一个自由的PairConstruction)
    并且促使finding去寻找下一个可用的内存空间的列表处理操作
    有且只有下面一个
    scheme :
    #+begin_src scheme
    (cons <value> <value>)
    #+end_src
    xiaolinguist :
    #+begin_src xiaolinguist
    cons <value>[value, type] set-car!
         <value>[value, type] set-cdr!
    #+end_src
    + 在古典的lisp中每当构造子cons像上面这样构造完一个pair之后
      都只有且只有一次机会来引用所构造的pair
      那就是在嵌套的sexp中调用cons的那个位置上
      那个位置上返回的值就是所构造的pair
    + 而在我的xiaolinguist中引用那个cons的方式极为灵活
    + 比如 如果我要编译一个类scheme语言到xiaolinguist的话
      我就可以又类似下面的语法
      在下面的两个<sexp>中也可以引用到这个cons将要构建好的pair
      #+begin_src scheme
      (cons :set-address-to kkk
            :car <sexp>
            :cdr <sexp>)
      #+end_src
    + >< 但是一个问题是上面的语法用到了局部变量
      不知到局部变量的问题如何在类forth语言中解决 ???
20. forth是如此灵活以至于我根本没必要实现common-lisp中的那种广义引用
    比如为了实现类似的效果 我复制一下被解构子解构的pair的地址就行了
21. 在使用scheme的时候我从来没有想像过对数据结构的使用能够像在forth中这样灵活
    但是就目前的实现进度而言与scheme相比我还缺少:
    1) λ-abstraction
    2) 局部变量
    3) 局部变量与λ-abstraction是等价的吗 ???
       我已经知道用λ-abstraction(closure)就可以实现局部变量了
       反过来也行吗 ???
    也许我可以在forth中实现这些东西
    因为我能够单纯地用列表处理来实现整个λ-cal(惰性求值的)
    用列表处理实现λ-cal之后 我只需要实现一个类似apply的函数就行了
    可以说forth的语法是就``函数的复合''而优化的
    而scheme的语法是就``函数的作用''而优化的
    但是两种语义显然是能够互相表示的
    要知道 当把forth中的所有的word都理解为一栈为参数的一元函数的时候
    其实那些单纯地把一个量入栈的函数 也可以被理解为参数
    而后面的函数与这些函数的复合可以被理解为这些函数对参数的作用(当然了,这才是古典的理解)
    也就是说对forth的理解是非常灵活的
    + 对于被当作二元运算的二元函数来说
      只有当这种二元运算满足结合律的时候使用infix才是令人满意的
      + 比如: + * max min gcd 等等
      这正是joy所想要表达的
    + 对结合律的证明 可以被转化为对交换性的证明
      #+begin_src
      (p+q)+r == p+(q+r)  <==>  pq+r+ == pqr++  <==>  +r == r+
      或者:
      (p + q) + r  ==  p + (q + r)  <==>
      p q + r +    ==  p q r + +    <==>
      + r          ==  r +
      #+end_src
    + 再考虑一下别的运算律 简直有趣极了
      #+begin_src
      分配律(对一种同态变换的描述):
      中缀表达式: (a+b)*c == (a*c)+(b*c)  <==>
      后缀表达式: ab+c* == ac*bc*+  <==>  ???
      但是至少我知道 +(c*) =/= (c*)+
      要想填上上面的问号 可能就需要 λ-abstraction 的抽象性
      否则我根本没法描述某些东西

      交换律:
      a+b == b+a  <==>  ab+ == ba+  <==>  ab == ba

      +* =/= *+
      abc+*  <==>  a*(b+c) =/= a+(b*c) <==> abc*+
      #+end_src
    + 把后缀表达式考虑为对栈的操作是自然的
      并且这样的理解方式所带来的一个很大的好处就是实在性
      这就又回到了哪个``小孩玩积木''的比喻了
      比如我的十三岁的弟弟可以问我"那个函数的参数是从哪来的?"
      我就告诉他是从栈里拿出来了
      "那个函数的结果去哪了?"
      我就告诉他结果放回到栈里了
      数学 和 编程 就都像一个小孩在玩积木一样
      对了 他还可以问我这个函数是从哪里来的
      我就说是从字典里找来的
22. forth是最有趣的结合代数
    利用这个结合代数似乎可以模拟任何代数结构(甚至是非结合代数)
    1) 比如上面对函数作用的模拟(尽管函数的作用不是结合的)
    2) 又比如我可以把两个矩阵入栈
       然后一个矩阵乘法函数可以像"*"乘两个数一样为我返回矩阵的积(尽管矩阵乘法不是结合的)
    3) 又比如列表处理可以用来实现digrap
       而digrap已经出离代数的范畴之外了
       但是它还是能够被forth的结合代数所模拟
23. 如果让我写scheme编译器的话 我会让每个表达式都返回一个值
    正因为如此 在xiaolinguist中
    我才把set!,set-clr!,set-car!,set-cdr!等等函数实现为它们现在的这种样子
** note about <string>
1. 可以用压缩式的垃圾回收器来实现对字符串的动态内存管理
   因为string的长度可变
   所以简单的marking-gc是不适用的
2. 在marking工作的时候 如果看见<string>
   就更改引用点 并且复制字符串
   + makeing是知道引用点是哪个的
3. 如果string的堆比pair的堆先耗尽
   这时就必须重启gc
   所以应该把string的堆设置的充分大 以避免这种情况
4. 一个问题是
   应该如何在 比如说 定义一个字典中的函数的时候
   在这个定义中使用string-literal还有list-literal
   比如debuger那一节的函数就包含了很多要打印出来的字符串
   如果这些字符串是不被别的地方引用的
   那么用``defineConstString''来定义它们就是不合理的
5. 要知道被定义到字典中的东西是永远不能被删除的
   因此也就是不需要被垃圾回收的
   所以让这gc去mark这些量是不合理的
   所以就像在汇编中一样
   每个函数中的结构化的literal量 就是这个函数的数据段
   在编译函数的时候应该把这些数据也写到字典里
6. 所以 string-literal 和 string-processing
   采用了两种不同的方式来使用string
   string-processing 中所使用的string必须是动态分配内存的
   ``readStringInToBuffer'' 这个函数所提供的 string buffer
   是一种能力非常有限的动态分配内存的方式
   而这里的 利用gc来实现的<string> 是一种更好的方式
7. string[address, length] 之外另一种字符串的表示方式是
   [address, <string>]
   此时address的前面必须保存length
   我用4byte来保存这个length       
** implementation of dynamic-allocation of string
*** try,copy-substring,from->to
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
StringHeap1 : Variable,StringHeap,from ; defineVar
StringHeap2 : Variable,StringHeap,to   ; defineVar

StringHeap1 : CurrFreeStringAddress,from ; defineVar
StringHeap2 : CurrFreeStringAddress,to   ; defineVar

(* 
 ,* little experiment:
 ,*   HexBase Base save 
 ,*     10_10_00_00 fetchArgumtStackPointer 
 ,*     duplicate
 ,*       1 swap saveByte 
 ,*     duplicate
 ,*       1 swap add1 saveByte 
 ,*     fetch .hex .hex
 ,*   DecBase Base save 
 ,*)

: fetchFourBytes (* address -- value *)
  Zero fetchArgumtStackPointer
  x|over|xx swap
  Four copyByteString 
  swap drop
  Exit
; defineFunction

: saveFourBytes (* value, address -- *)
  swap fetchArgumtStackPointer 
  x|over|xx  
  Four copyByteString
  twoDrop 
  Exit
; defineFunction

(* 
 ,* test:
 ,*   HexBase Base save 
 ,*    10__10_10_00_00 fetchArgumtStackPointer 
 ,*    duplicate
 ,*      1 swap saveByte 
 ,*    duplicate
 ,*      1 swap add1 saveByte 
 ,*    fetchFourBytes .hex .hex
 ,*    10__10_10_00_00 fetchArgumtStackPointer 
 ,*    duplicate
 ,*      22_22_22_22 swap saveFourBytes
 ,*    fetchFourBytes .hex .hex
 ,*   DecBase Base save 
 ,*)

: getLengthOfString (* string[address] -- length *)
  sub4 fetchFourBytes
  Exit
; defineFunction

: stringIn?StringHeap,from (* string[address] -- True or False *)
  Variable,StringHeap,from fetch
  over over
  SizeOfStringHeap +  <
  xx|swap|x  >=
  bitwiseAnd
  Exit
; defineFunction

: stringIn?StringHeap,to (* string[address] -- True or False *)
  Variable,StringHeap,to fetch
  over over
  SizeOfStringHeap +  <
  xx|swap|x  >=
  bitwiseAnd
  Exit
; defineFunction

: withLength,copyByteString 
  (* source address, destination address, length -- *)
  duplicate x|over|xx saveFourBytes
  swap add4 swap
  copyByteString
  Exit
; defineFunction

: try,copy-substring,from->to
  (* [address, <substring>] -- [address, <substring>] *)
  (* 
   ,* duplicate <substring> =/= if 
   ,*   Exit    
   ,* then
   ,*)
  over duplicate
  stringIn?StringHeap,to if
    drop Exit
  then
  CurrFreeStringAddress,to fetch
  over getLengthOfString
  withLength,copyByteString
  (* set return value *)
  CurrFreeStringAddress,to fetch add4
  |123->321|
  (* update CurrFreeStringAddress,to *)  
  getLengthOfString add4
  CurrFreeStringAddress,to addSave   
  Exit
; defineFunction

(* test: *)
(* 
 ,* CurrFreeStringAddress,to fetch
 ,*   s" kkk " twoDuplicate printString (\* kkk *\)
 ,*   drop <substring>
 ,*   try,copy-substring,from->to 
 ,*   twoDrop
 ,* add4 duplicate
 ,* getLengthOfString
 ,* printString (\* kkk *\)
 ,*)


: try,copy-substring,from->to,forCar
  (* [address, <pair-like>] -- [address, <pair-like>] *)
  over fetchTwo (* this line is as car *)
  duplicate <substring> =/= if 
    twoDrop (* drop car *)
    Exit    
  then
  try,copy-substring,from->to
  x|over|xxx saveTwo (* this line is as set-car! *)
  Exit
; defineFunction

: try,copy-substring,from->to,forCdr
  (* [address, <pair-like>] -- [address, <pair-like>] *)
  over CarBytesSize + fetchTwo (* this line is as cdr *)
  duplicate <substring> =/= if 
    twoDrop (* drop cdr *)
    Exit
  then
  try,copy-substring,from->to
  x|over|xxx CarBytesSize + saveTwo (* this line is as set-cdr! *)
  Exit
; defineFunction


(* 
 ,* [* s" kkk" drop <substring>
 ,*    s" ppp" drop <substring> *]
 ,* 
 ,* twoDuplicate
 ,*   car printTypeTag cr (\* <substring> *\)
 ,*   duplicate getLengthOfString
 ,*   printString cr (\* kkk *\)
 ,* twoDuplicate
 ,*   cdr printTypeTag cr (\* <substring> *\)
 ,*   duplicate getLengthOfString
 ,*   printString cr (\* ppp *\)
 ,* 
 ,* twoDuplicate
 ,*   car drop .hex cr (\* >< *\)
 ,* twoDuplicate
 ,*   cdr drop .hex cr (\* >< *\)
 ,* 
 ,* twoDuplicate
 ,*   try,copy-substring,from->to,forCar
 ,*   try,copy-substring,from->to,forCdr
 ,* 
 ,* twoDuplicate
 ,*   car printTypeTag cr (\* <substring> *\)
 ,*   duplicate getLengthOfString
 ,*   printString cr (\* kkk *\)
 ,* twoDuplicate
 ,*   cdr printTypeTag cr (\* <substring> *\)
 ,*   duplicate getLengthOfString
 ,*   printString cr (\* ppp *\)
 ,* 
 ,* (\* the two hex numbers must be different *\)
 ,* twoDuplicate
 ,*   car drop .hex cr (\* >< *\)
 * twoDuplicate
 *   cdr drop .hex cr (\* >< *\)
 * 
 * twoDrop
 *)
#+end_src
*** readString
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
: readNonStringEndingChar (* -- FirstNonBlankChar or Zero *)
  readChar
  duplicate '"' == if
    drop Zero
  then Exit
; defineFunction

: help,readString,loop (* begin-address -- end-address *)
  readNonStringEndingChar
  duplicate zero? if 
    drop Exit
  then
  over saveByte
  add1
  help,readString,loop
  Exit
; defineRecursiveFunction

: readString (* -- string[address, length] *)
  CurrFreeStringAddress,from fetch add4
  duplicate (* leave begin-address *)
    help,readString,loop  
  duplicate (* leave end-address *)
    CurrFreeStringAddress,from save
  over -
  duplicate (* return: length *)
  x|over|xx (* return: address *)
  sub4 saveFourBytes
  Exit
; defineFunction

: s" (* -- string[address, length] *)
  readString Exit
; defineFunction

(* test: *)
(* s" 123 kkk aaa !!! @@@ ###" printString *)
#+end_src
** implementation of gc & <pair> & <string>
*** the construction & clr, car, cdr
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
(* the construction of pair : [unit : byte]
 ,* clr:
 ,*     ||  1 : color     ||
 ,* car:
 ,*     ||  8 : type tag  ||
 ,*     ||  8 : value     ||
 ,* cdr:
 ,*     ||  8 : type tag  ||
 ,*     ||  8 : value     ||
 ,*)

(* the following constants are defined in assembler:
 ,* ConsBytesSize == 33
 ,* ClrBytesSize  ==  1
 ,* CarBytesSize  == 16
 ,* CdrBytesSize  == 16
 ,*)

:" clr said:
   ``My function-type is (* [address, <pair-like>] -- color-byte *).
     But the type of the TypedValue I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,clr,typeError ; defineConstString
: clr (* [address, <pair-like>] -- color-byte *)
  duplicate <not-pair-like>? if
    String,clr,typeError printString  
    duplicate printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  sub1 fetchByte Exit
; defineFunction


:" car said:
   ``My function-type is (* [address, <pair-like>] -- [value, type] *).
     But the type of the TypedValue I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,car,typeError ; defineConstString
: car (* [address, <pair-like>] -- [value, type] *)
  duplicate <not-pair-like>? if
    String,car,typeError printString  
    duplicate printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  fetchTwo Exit
; defineFunction


:" cdr said:
   ``My function-type is (* [address, <pair-like>] -- [value, type] *).
     But the type of the TypedValue I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,cdr,typeError ; defineConstString
: cdr (* [address, <pair-like>] -- [value, type] *)
  duplicate <not-pair-like>? if
    String,cdr,typeError printString  
    duplicate printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  CarBytesSize + fetchTwo Exit
; defineFunction
#+end_src
*** notation
Lisp was originally implemented on the IBM 704 computer, in the late 1950s.
The 704 hardware had special support for
splitting a 36-bit machine word into four parts:
1. address part   : 15 bits
2. decrement part : 15 bits
3. prefix part    : 3 bits
4. tag part       : 3 bits
Precursors to Lisp included the following functions:
(The term "register" in the following context refers to "memory location")
1. car : Contents of the Address part of Register number
2. cdr : Contents of the Decrement part of Register number
3. cpr : Contents of the Prefix part of Register number
4. ctr : Contents of the Tag part of Register number
--------------------------------------------------------
in my xiaolinguist, for my PairConstruction
I introduce the following c*r functions:
(maybe more in the future, if needed)
1. clr : color byte
   for garbage-collection
2. car : contents of the address part of a PairConstruction
   as the first typed-value of a pair
3. cdr : contents of the decrement part of a PairConstruction
   as the second typed-value of a pair
*** color & set-clr!
cons的每个着色点上 只涂黑白两种颜色就足够了
而那些被记录在GreyPairStack中的黑色的pair就被认为是灰色的pair
灰色的pair其实代表那些在那个蔓延着的黑色的子图前端的点
这些点可能在黑白的交界处 也可能不在黑白的交界处 这是不确定的
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
0 : White ; defineConst
1 : Black ; defineConst

(* set three offsets used by fetchByte, setBit, clearBit *)
0 : VariableColorOffsetForFinding  ; defineVar
1 : VariableColorOffsetForMarking  ; defineVar
2 : VariableColorOffsetForClearing ; defineVar
: ColorOffsetForFinding  VariableColorOffsetForFinding  fetch Exit ; defineFunction
: ColorOffsetForMarking  VariableColorOffsetForMarking  fetch Exit ; defineFunction
: ColorOffsetForClearing VariableColorOffsetForClearing fetch Exit ; defineFunction

:" set-clr! said:
   ``My function-type is (* [address, <pair-like>], color-byte -- [address, <pair-like>] *).
     But there must be something wrong with the arguments that I received.
     If I view the second argument as a type-tag,
     it will be as the following,
     I will not touch it and call debuger.''
   --> "
: String,set-clr!,typeError ; defineConstString
: set-clr! (* [address, <pair-like>], color-byte -- [address, <pair-like>] *)
  over duplicate  <not-pair-like>? if
    String,set-clr!,typeError printString  
    printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag *)
  x|over|xx sub1 saveByte Exit
; defineFunction
#+end_src
*** marking
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
: whiteColorForMarking? (* color-byte -- True or False *)
  ColorOffsetForMarking fetchBit White == Exit
; defineFunction

: blackColorForMarking? (* color-byte -- True or False *)
  ColorOffsetForMarking fetchBit Black == Exit
; defineFunction

: black-<pair>? (* [address, <pair-like>] -- True or False *)
  clr blackColorForMarking? Exit
; defineFunction


(* the following function is the only function who pushGreyPairStack
 ,* and this function is called by one,grey->black and so on *)
:" try,white->grey said:
   ``My function-type is ( [address, <pair-like>] -- [address, <pair-like>] ).
     But the type of the TypedValue I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,try,white->grey,typeError ; defineConstString
: try,white->grey (* [address, <pair-like>] -- [address, <pair-like>] *)
  duplicate <not-pair-like>? if
    String,try,white->grey,typeError printString  
    duplicate printTypeTag cr
    debuger
    Exit  
  then
  twoDuplicate clr
  duplicate
  whiteColorForMarking? if
    ColorOffsetForMarking setBit set-clr!

    try,copy-substring,from->to,forCar
    try,copy-substring,from->to,forCdr
    over pushGreyPairStack
    Exit
  then
  drop (* drop the color-byte *) Exit  
; defineFunction


: one,try,grey->black (* -- *)
  emptyGreyPairStack? if
    Exit
  then
  popGreyPairStack duplicate
    fetchTwo duplicate <pair-like>? if
      try,white->grey
    then twoDrop
    CarBytesSize +
    fetchTwo duplicate <pair-like>? if
      try,white->grey
    then twoDrop
  Exit
; defineFunction


(* the following is a help-function of all,grey->black
 ,* the GreyPairStack must not be empty when it is called *)

: one,grey->black (* -- *)
  popGreyPairStack duplicate
    fetchTwo duplicate <pair-like>? if
      try,white->grey
    then twoDrop
    CarBytesSize +
    fetchTwo duplicate <pair-like>? if
      try,white->grey
    then twoDrop
  Exit
; defineFunction

: all,grey->black (* -- *)
  emptyGreyPairStack? if
    Exit
  then
  one,grey->black
  all,grey->black Exit
; defineRecursiveFunction
#+end_src
*** set!, set-car!, set-cdr!
in xiaolinguist, to make the gc to be incremental
there are many strategies you can use
the following shows one of them
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
: set!
  (* VarForTypedValue[address], [value, type] -- VarForTypedValue[address] *)
  duplicate <pair-like>? if
    all,grey->black (* to be incremental-gc is to call this function here *)
    try,white->grey
  then
  x|over|xx saveTwo
  Exit
; defineFunction

: help,set-car!&set-cdr!,for-black-<pair>
  (* [valus, type] -- [valus, type] *)
  duplicate <pair-like>? if
    all,grey->black (* to be incremental-gc is to call this function here *)
    try,white->grey
  then
  Exit
; defineFunction

:" set-car! said:
   ``My function-type is (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *).
     But there must be something wrong with the arguments that I received.
     If I view the third argument as a type-tag,
     it will be as the following,
     I will not touch it and call debuger.''
   --> "
: String,set-car!,typeError ; defineConstString

: set-car!
  (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
  x|over|xx duplicate  <not-pair-like>? if
    String,set-car!,typeError printString  
    printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag overed *)
  xx|over|xx black-<pair>? if
    help,set-car!&set-cdr!,for-black-<pair>
  then
  x|over|xxx saveTwo
  Exit
; defineFunction


:" set-cdr! said:
   ``My function-type is (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *).
     But there must be something wrong with the arguments that I received.
     If I view the third argument as a type-tag,
     it will be as the following,
     I will not touch it and call debuger.''
   --> "
: String,set-cdr!,typeError ; defineConstString

: set-cdr!
  (* [address, <pair-like>], [valus, type] -- [address, <pair-like>] *)
  x|over|xx duplicate  <not-pair-like>? if
    String,set-cdr!,typeError printString  
    printTypeTag cr
    debuger Exit
  then
  drop (* drop the type-tag overed *)
  xx|over|xx black-<pair>? if
    help,set-car!&set-cdr!,for-black-<pair>
  then
  x|over|xxx CarBytesSize + saveTwo
  Exit
; defineFunction
#+end_src
*** marking & define
define和set!都是动态类型系统的接口
但是define和set!的使用方式非常不同
1. set!之所以把address作为靠近栈底的参数
   而把带有动态类型标签的值作为靠近栈顶的参数
   是因为这样在求被动态类型的值的时候 就可以引用到前面的address了
2. 而define要读一个字符串并把它作为名字 向字典中编撰一个新的Word
   它与set!的性质本身就是有很大区别的
3. 我对define的实现方式限制了它的使用
   而使得每次使用define定义一个新的Word的时候都必须要初始化它的value与type
4. define并不像set!一样返回值
   这是因为
   我说``每个表达式都要返回值''的时候 是就我要写类scheme的编译器而言的
   define是一个(特殊的)字典编撰者
   在我的forth系统中让它返回值显然是不合理的
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
(* recall
 ,* a word in the dictionary [unit : CellWidth = 8 bytes]
 ,*   ||  1 : name-string-header-which-contains-the-length-of-name-string  ||
 ,*   ||  m : name-string  ||
 ,*   ||  1 : SizeOfFunctionBody  ||
 ,*   ||  1 : identification  ||
 ,*   ||  1 : link  ||
 ,*   ||  1 : type  ||
 ,*   ||  1 : address-of-name-string-header  ||
 ,*   ||  1 : address-of-explainer  ||
 ,*   ||  n : body  ||
 ,* where
 ,*   ||  1 : type  ||
 ,* ==
 ,*   | type-bit-63 | ... | type-bit-1 | type-bit-0 |
 ,* type-bit-0 is for HiddenWord
 ,* type-bit-1 is for VariableOfTypedValue
 ,*)

: createWordHeaderForTypedValue
  (* string[address, length] -- word[address of link] *)
    Here fetch xx|swap|x (* address-of-name-string-header *)
    appendStringToHere
    Here fetch appendNumberToHere (* identification *)
    Here fetch (* leave the word[link] *)
    Zero appendNumberToHere (* link *)
    Two appendNumberToHere  (* type *)
    swap
    appendNumberToHere (* address-of-name-string-header *)
    Exit
; defineFunction


: define
  (* [value, type], wordList[address, the number of words] -- *)
    tailAndHeadOfWordList
    createWordHeaderForTypedValue
    VarExplainer appendNumberToHere
    xx|swap|x twoDrop xx|swap|x  (* leave wordHeader *)
    duplicate <pair-like>? if
      try,white->grey
    then
    appendNumberToHere appendNumberToHere
    addNewWordToDictionary
    Exit
; defineFunction
#+end_src
*** finding & cons(<pair>)
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
(* the following functions are helping cons *)

: clearColorBitOfPairForClearing (* pair[address] -- pair[address] *)
    <pair>
    twoDuplicate clr
    ColorOffsetForClearing clearBit
    set-clr!
    drop
    Exit
; defineFunction

: whiteColorForFinding? (* color-byte -- True or False *)
    ColorOffsetForFinding fetchBit White ==
    Exit
; defineFunction

: findNextFreePairConstruction
  (* pair[address] -- Zero or NextFreePairConstruction[address] *)
    duplicate LastPairConstruction == if
      drop Zero Exit
    then
    ConsBytesSize +
    clearColorBitOfPairForClearing
    duplicate <pair> clr
    whiteColorForFinding? if
      Exit
    then
    findNextFreePairConstruction
    Exit
; defineRecursiveFunction



(* 三阶置换群中的两个三周期循环置换之中的一个
 ,* VariableColorOffsetForFinding   -->  VariableColorOffsetForClearing
 ,* VariableColorOffsetForMarking   -->  VariableColorOffsetForFinding
 ,* VariableColorOffsetForClearing  -->  VariableColorOffsetForMarking
 ,*)
: resetColorOffsets (* -- *)
    VariableColorOffsetForFinding  fetch
    VariableColorOffsetForMarking  fetch
    VariableColorOffsetForClearing fetch
    VariableColorOffsetForMarking  save
    VariableColorOffsetForFinding  save
    VariableColorOffsetForClearing save
    Exit
; defineFunction



: dynamicVariableWordFor<pair-like>? (* word[address of link] -- True or False *)
    duplicate dynamicVariableWord? if
    wordLinkToWordExplainer execute fetchTwo
    swap drop
    <pair-like>?
    Exit
    then
    drop False Exit
; defineFunction

: help,pushAllRootNodeIntoGreyPairStack (* word[address of link] -- *)
    duplicate lastWordInTheDictionary? if
      drop Exit
    then
    duplicate dynamicVariableWordFor<pair-like>? if
    duplicate wordLinkToWordExplainer execute fetchTwo
    try,white->grey twoDrop
    then
    nextWordInTheDictionary
    help,pushAllRootNodeIntoGreyPairStack
    Exit
; defineRecursiveFunction

: pushAllRootNodeIntoGreyPairStack (* -- *)
    FirstWordInDictionary fetch
    help,pushAllRootNodeIntoGreyPairStack
    Exit
; defineFunction



(* 在我看来下面这个函数是``非内蕴的''
 ,* 因而是不好的函数
 ,* 但是无奈这是我所使用的这种动态类型系统的弱点之一
 ,*)

(* 满足下面三个条件的Value被我认为是AddressOfPair
 ,* [下面的等式和不等式 是用中缀表达式表示的]
 ,* 1. Value >= FirstPairConstruction
 ,* 2. Value <= LastPairConstruction
 ,* 3. [Value - FirstPairConstruction] mod ConsBytesSize == 0
 ,*)

: addressOfPair? (* value -- Ture or False *)
    duplicate FirstPairConstruction < if
      drop False Exit
    then
    duplicate LastPairConstruction > if
      drop False Exit
    then
    FirstPairConstruction - ConsBytesSize mod zero?
    Exit
; defineFunction



: help,allPairsInArgumtStack,try,white->grey
  (* address of a Cell in ArgumtStack -- *)
    duplicate ArgumtStackTop > if
      drop Exit
    then
    duplicate fetch addressOfPair? if
      duplicate fetch
      <pair> try,white->grey
      twoDrop
    then
    CellWidth +
    help,allPairsInArgumtStack,try,white->grey
    Exit
; defineRecursiveFunction

(* tryToDarkenAllWhirtPairsInArgumtStack *)
: allPairsInArgumtStack,try,white->grey (* -- *)
    fetchArgumtStackPointer
    help,allPairsInArgumtStack,try,white->grey
    Exit
; defineFunction




: resetVariablesAboutString (* -- *)
  CurrFreeStringAddress,to fetch CurrFreeStringAddress,from save
  Variable,StringHeap,from fetch CurrFreeStringAddress,to   save
  Variable,StringHeap,to   fetch Variable,StringHeap,from   save
  CurrFreeStringAddress,to fetch Variable,StringHeap,to     save
  Exit
; defineFunction



:" cons said: ``Memory for cons is used up! No value is returned!''"
: String,cons,MemoryIsUsedUp ; defineConstString

: cons (* -- [address, <pair>] *)
    CurrFreePairConstruction fetch <pair> (* leave the return <value> *)
    CurrFreePairConstruction fetch findNextFreePairConstruction
    duplicate notZero? (* Zero denotes fail to find *) if
      CurrFreePairConstruction save
      Exit
    then drop (* drop the Zero, which denotes fail to find, need gc *)
    allPairsInArgumtStack,try,white->grey
    all,grey->black
    resetColorOffsets resetVariablesAboutString (* note the timing to reset *)  
    pushAllRootNodeIntoGreyPairStack
    InFrontOfTheFirstPairConstruction findNextFreePairConstruction
    duplicate notZero? if
      CurrFreePairConstruction save
      'space' ':' 'g' 'c' ':' 'space'
       writeChar writeChar writeChar writeChar writeChar writeChar
      Exit
    then drop
    (* if after gc still fail to find, we know the memory is used up *)
    twoDrop
    String,cons,MemoryIsUsedUp printString cr
    debuger
    Exit
; defineFunction
#+end_src
*** syntax sugar
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
: [* (* -- [address, <pair>] *)
  cons Exit
; defineFunction

: *] (* [address, <pair>], [value, type of car], [value of cdr, type] --
        [address, <pair>] *)
  xx|swap|xxxx
  xx|swap|xx
  set-cdr!
  xx|swap|xx
  set-car!
  Exit
; defineFunction
#+end_src
*** <string>
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
: read-string (* -- [address, <string>] *)
  cons drop (* drop <pair> *) <string>
  s" drop (* drop length *) <substring>
  set-cdr!
  Null <null> set-car!
  Exit
; defineFunction

: ::" (* -- [address, <string>] *)
  read-string Exit
; defineFunction


:" write-string said:
   ``My function-type is ( [address, <string>] -- ).
     But the type of the TypedValue I received is the following,
     I will not touch it and call debuger.''
   --> "
: String,write-string,typeError ; defineConstString

: write-string (* [address, <string>] -- *)
  duplicate <string> =/= if
    String,write-string,typeError printString  
    duplicate printTypeTag cr
    debuger Exit
  then
  cdr drop (* drop <substring> *)
  duplicate getLengthOfString printString
  Exit
; defineFunction
#+end_src
*** about test
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
(* for test *)
: printTypeOfIt (* type -- *)
  printTypeTag ':' writeChar writeSpace Exit
; defineFunction

(* test: gc *)
: ask-for-lots-of-cons (* n -- *)
    duplicate zero? if drop Exit
    then
    sub1
    [* literal 555 <fixnum>
       literal 666 <fixnum> *]
    twoDrop
    ask-for-lots-of-cons
    Exit
; defineRecursiveFunction

: ask-for-lots-of-cons,leave-them-on-the-ArgumtStack (* n -- *)
    duplicate zero? if drop Exit
    then
    sub1
    [* literal 555 <fixnum>
       literal 666 <fixnum> *]
    x|swap|xx
    ask-for-lots-of-cons,leave-them-on-the-ArgumtStack
    Exit
; defineRecursiveFunction
#+end_src
** test
#+begin_src xiaolinguist
(* test: define *)
6 <fixnum> : Liu-fixnum ; define
Liu-fixnum fetchTwo printTypeOfIt . cr (* <fixnum>: 6 *)

(* test: cons *)
cons 9 <fixnum> set-car!
     8 <fixnum> set-cdr!
twoDuplicate
  car printTypeOfIt . cr (* <fixnum>: 9 *)
twoDuplicate
  cdr printTypeOfIt . cr (* <fixnum>: 8 *)
twoDrop

[* 9 <fixnum>  8 <fixnum> *]
twoDuplicate
  car printTypeOfIt . cr (* <fixnum>: 9 *)
twoDuplicate
  cdr printTypeOfIt . cr (* <fixnum>: 8 *)
twoDrop


(* test: define a pair *)
cons 9 <fixnum> set-car!
     8 <fixnum> set-cdr!
: Simple-pair ; define
Simple-pair fetchTwo
twoDuplicate
  car printTypeOfIt . cr (* <fixnum>: 9 *)
twoDuplicate
  cdr printTypeOfIt . cr (* <fixnum>: 8 *)
twoDrop


(* test: set-car! & set-cdr! *)
Simple-pair fetchTwo
  [* 7 <fixnum>   6 <fixnum> *]
set-car!
twoDuplicate
  car car printTypeOfIt . cr (* <fixnum>: 7 *)
twoDuplicate
  car cdr printTypeOfIt . cr (* <fixnum>: 6 *)
twoDrop




Simple-pair fetchTwo
  [* 5 <fixnum>
     [* 4 <fixnum>  3 <fixnum> *] *]
set-cdr!

twoDuplicate
  car car printTypeOfIt . cr (* <fixnum>: 7 *)
twoDuplicate
  car cdr printTypeOfIt . cr (* <fixnum>: 6 *)
twoDuplicate
  cdr car printTypeOfIt . cr (* <fixnum>: 5 *)
twoDuplicate
  cdr cdr car printTypeOfIt . cr (* <fixnum>: 4 *)
twoDuplicate
  cdr cdr cdr printTypeOfIt . cr (* <fixnum>: 3 *)
twoDrop





(* 上面有的 pair 被放进 GreyPairStack 了 *)
(* test: all,grey->black *)
 (* emptyGreyPairStack? . cr (* 0 *)
 (* all,grey->black
 (* emptyGreyPairStack? . cr (* 1 *)

(* test: marking *)
 (* Simple-pair fetchTwo
 (* cdr cdr clr ColorOffsetForMarking fetchBit . cr (* 1 *)







all,grey->black

(* 如果在测试下面这段的时候 先执行上面的函数 那么就会出现bug *)

(* test: reset set-cdr! *)
Simple-pair fetchTwo
  [* 1 <fixnum>
     [* 2 <fixnum>  3 <fixnum> *] *]
set-cdr!

twoDuplicate
  car car printTypeOfIt . cr (* <fixnum>: 7 *)
twoDuplicate
  car cdr printTypeOfIt . cr (* <fixnum>: 6 *)

twoDuplicate
  cdr car printTypeOfIt . cr (* <fixnum>: 1 *)
twoDuplicate
  cdr cdr car printTypeOfIt . cr (* <fixnum>: 2 *)
twoDuplicate
  cdr cdr cdr printTypeOfIt . cr (* <fixnum>: 3 *)
twoDrop



(* test: gc *)
: ask-for-lots-of-cons (* n -- *)
    duplicate zero? if drop Exit
    then
    sub1
    [* literal 555 <fixnum>
       literal 666 <fixnum> *]
    twoDrop
    ask-for-lots-of-cons
    Exit
; defineRecursiveFunction


NumberOfPairConstructions ask-for-lots-of-cons

NumberOfPairConstructions 30 * ask-for-lots-of-cons




(* after gc the Simple-pair must still be ok *)
Simple-pair fetchTwo

twoDuplicate
  car car printTypeOfIt . cr (* <fixnum>: 7 *)
twoDuplicate
  car cdr printTypeOfIt . cr (* <fixnum>: 6 *)
twoDuplicate
  cdr car printTypeOfIt . cr (* <fixnum>: 1 *)
twoDuplicate
  cdr cdr car printTypeOfIt . cr (* <fixnum>: 2 *)
twoDuplicate
  cdr cdr cdr printTypeOfIt . cr (* <fixnum>: 3 *)
twoDrop



(* ----------------------------------------------------------- *)
(* after gc the values in the stack must still be ok *)

[* [* 147 <fixnum>
      258 <fixnum> *]
   369 <fixnum> *]

NumberOfPairConstructions 30 * ask-for-lots-of-cons

twoDuplicate 

cr
twoDuplicate
   car car printTypeOfIt . cr (* <fixnum>: 147 *)
twoDuplicate
   car cdr printTypeOfIt . cr (* <fixnum>: 258 *)
twoDuplicate
   cdr printTypeOfIt . cr (* <fixnum>: 369 *)
twoDrop
ok

NumberOfPairConstructions 30 * ask-for-lots-of-cons

cr
twoDuplicate
   car car printTypeOfIt . cr (* <fixnum>: 147 *)
twoDuplicate
   car cdr printTypeOfIt . cr (* <fixnum>: 258 *)
twoDuplicate
   cdr printTypeOfIt . cr (* <fixnum>: 369 *)
twoDrop
ok





(* ----------------------------------------------------------- *)
(* about string *)
(* after gc the values in the stack must still be ok *)


::" 111 " 
NumberOfPairConstructions  ask-for-lots-of-cons
::" 222 "   
NumberOfPairConstructions  ask-for-lots-of-cons
::" 333 "   
NumberOfPairConstructions  ask-for-lots-of-cons
NumberOfPairConstructions  ask-for-lots-of-cons
cr ok 

write-string write-string write-string (* 333 222 111 *)
cr


::" aaa " 
: Simple-string ; define
NumberOfPairConstructions ask-for-lots-of-cons 
::" AAA "   
NumberOfPairConstructions ask-for-lots-of-cons
::" AAA "   
NumberOfPairConstructions ask-for-lots-of-cons
::" AAA "   
NumberOfPairConstructions ask-for-lots-of-cons
::" AAA "   
::" AAA "   
::" AAA "   
NumberOfPairConstructions 20 * ask-for-lots-of-cons 
ok (* yse *)

Simple-string fetchTwo write-string (* aaa *)

NumberOfPairConstructions  ask-for-lots-of-cons
write-string write-string write-string (* AAA AAA AAA *)
cr
NumberOfPairConstructions  ask-for-lots-of-cons
write-string write-string write-string (* AAA AAA AAA *)
cr





(* ----------------------------------------------------------- *)
(* about using up memory *)


(* 
 ,* NumberOfPairConstructions
 ,* ask-for-lots-of-cons,leave-them-on-the-ArgumtStack
 ,* 
 ,* 
 ,* (\* in debugREPL: *\)
 ,*   1 debuger,fetchFromReturnStack traceFunction
 ,*   2 debuger,fetchFromReturnStack traceFunction
 ,* 
 ,* basicREPL countArgumtStack . cr (\* 0 *\)
 *)
#+end_src
* index-hashback->string & string-hash->index
** note
1. hash-function (string)
   ==>
   (sum-up [byte_n * 2^n]) mod NumberOfSymbolEntrys
   + where:
     0 <= n < SymbolMaxLength
     and NumberOfSymbolEntrys is a prime number
   after sum-up,
   the greatest number < 2^(SymbolMaxLength + 8)
   so I let SymbolMaxLength == 64 - 8 == 56
3. ``string-hash->index index-hashback->string''
   is a identity function
   and if the argumt is a index returned by ``string-hash->index''
   ``index-hashback->string string-hash->index''
   also is a identity function
** implementation
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
(* a SymbolEntry [unit : byte]
 ,* ========================
 ,*   ||  1 : SymbolLength  ||
 ,* ------------------------
 ,*   || 56 : SymbolString  ||
 ,* ========================
 ,* where SymbolMaxLength = 56
 ,*)

: index->address (* index -- address *)
    SymbolEntryBytesSize *
    FirstSymbolEntry +
    Exit
; defineFunction

: index-hashback->string
  (* index -- string[address, length] *)
    index->address
    duplicate add1 swap
    fetchByte
    Exit
; defineFunction


: help,string-hash->index,sum-up
  (* sum-up , string[address, length] -- sum-up *)
    duplicate zero? if
      twoDrop Exit
    then
    tailAndHeadOfString
    over shiftLeft
    x|swap|xxx  +  xx|swap|x
    help,string-hash->index,sum-up
    Exit
; defineRecursiveFunction

: help,string-hash->index,find-old-or-creat-new
  (* string[address, length], index -- index *)
    xx|tuck|x index-hashback->string
    duplicate zero? if  (* creat-new *)
      drop
      over over sub1 saveByte
      swap copyByteString
      Exit
    then
    xx|over|xx equalString? if (* found old *)
      twoDrop Exit
    then
    x|swap|xx (* to get next-index *)
    duplicate index->address LastSymbolEntry == if
      drop
      Zero
      help,string-hash->index,find-old-or-creat-new
      Exit
    then
    add1
    help,string-hash->index,find-old-or-creat-new
    Exit
; defineRecursiveFunction

: string-hash->index
  (* string[address, length] -- index *)
    twoDuplicate
      Zero xx|swap|x
        duplicate SymbolMaxLength > if
          drop SymbolMaxLength
        then
      help,string-hash->index,sum-up
      NumberOfSymbolEntrys mod
    help,string-hash->index,find-old-or-creat-new
    Exit
; defineFunction
#+end_src
** test
#+begin_src xiaolinguist
NumberOfSymbolEntrys 1 -
index->address LastSymbolEntry == . (* 1 *)

:" a" string-hash->index . cr
:" b" string-hash->index . cr
:" c" string-hash->index . cr

:" k" string-hash->index . cr
:" kk" string-hash->index . cr
:" kkk" string-hash->index . cr
:" kkkk" string-hash->index . cr
:" kkkkk" string-hash->index . cr
:" kkkkkk" string-hash->index . cr
:" kkkkkkk" string-hash->index . cr
:" kkkkkkkk" string-hash->index . cr
:" kkkkkkkkk" string-hash->index . cr
:" kkkkkkkkkk" string-hash->index . cr
:" kkkkkkkkkkk" string-hash->index . cr
:" kkkkkkkkkkkk" string-hash->index . cr
:" kkkkkkkkkkkkk" string-hash->index . cr
:" kkkkkkkkkkkkkk" string-hash->index . cr
:" kkkkkkkkkkkkkkk" string-hash->index . cr
:" kkkkkkkkkkkkkkkk" string-hash->index . cr
:" kkkkkkkkkkkkkkkkk" string-hash->index . cr

(* NumberOfSymbolEntrys : 10_0333 , 10_0003
   97      97
   98      98
   99      99
   107     107
   321     321
   749     749
   1605    1605
   3317    3317
   6741    6741
   13589   13589
   27285   27285
   54677   54677
   9128    9458
   18363   19023
   36833   38153
   73773   76413
   47320   52930
   94747   5964
   89268   12035
   78310   24177
  ,*)

(* test: collision *)
(*  'A'*2 + 'c' = 'B'*2 + 'a' *)
:" Ac" string-hash->index . cr (* 229 *)
:" Ba" string-hash->index . cr (* 230 *)

:" A"
  string-hash->index index-hashback->string
printString

:" Ac"
  string-hash->index index-hashback->string
printString

:" Ba"
  string-hash->index index-hashback->string
printString

(* test: rounding *)

(* when: NumberOfSymbolEntrys = 10_0003 *)
10_0003 .bin (* 11000011010100011 *)

(* when: NumberOfSymbolEntrys = 10_0333 *)
10_0333 .bin (* 11000011111101101 *)

(* I do not want to solve two funny equations about ascii-chars,
 ,* just to test the two ``NumberOfSymbolEntrys'' above !!!???
 ,* so, to test this, I reset ``NumberOfSymbolEntrys'' to 230, in assembler,
 ,* then the greatest index == 229,
 ,* then to test collision is to test rounding
 ,*)

:" Ac" string-hash->index . cr (* 229 *)
:" Ba" string-hash->index . cr (* 0 *)

:" Ac"
  string-hash->index index-hashback->string
printString

:" Ba"
  string-hash->index index-hashback->string
printString
#+end_src
* ><><>< <symbol> (new lexicographers)
** note
1. a symbol
   when compared, is as a fixnum (hash-table-index) 
   when read and write, is as a string 
   hash-function 在每次运行过程中
   都必须假装自己是一个数学意义上的可逆函数
   但是其实 重启xiaolinguist之后 这个函数可能是不同的函数
   是因为要处理hash-function本质上的非可逆性 所以出现了这样的不好的性质
2. <symbol>是不使用gc的
   这个hash-table只有非常单调的任务
   这是一个只读的hash-table
4. 一个可嵌套的<symbol> list的语义可能是:
   1) 匿名函数
      此时你可以编译这个函数 并且声明其中的某些symbol代表变元
      你可以把它保存起来
      并且随时重新编译这个函数的任何部分
      并且随时重新声明其中的任何位置为变元
      因为xiaolinguist的语法是就函数复合而优化的
      所以 表达匿名函数的作用的时候稍微有些麻烦
      必须用一个明显的apply来将函数作用到参数上面
      我使用LambdaStack来保存需要被作用的函数
      在λ-cal中 最重要的是要形成``代入''的语义
      而这时就必须使用``形式变元''
      除非用有向图处理语言来表达 否则形式变元的使用是无法避免的
      形式变元是用来标记代入的位置的
      scheme利用closure来实现嵌套的标记
      而我利用有向图的语义来实现嵌套的标记
      #+begin_src xiaolinguist
      1 2 '[x y +] 'x 'y lambda ready apply
      "abc" "123" [ string-eq? ] lambda
      [  ] lambda ready apply
      #+end_src     
   2) 数据(即 sexp)
      此时你可以对sexp进行列表处理(list processing)
5. 但是对列表数据类型的使用方式还需要好好的设计
   最严重的问题是编译器的行为和repl的行为方式不一致
   在我看来编译器显然要比repl重要 使用起来也更灵活
   我不可能把 所有的语法关键词都定义两遍
   所以任何时候我都只定义跟函数定义(即编译性的)的语法关键词
   比如在repl中把一个sexp编译成lambda-function并且入栈
   就可以利用":;"读一个需要被语法解析的word-list来使用
   #+begin_src xiaolinguist
   [ + ]  lambda
   #+end_src
** about joy
1. joy其实就是forth外加一个处理用list表示的forth程序的解释器
   但是其实没有这么简单 类似于scheme中的eval的解释器
   只是所谓的``combinators''中最简单的一个而已
2. 注意在joy中函数不是也不可能是一等公民
   但是这些丰富的解释器比我所设计的所谓灵活的编译器要强大多了
3. 这种解释器可以具有类似lexical-scope的性质
   只要让[a b c]被读入的时候就去把它们作代表的函数的地址找来就行了
   这样就非常灵活
   输入列表的时候可以选择是否编译
   执行的时候也可以选择是否解释
   换一种说法就是可以以明显的方式控制查字典者的工作方式
4. 这些所谓的``combinators''正式我想要的explainers
5. joy其实是forth外加一个rsexp的解释器
   rsexp == reversed sexp
6. joy也提供了匿名机制
   这与forth相反
   这也与wordy-lisp相反
   形象地说 匿名机制就是
   你说出了一段话
   但是你是让一个人现在就去逐字逐句地查字典以理解你的话
   而不是把你所说的话写进字典里
   然后让诠释者以特定的方式诠释你的话
7. 名词的word会将一些值入栈
   而某些形成副作用的动词的word
   1) 其主语是`我'
   2) 宾语是它所接受的参数
   3) 间接宾语是被它的副作用所影响到的世界
9. To make the recursion possible,
   every call of the anonymous function
   must be able to access itself again,
   and this is done by giving it
   its own body as a quoted parameter on the top of the stack.
** implementation (to use the above hash-function)
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl

#+end_src
** test
#+begin_src xiaolinguist

#+end_src
* ><>< define Words in the PairConstructionsArray
>< 可能需要实现新的``find''函数来衔接两个字典
或者说来衔接用来撰写字典的两种质地的材料
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl

#+end_src
* ><>< reader of sexp
内存中的数据结构 <--reader-- 字符串
关于各种进制的数的read有多种方案:
1. 为各种不同的进位制定义不同的reader
2. 为各种进位制的数字设计不同的书写格式
   在一个reader中分类处理这些数字
3. 通过改变全局变量Base而实现对一个单一的reader控制
   进而实现对各种不同进位制的数read
一般的语言都采用这种方式2.
而方式3.是最不好的方式 因为它使得代码的语义依赖于语境
我选择方式1.
这样现有的literal就是不够的了
必须根据不同的进制写多种literal
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl

#+end_src
* ><>< writer of sexp
字符串 <--writer-- 内存中的数据结构
2. writer所写出来的东西要能够不经更改就被reader所读入
   并且还要形成对结构化的数据(比如sexp)的直接读写
   也就是要形成一对互逆的函数
   + 但是其实不是函数因为reader是在解析字符串人后形成副作用
3. 需要一些够按不同的进制打印出数字来的函数
   还需要根据Base这个变量来打印数字的函数
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl

#+end_src
* ><>< module system
>< HiddenWord这个类型的Word是不是可以用来实现模块系统 ???
因为模块系统其实就是对命名空间的控制
所以写出一个lib之后
只要把想要隐藏的Word设为HiddenWord类型的Word就行了
+ 其实并不是这么简单
  比如在没有模块系统的时候
  虽然xiaolinguist对载入的代码的处理是纯粹线性的
  但是因为每次都没能明确的指出后面一个函数的定义
  到底如何依赖于前面的很多函数中的那些
  所以在修改代码的时候我必须仔细地检查依赖关系
+ 应该如何解决上面的问题呢???
  函数之间的定义与被定义关系形成的是lattice而不是tree
  就文本编辑器的用户接口的设计而言 我可以参考ranger
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl

#+end_src
* ><>< exception
exception是用来实现非单步退出的
forth的exception机制是throw和catch
这是不是有点像scheme的call/cc
当然不是了
因为没有函数的作用这种语义
就没法有call-with-*这种语义
但是forth的catch可以被看成是一个特殊的execute
而execute是可以模仿函数作用语义的
+ 在古典的forth中
  ['] function 就会把function的explainer入栈
  然后execute就可以用来转跳到那个explainer
  这样就形成了对在栈中的(作为数据的)function的解释
  并且forth的throw和catch本身就是对lisp的模仿
+ 注意call/cc中的cc是一个一元函数 !!!
* --------------------------------------------------
* ok
for the repl is actually a rel which does not print
so I provide a word to check that the xiaolinguist is working properly
#+begin_src xiaolinguist :tangle ./play/xiaolinguist.xl
: ok (* -- *)
    'y' writeChar
    'e' writeChar
    's' writeChar
    'space' writeChar
    Exit
; defineFunction
#+end_src
* byebye
#+begin_src xiaolinguist :tangle ./play/byebye.xl
(* usage:
 to play with xiaolinguist
 make a script file as the following
 ,* ------------- file begin -------------
 #!/bin/bash
 export xiaolinguist_play_directory=/home/xyh/xiaolinguist/play
 cat ${xiaolinguist_play_directory}/xiaolinguist.xl - ${xiaolinguist_play_directory}/byebye.xl | ${xiaolinguist_play_directory}/xiaolinguist
 ,* ------------- file end -------------
 ,*)

'b' writeChar
'y' writeChar
'e' writeChar

'b' writeChar
'y' writeChar
'e' writeChar
#+end_src
* ==================================================
* text editor
** note
对于xiaolinguist的代码来说
text editor因该有什么样的性状才合适呢 ???
1. 基本的语法高亮
   以不同的颜色高亮某些语义不同的元素
   能够减轻代码的阅读者的认知方面的负担
   但是因为 解释器,编译器,文本编辑器 所能够识别的都只是语法而已
   所以 文本编辑器的这种功能被称作``语法高亮''而不是``语义高亮''
   但是 对于 xiaolinguist 和forth 这种没有语法的语言而言
   文本编辑器对语义不同的元素的识别
   是通过做一些合适的约定来完成的
   一个用户只有遵守文本编辑器所做的约定 其代码才能被正确高亮
2. 没有自动缩进 而使用手工缩进
   这样对代码的排版就更灵活
   因此 需要提供方便的函数来帮助手工缩进
3. 函数之间的定义和被定义关系 是 离散偏序集
   在我看来 xiaolinguist 和 forth 这类语言最大的优点在于
   它的简洁性在教你去解决问题
   即forth用户常说的``factoring''
   当你需要定义一个函数来完成一个任务
   在定义这个函数之前你就知道这个函数一定将是很多函数复合而成的
   所以你的任务就是去寻找一种将其他的函数复合起来的方式
   以形成一个能完成你所需要的任务的函数
   三个函数的复合满足结合律 所以 多个函数的复合满足广义结合律
   对于满足结合律的整数乘法 你常常要分解一个整数
   类似地 在这里你要分解一个函数
   分解一个整数的目的也许是为了获得一种
   更有利于乘法和除法运算的对这个整数的表示方式
   而当你以不同的方式分解一个函数
   可能你就会对这个函数形成不同的理解方式
   所以我想 分解一个函数的目的是为了形成对这个函数的最好的理解方式
   当你以不同的方式分解一个函数
   可能机器计算这个函数时对时间和空间的消耗程度也不同
   所以 分解一个函数的目的也可以是为了获得最优的计算速度或最节省内存
   在 xiaolinguist 与 forth 中
   你是通过``作定义,以明显地命名''这种方式
   来形成对一个函数的各种不同的分解的
   所以将有非常多的函数定义
   我自然地希望文本编辑器能够帮助我管理
   函数之间的定义与被定义关系所形成的离散偏序集
   文本编辑器为了完成这个任务所需要的数据结构可能是这样的
   首先 函数按语义被组织成一组一组的
   偏序集的节点将是这些函数的小组 而不是单个的函数
   我用``上,下''这两个词来描述偏序关系
   这是自然的 因为在代码的文本中
   被替他函数定义的函数自然在其他函数的下面
   在代码的文本中 从每一个function-group的位置
   向上查找就能找到所有在这个节点之上的节点
   向下查找就能找到所有在这个节点之下的节点
   注意向下查找的时候
   对这function-group中的某些函数的重复定义将限制查找这些函数的范围
4. 对于上面所描述的这个文本编辑器的功能
   用户接口将是一个代码浏览器
   能够帮你从一个function-group走到另外的function-group
* ==================================================
* demo
** note
1. 我只 挑出来少量的性状来做展示
   我将 按我的理解方式来简单的把需要被展示的特性分类
   并介 绍一些我使用的术语
3. 我从 最简单而有趣的例子开始
4. 我来 通过展示代码来形象化对上面的某些特性的介绍
5. 通过 对比其他语言来说明我的设计的合理性
6. 最后我来指出你能获得更详细的关于xiaolinguist的文档的方式
   包括:
   1) 历史传承
   2) 设计哲学
   3) 实现技术
   4) 数学背景
7. 最后我做一下回顾性的总结
** 论文
*** note
向中文读者介绍一下垃圾回收器
并且附上xiaolinguist的用中文和英文对这个垃圾回收器的实现
并且说明这个垃圾回收器的限制(省略对字符串的处理)
并且说明xiaolinguist的一些东西
*** ><
对程序语言的设计者而言垃圾回收器是一个有趣的难题




